<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"nobug.world","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="TDD 实现 DI 容器简介TDD 的难点首先在于理解需求，并将需求分解为功能点。 以  Jakarta EE 中的 Jakarta Dependency Injection 为主要功能参考，并对其适当简化，以完成我们的目标 实现 DI 时参考 Jakarta Dependency Injection，其中的功能主要分为三部分：  注入点的支持、组件的构造  依赖的选择  生命周期控制（多例和单例">
<meta property="og:type" content="article">
<meta property="og:title" content="TDD实现Spring（DI容器）">
<meta property="og:url" content="https://nobug.world/blogs/25729/index.html">
<meta property="og:site_name" content="nobug.world">
<meta property="og:description" content="TDD 实现 DI 容器简介TDD 的难点首先在于理解需求，并将需求分解为功能点。 以  Jakarta EE 中的 Jakarta Dependency Injection 为主要功能参考，并对其适当简化，以完成我们的目标 实现 DI 时参考 Jakarta Dependency Injection，其中的功能主要分为三部分：  注入点的支持、组件的构造  依赖的选择  生命周期控制（多例和单例">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-08_16-20-52.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-09_15-41-19.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-09_15-41-51.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240809161723867.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240809184214486.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240809185759277.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240809191402158.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240809194930682.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-09_19-43-11.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240810095457438.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240810101133637.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240810110504080.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240810110639340.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240810110805138.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-10_11-36-38.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240810113656568.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-10_11-39-45.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240810115120039.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812095213493.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812100841607.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-12_10-27-52.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812104907259.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-12_11-40-11.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812110730534.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812111635721.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812112111509.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-12_11-40-11.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812140847037.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812142838411.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-12_14-42-35.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812144651351.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-12_14-50-35.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812145737955.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-12_15-02-46.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812150633641.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-12_15-09-43.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-12_15-15-52.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812153821742.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-12_15-42-40.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-12_15-43-10.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812160514288.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-12_16-10-12.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812162507968.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-12_16-26-15.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-12_16-26-45.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812162800695.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812164601445.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240812164702951.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-12_16-51-08.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240813102203192.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240813102811774.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-13_11-02-35.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-13_11-40-48.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240813114315788.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-13_14-51-24.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240813151931496.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240813170732077.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240813175302973.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814102238573.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814114238683.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814115236417.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-14_12-03-14.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-14_13-43-13.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814134740365.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814135151138.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814135657701.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814151410275.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-14_15-26-55.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-14_15-28-06.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814153437033.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814153602000.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814153744147.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814153851651.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-14_15-59-28.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814160224365.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-14_16-12-35.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814162037571-1723623638469-6.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814162619203.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814163326742.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814163812035.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814164435758.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814165056094.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814165358387.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814170235565.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814175622797.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240815115724375.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240815135153837.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240815135326871.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240815135441506.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240815140852626.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240815141206661.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814190544963.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814190717435.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814193426209.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814193907824.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814194214679.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814195736380.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814200226834.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814200548328.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814202044074.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814202352826.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814201633717.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814201652190.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814202727618.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-14_20-30-15.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814203236723.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-14_20-35-47.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-14_20-38-27.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814204107708.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814205149449.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814212142865.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814212502434.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814212621229.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240814213050948.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240815093415791.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240815095344716.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240815095814592.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240815144345057.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240815155136365.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240815155834612.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240815160013631.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240815170531302.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240815170616411.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816093648383.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816093851722.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816101405554.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-16_10-26-52.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816110219942.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816111741157.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816112722818.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-16_11-30-20.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816113629005.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816113543754.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816114253710.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816114722694.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816115431932.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816142714821.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816142854828.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816143124700.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816143615349.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-16_14-44-20.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816145441076.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816145519993.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816151832369.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816152614060.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-16_15-43-32.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-16_15-53-25.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816160853947.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-16_16-09-16.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816161944872.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816172206505.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816172730553.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816173312128.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240816174437894.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-16_17-56-56.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240817094941953.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240817100143695.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240817100436322.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240817101707744.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240817102416259.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240817103155965.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240817103405954.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240817110150540.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-17_11-10-00.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240817111102232.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819105209273.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240817112312997.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240817115223561.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819104016654.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-19_11-18-32.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-19_14-16-56.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-19_14-20-19.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819144934546.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819145015046.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819150104089.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819155305967.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819161618368.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819162836708.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819171549770.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-19_17-25-58.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819180342402.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819183725309.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819190900039.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819191232231.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-19_19-13-36.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819191622688.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819191940010.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819195133888.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819195927082.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819200809441.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819200844752.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819202905248.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240819204156897.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820092043644.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820093625332.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820093829851.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820100400074.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-20_10-39-36.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820111434672.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820141337390.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820141638666.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820142512043.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820143332218.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820145941249.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820150159534.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820151251760.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820153558513.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820154445155.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820154815243.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820154941586.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820155126273.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820160107174.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-20_16-01-58.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820161115163.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820161528106.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820161933112.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820162458834.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820162837117.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-20_16-32-49.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820171152367.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820171834398.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820172735344.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820192553665.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820194638100.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820195127187.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-20_19-55-36.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820200136437.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820201833198-1724156314344-16.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-20_20-37-35.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820204448777.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820204544810.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820205249652.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-20_20-59-15.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240820210355336.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240821093308594.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240821103932822.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-21_11-10-20.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-21_11-13-29.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240821111855275.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240821111943949.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240821114336444.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240821134009469.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-21_14-20-48.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240821144348995.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240821145440311.png">
<meta property="og:image" content="https://nobug.world/blogs/25729/image-20240821150535770.png">
<meta property="article:published_time" content="2024-08-21T08:02:49.000Z">
<meta property="article:modified_time" content="2024-09-05T03:27:16.701Z">
<meta property="article:author" content="彭嘉俊">
<meta property="article:tag" content="TDD">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nobug.world/blogs/25729/Snipaste_2024-08-08_16-20-52.png">


<link rel="canonical" href="https://nobug.world/blogs/25729/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://nobug.world/blogs/25729/","path":"blogs/25729/","title":"TDD实现Spring（DI容器）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>TDD实现Spring（DI容器） | nobug.world</title>
  







<link rel="dns-prefetch" href="https://blogs-waline.vercel.app/">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">nobug.world</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">软件开发的核心问题是管理复杂度</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#TDD-%E5%AE%9E%E7%8E%B0-DI-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="nav-text">TDD 实现 DI 容器简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Guice-%E6%BC%94%E7%A4%BA-DI-%E5%AE%B9%E5%99%A8%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD"><span class="nav-text">使用 Guice 演示 DI 容器如何使用，包含哪些功能</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E5%88%86%E8%A7%A3"><span class="nav-text">功能分解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="nav-text">新建项目</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E7%BA%A2-%E7%BB%BF-%E9%87%8D%E6%9E%84%E5%BE%AA%E7%8E%AF"><span class="nav-text">开始红-绿-重构循环</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TODO-instance"><span class="nav-text">TODO: instance</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95"><span class="nav-text">构造测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0"><span class="nav-text">快速实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TODO-No-args-constructor"><span class="nav-text">TODO: No args constructor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95-1"><span class="nav-text">构造测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">快速实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%9E%84"><span class="nav-text">重构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2components"><span class="nav-text">替换components</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2componentImplementations"><span class="nav-text">替换componentImplementations</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E6%80%BB%E7%BB%93"><span class="nav-text">重构总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E9%87%8D%E6%9E%84"><span class="nav-text">简单重构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TODO-with-dependencies"><span class="nav-text">TODO: with dependencies</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95-2"><span class="nav-text">构造测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E9%87%8D%E6%9E%84-1"><span class="nav-text">简单重构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0-2"><span class="nav-text">快速实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5"><span class="nav-text">第一步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5"><span class="nav-text">第二步</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TODO-A-B-C"><span class="nav-text">TODO: A -&gt; B -&gt; C</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95-3"><span class="nav-text">构造测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E5%A4%84%E7%90%86sad-path"><span class="nav-text">何时处理sad path</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TODO%EF%BC%9Amulti-inject-constructors"><span class="nav-text">TODO：multi inject constructors</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95-4"><span class="nav-text">构造测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0-3"><span class="nav-text">快速实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TODO-no-default-constructor-and-inject-constructor"><span class="nav-text">TODO: no default constructor and inject constructor</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95-5"><span class="nav-text">构造测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0-4"><span class="nav-text">快速实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-1"><span class="nav-text">重构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E6%95%B4-bind-%E4%B8%AD%E5%AF%B9%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%A1%E9%AA%8C%E9%80%BB%E8%BE%91"><span class="nav-text">调整 bind 中对默认构造函数的校验逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E6%95%B4-bind-%E4%B8%AD%E5%AF%B9%E5%A4%9A%E4%B8%AA%E8%A2%AB-Inject-%E6%A0%87%E6%B3%A8%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%A1%E9%AA%8C%E9%80%BB%E8%BE%91"><span class="nav-text">调整 bind 中对多个被 Inject 标注的构造函数的校验逻辑</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TODO-dependencies-not-exist"><span class="nav-text">TODO: dependencies not exist</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95-6"><span class="nav-text">构造测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TODO-component-does-not-exist"><span class="nav-text">TODO: component does not exist</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95-7"><span class="nav-text">构造测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E6%B5%8B%E8%AF%95%E5%81%9A%E9%87%8D%E6%9E%84"><span class="nav-text">为测试做重构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TODO%EF%BC%9A-cyclic-dependencies"><span class="nav-text">TODO： cyclic dependencies</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-text">直接循环依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95-8"><span class="nav-text">构造测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-2"><span class="nav-text">重构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-3"><span class="nav-text">重构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="nav-text">实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E6%80%A7%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-text">传递性的循环依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95-9"><span class="nav-text">构造测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-4"><span class="nav-text">重构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E7%90%86%E4%BB%A3%E7%A0%81%E4%BD%8D%E7%BD%AE"><span class="nav-text">整理代码位置</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF"><span class="nav-text">优化异常信息</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DependencyNotFoundException"><span class="nav-text">DependencyNotFoundException</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E4%BE%9D%E8%B5%96%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-text">直接依赖缺失的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E6%80%A7%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-text">传递性中的依赖缺失的情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicDependenciesException"><span class="nav-text">CyclicDependenciesException</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%86%E4%BE%9D%E8%B5%96%E7%9A%84%E6%A3%80%E6%9F%A5%E6%8F%90%E5%89%8D%E5%88%B0%E8%8E%B7%E5%8F%96%E5%AE%9E%E4%BE%8B%E4%B9%8B%E5%89%8D"><span class="nav-text">将依赖的检查提前到获取实例之前</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-%E5%B0%86-Builder-%E5%92%8C-Context-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%86%E5%BC%80"><span class="nav-text">重构-将 Builder 和 Context 上下文分开</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8-get-%E6%96%B9%E6%B3%95"><span class="nav-text">移动 get 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%89%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">目前存在的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA-Provider-%E6%8E%A5%E5%8F%A3"><span class="nav-text">新建 Provider 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%90%E6%AD%A5%E9%87%8D%E6%9E%84"><span class="nav-text">逐步重构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E8%8E%B7%E5%8F%96%E5%AE%B9%E5%99%A8%E6%97%B6%E6%A3%80%E6%9F%A5%E4%BE%9D%E8%B5%96%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-text">在获取容器时检查依赖缺失的情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95-10"><span class="nav-text">构造测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0-5"><span class="nav-text">快速实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E9%87%8D%E6%9E%84-%E7%AE%80%E5%8C%96%E5%91%BD%E5%90%8D"><span class="nav-text">简单重构-简化命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E8%8E%B7%E5%8F%96%E5%AE%B9%E5%99%A8%E6%97%B6%E6%A3%80%E6%9F%A5%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-text">在获取容器时检查循环依赖的情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95-11"><span class="nav-text">构造测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0-6"><span class="nav-text">快速实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E8%8E%B7%E5%8F%96%E5%AE%9E%E4%BE%8B%E6%97%B6%EF%BC%88get%E6%97%B6%EF%BC%89%E5%BE%80%E5%A4%96%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-text">移除获取实例时（get时）往外抛异常的代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-%E5%B0%86-dependencies-%E7%A7%BB%E5%85%A5-providers"><span class="nav-text">重构-将 dependencies 移入 providers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-%E5%87%8F%E5%B0%91ContextConfig%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8F"><span class="nav-text">重构-减少ContextConfig的代码量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Field-Injection"><span class="nav-text">Field Injection</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95"><span class="nav-text">如何构造测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-should-inject-dependency-via-field"><span class="nav-text">实现 should_inject_dependency_via_field</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-provide-dependencies-information-for-field-injection"><span class="nav-text">实现 provide dependencies information for field injection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9-Subclass-%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-text">对 Subclass 的支持</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Method-Injection"><span class="nav-text">Method Injection</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E5%8F%82%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-text">无参方法注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%8F%82%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-text">有参方法注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E4%BE%9D%E8%B5%96%E7%9A%84%E6%A3%80%E6%9F%A5"><span class="nav-text">对依赖的检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%88%B6%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-text">父类和子类的方法注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E6%B3%A8%E5%86%8C%E6%97%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%B3%A8%E5%85%A5%E7%82%B9%E6%96%B9%E6%B3%95"><span class="nav-text">子类注册时，需要调用父类的注入点方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E6%B3%A8%E5%86%8C%E6%97%B6%EF%BC%8C%E5%85%88%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%B3%A8%E5%85%A5%E7%82%B9%E6%96%B9%E6%B3%95"><span class="nav-text">子类注册时，先调用父类的注入点方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Override-%E6%B3%A8%E5%85%A5%E7%82%B9%E6%96%B9%E6%B3%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-text">Override 注入点方法的情况</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E8%A6%86%E7%9B%96%E7%9A%84%E6%96%B9%E6%B3%95%E8%A2%AB-Inject-%E6%A0%87%E6%B3%A8"><span class="nav-text">子类覆盖的方法被 Inject 标注</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E8%A6%86%E7%9B%96%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%AA%E8%A2%AB-Inject-%E6%A0%87%E6%B3%A8"><span class="nav-text">子类覆盖的方法未被 Inject 标注</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Sad-Path"><span class="nav-text">Sad Path</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">注册抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E6%8E%A5%E5%8F%A3"><span class="nav-text">注册接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5%E6%97%B6%EF%BC%8C%E5%AD%97%E6%AE%B5%E4%B8%BA-final-%E6%97%B6"><span class="nav-text">字段注入时，字段为 final 时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-text">方法定义类型参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-text">重构测试代码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-text">删除不必要的测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E9%83%A8%E5%88%86%E6%B5%8B%E8%AF%95%E5%88%B0%E6%96%B0%E7%9A%84%E6%B5%8B%E8%AF%95%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-text">移动部分测试到新的测试上下文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-ConstructorInjection-%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-text">重构 ConstructorInjection 上下文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-ConstructorInjection-%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%AF%B9%E4%BE%9D%E8%B5%96%E6%A0%A1%E9%AA%8C%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-text">在 ConstructorInjection 中增加对依赖校验的测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-InjectionTest-%E5%B9%B6%E7%A7%BB%E5%87%BA-ContainerTest"><span class="nav-text">创建 InjectionTest 并移出 ContainerTest</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-InjectionTest"><span class="nav-text">重构 InjectionTest</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3%E5%8C%96"><span class="nav-text">测试文档化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E5%8C%96-InjectionTest"><span class="nav-text">文档化 InjectionTest</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9F%E4%B8%80%E5%91%BD%E5%90%8D"><span class="nav-text">统一命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%86%E5%8C%96%E5%88%86%E7%BB%84"><span class="nav-text">细化分组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E5%8C%96-ContainerTest"><span class="nav-text">文档化 ContainerTest</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TypeBinding-%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E5%8F%82%E6%95%B0%E5%8C%96"><span class="nav-text">TypeBinding 注入方式参数化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DependencyCheck-%E5%8F%82%E6%95%B0%E5%8C%96"><span class="nav-text">DependencyCheck 参数化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E7%BC%BA%E5%A4%B1"><span class="nav-text">依赖缺失</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96-1"><span class="nav-text">直接循环依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%B4%E6%8E%A5%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-text">间接循环依赖</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8-ContainerTest-%E4%B8%AD%E7%9A%84%E9%83%A8%E5%88%86%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%B1%BB"><span class="nav-text">移动 ContainerTest 中的部分测试用例类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E7%94%9F%E4%BA%A7%E4%BB%A3%E7%A0%81"><span class="nav-text">重构生产代码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-ContextConfig"><span class="nav-text">重构 ContextConfig</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-ConstructorInjectionProvider"><span class="nav-text">重构 ConstructorInjectionProvider</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E6%96%B0%E5%8A%9F%E8%83%BD-%E6%94%AF%E6%8C%81%E6%B3%A8%E5%85%A5Provider"><span class="nav-text">增加新功能-支持注入Provider</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E-Context-%E4%B8%AD%E8%8E%B7%E5%8F%96-Provider"><span class="nav-text">从 Context 中获取 Provider</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%BB%B6%E8%BF%9F%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">1. 延迟实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8E%A7%E5%88%B6%E4%BE%9D%E8%B5%96%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">2. 控制依赖的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%B5%8B%E8%AF%95%E5%8F%8B%E5%A5%BD"><span class="nav-text">3. 测试友好</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE"><span class="nav-text">4. 动态配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%A7%A3%E8%80%A6"><span class="nav-text">5. 解耦</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#support-provider-inject-constructor"><span class="nav-text">support provider inject constructor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#support-provider-inject-method"><span class="nav-text">support provider inject method</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#support-provider-inject-field"><span class="nav-text">support provider inject field</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%81%97%E6%BC%8F%E7%9A%84%E4%BB%BB%E5%8A%A1-Provider-%E4%BE%9D%E8%B5%96%E7%9A%84%E6%A3%80%E6%9F%A5"><span class="nav-text">遗漏的任务-Provider 依赖的检查</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Provider-%E6%A3%80%E6%9F%A5%E4%BE%9D%E8%B5%96%E7%BC%BA%E5%A4%B1"><span class="nav-text">Provider 检查依赖缺失</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Provider-%E6%A3%80%E6%9F%A5%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-text">Provider 检查循环依赖</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-5"><span class="nav-text">重构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E5%AF%B9-Type-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD"><span class="nav-text">重构对 Type 类型的判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85-Type-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD%E9%80%BB%E8%BE%91"><span class="nav-text">封装 Type 类型的判断逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context-%E4%BD%BF%E7%94%A8-Ref-%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B%E8%AE%BF%E9%97%AE"><span class="nav-text">Context 使用 Ref 对外提供访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E6%8E%A5%E5%8F%A3-API-%E5%8F%98%E5%BE%97%E6%9B%B4%E5%8F%8B%E5%A5%BD"><span class="nav-text">如何让接口 API 变得更友好</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Qualifier"><span class="nav-text">Qualifier</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#binding-component-with-qualifier"><span class="nav-text">binding component with qualifier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A-instance"><span class="nav-text">绑定 instance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E7%BB%84%E4%BB%B6"><span class="nav-text">绑定组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binding-component-with-qualifiers"><span class="nav-text">binding component with qualifiers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%AE%9E%E4%BE%8B"><span class="nav-text">绑定实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E7%BB%84%E4%BB%B6-1"><span class="nav-text">绑定组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-ContextConfig-%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">重构 ContextConfig 的内部实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#components-%E6%9B%BF%E6%8D%A2%E6%8E%89-providers"><span class="nav-text">components 替换掉 providers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%9D%8F%E5%91%B3%E9%81%93"><span class="nav-text">其他坏味道</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E6%B5%8B%E8%AF%95"><span class="nav-text">重构测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3%E5%8C%96-1"><span class="nav-text">测试文档化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Qualifier"><span class="nav-text">自定义 Qualifier</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E6%B3%95%E7%9A%84-Qualifier"><span class="nav-text">非法的 Qualifier</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5"><span class="nav-text">依赖检查</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Qualifier-%E6%A0%87%E8%AE%B0%E7%9A%84%E4%BE%9D%E8%B5%96%E4%B8%8D%E5%AD%98%E5%9C%A8"><span class="nav-text">Qualifier 标记的依赖不存在</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DependencyNotFoundException-%E4%BF%A1%E6%81%AF%E4%BC%98%E5%8C%96"><span class="nav-text">DependencyNotFoundException 信息优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-text">循环依赖</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ComponentProvider-%E6%A3%80%E6%9F%A5-Qualifier-%E4%BE%9D%E8%B5%96"><span class="nav-text">ComponentProvider 检查 Qualifier 依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inject-with-qualifier"><span class="nav-text">inject with qualifier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5%E8%A2%AB-Qualifier-%E6%A0%87%E8%AE%B0%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="nav-text">构造器注入被 Qualifier 标记的依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5%E8%A2%AB-Qualifier-%E6%A0%87%E8%AE%B0%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="nav-text">方法注入被 Qualifier 标记的依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5%E8%A2%AB-Qualifier-%E6%A0%87%E8%AE%B0%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="nav-text">字段注入被 Qualifier 标记的依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E6%B3%95%E7%9A%84-Qualifier-%E6%B3%A8%E5%85%A5"><span class="nav-text">非法的 Qualifier 注入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E9%9D%9E%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-text">构造器非法注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%9D%9E%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-text">方法非法注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E9%9D%9E%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-text">字段非法注入</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-6"><span class="nav-text">重构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA-getQualifier"><span class="nav-text">合并两个 getQualifier</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E5%B0%81%E8%A3%85"><span class="nav-text">模型封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E4%BE%9D%E8%B5%96"><span class="nav-text">封装构造器和依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5%E5%99%A8%E5%92%8C%E4%BE%9D%E8%B5%96"><span class="nav-text">封装方法注入器和依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E9%87%8D%E6%9E%84-2"><span class="nav-text">简单重构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5%E5%99%A8%E5%92%8C%E4%BE%9D%E8%B5%96"><span class="nav-text">封装字段注入器和依赖</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E7%90%86%E4%BB%A3%E7%A0%81"><span class="nav-text">整理代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3%E5%8C%96%E9%87%8D%E7%BB%84"><span class="nav-text">测试文档化重组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Provider-%E5%92%8C-Qualifier-%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-text">Provider 和 Qualifier 的测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Qualifier-%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E5%8F%82%E6%95%B0%E5%8C%96"><span class="nav-text">Qualifier 依赖检查参数化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Singleton-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="nav-text">Singleton-生命周期管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E9%9D%9E%E5%8D%95%E4%BE%8B"><span class="nav-text">默认非单例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E7%BB%84%E4%BB%B6%E4%B8%BA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text">绑定组件为单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E6%B5%8B%E8%AF%95"><span class="nav-text">构建测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-4"><span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%AF%E6%8C%81-Singleton"><span class="nav-text">支持 @Singleton</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95-12"><span class="nav-text">构造测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-5"><span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F-bug"><span class="nav-text">小 bug</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5-1"><span class="nav-text">依赖检查</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E4%B8%8D%E5%AD%98%E5%9C%A8"><span class="nav-text">依赖不存在</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96-1"><span class="nav-text">循环依赖</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Scope-%E6%B3%A8%E8%A7%A3"><span class="nav-text">自定义 Scope 注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95-13"><span class="nav-text">构造测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-6"><span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-7"><span class="nav-text">重构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E7%AE%80%E5%8C%96-bind-%E6%96%B9%E6%B3%95"><span class="nav-text">重构简化 bind 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scope-Sad-Path"><span class="nav-text">Scope Sad Path</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87"><span class="nav-text">测试覆盖率</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B5%B0%E7%9A%84%E6%9B%B4%E8%BF%9C"><span class="nav-text">走的更远</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">彭嘉俊</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Jiajun-Peng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Jiajun-Peng" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:pengjiajun566@gmail.com" title="E-Mail → mailto:pengjiajun566@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://ddia2.pigsty.io/#/" title="https:&#x2F;&#x2F;ddia2.pigsty.io&#x2F;#&#x2F;" rel="noopener" target="_blank">DDIA 第二版中文翻译</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://world.hey.com/dhh" title="https:&#x2F;&#x2F;world.hey.com&#x2F;dhh" rel="noopener" target="_blank">DHH</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://pdai.tech/" title="https:&#x2F;&#x2F;pdai.tech&#x2F;" rel="noopener" target="_blank">Java 全栈知识体系</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nobug.world/blogs/25729/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="彭嘉俊">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nobug.world">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="TDD实现Spring（DI容器） | nobug.world">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TDD实现Spring（DI容器）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-21 16:02:49" itemprop="dateCreated datePublished" datetime="2024-08-21T16:02:49+08:00">2024-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-05 11:27:16" itemprop="dateModified" datetime="2024-09-05T11:27:16+08:00">2024-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TDD/" itemprop="url" rel="index"><span itemprop="name">TDD</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/blogs/25729/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/blogs/25729/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>35k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2:06</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="TDD-实现-DI-容器简介"><a href="#TDD-实现-DI-容器简介" class="headerlink" title="TDD 实现 DI 容器简介"></a>TDD 实现 DI 容器简介</h1><p>TDD 的难点首先在于理解需求，并将需求分解为功能点。</p>
<p>以  Jakarta EE 中的 Jakarta Dependency Injection 为主要功能参考，并对其适当简化，以完成我们的目标</p>
<p>实现 DI 时参考 Jakarta Dependency Injection，其中的功能主要分为三部分：</p>
<ul>
<li><p>注入点的支持、组件的构造</p>
</li>
<li><p>依赖的选择</p>
</li>
<li><p>生命周期控制（多例和单例）</p>
</li>
</ul>
<span id="more"></span>

<p>使用@Inject标注的方法或字段，被称为注入点</p>
<blockquote>
<p>常见的注入方式有：构造函数注入、字段注入、方法注入</p>
<blockquote>
<p>在 JSR330 中还包含两个可选的注入方式：静态方法的注入、静态字段的注入</p>
</blockquote>
<p>如果不考虑易于测试的情况下，更倾向于构造函数注入</p>
</blockquote>
<p>容器会找到被注入点，并找到所需的实例，再注入进来，来完成注入。</p>
<p>典型的错误是出现循环依赖的情况，JSR330 中规定了使用 Provider。</p>
<h1 id="使用-Guice-演示-DI-容器如何使用，包含哪些功能"><a href="#使用-Guice-演示-DI-容器如何使用，包含哪些功能" class="headerlink" title="使用 Guice 演示 DI 容器如何使用，包含哪些功能"></a>使用 Guice 演示 DI 容器如何使用，包含哪些功能</h1><blockquote>
<p>做解释的原因：在开发之前都需要澄清需求、理解需求</p>
<p>实际开发中，呈现需求的方式有：user story、PRD（Product Requirement Document，产品需求文档）等方式</p>
<p>在TDD中，也是不能直接上来就写测试的，也是需要先理解需求和上下文</p>
</blockquote>
<p>Jakarta Dependency Injection 中没有规定而又常用的部分有：容器如何配置、容器层级结构以及生命周期回调。</p>
<ul>
<li>如何形成配置文件</li>
<li>容器层级结构便于生命周期管理</li>
<li>生命周期回调</li>
</ul>
<blockquote>
<p>这些功能步包含在 JRS330 中，更多的是在企业级环境中需要，所以不在当前项目的考虑范围中。</p>
</blockquote>
<h1 id="功能分解"><a href="#功能分解" class="headerlink" title="功能分解"></a>功能分解</h1><p>对于组件构造部分，分解的任务大致如下：</p>
<ul>
<li><p>无需构造的组件：即直接将实例注册进容器</p>
</li>
<li><p>如果注册的组件不可实例化，则抛出异常</p>
<ul>
<li>抽象类</li>
<li>接口</li>
</ul>
</li>
<li><p>构造函数注入</p>
<ul>
<li>无依赖的组件应该通过默认构造函数生成组件实例</li>
<li>有依赖的组件，通过 Inject 标注的构造函数生成组件实例</li>
<li>如果所依赖的组件也存在依赖，那么需要对所依赖的组件也完成依赖注入</li>
<li>如果组件有多于一个 Inject 标注的构造函数，则抛出异常</li>
<li>如果组件需要的依赖不存在，则抛出异常</li>
<li>如果组件间存在循环依赖，则抛出异常</li>
</ul>
</li>
<li><p>字段注入</p>
<ul>
<li>通过 Inject 标注将字段声明为依赖组件</li>
<li>如果组件需要的依赖不存在，则抛出异常</li>
<li>如果字段为 final 则抛出异常</li>
<li>如果组件间存在循环依赖，则抛出异常</li>
</ul>
</li>
<li><p>方法注入</p>
<ul>
<li><p>通过 Inject 标注的方法，其参数为依赖组件</p>
</li>
<li><p>通过 Inject 标注的无参数方法，会被调用</p>
</li>
<li><p>按照子类中的规则，覆盖父类中的 Inject 方法</p>
</li>
<li><p>如果组件需要的依赖不存在，则抛出异常</p>
</li>
<li><p>如果方法定义类型参数，则抛出异常</p>
</li>
<li><p>如果组件间存在循环依赖，则抛出异常</p>
</li>
</ul>
</li>
</ul>
<p>对于依赖选择部分，我分解的任务列表如下：</p>
<ul>
<li><p>对 Provider 类型的依赖</p>
<ul>
<li>注入构造函数中可以声明对于 Provider 的依赖</li>
<li>注入字段中可以声明对于 Provider 的依赖</li>
<li>注入方法中可声明对于 Provider 的依赖</li>
</ul>
</li>
<li><p>自定义 Qualifier 的依赖</p>
<ul>
<li><p>注册组件时，可额外指定 Qualifier</p>
</li>
<li><p>注册组件时，可从类对象上提取 Qualifier</p>
</li>
<li><p>寻找依赖时，需同时满足类型与自定义 Qualifier 标注</p>
</li>
<li><p>支持默认 Qualifier——Named</p>
</li>
</ul>
</li>
</ul>
<p>对于生命周期管理部分，我分解的任务列表如下：</p>
<ul>
<li><p>Singleton 生命周期</p>
<ul>
<li>注册组件时，可额外指定是否为 Singleton</li>
<li>注册组件时，可从类对象上提取 Singleton 标注</li>
<li>对于包含 Singleton 标注的组件，在容器范围内提供唯一实例</li>
<li>容器组件默认不是 Single 生命周期</li>
</ul>
</li>
<li><p>自定义 Scope 标注</p>
<ul>
<li>可向容器注册自定义 Scope 标注的回调</li>
</ul>
</li>
</ul>
<h1 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h1><p>新建一个gradle项目，build.gradle.kts配置文件如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    `java-library`</span><br><span class="line">    <span class="string">&quot;jacoco&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;jakarta.inject:jakarta.inject-api:2.0.1&quot;</span>)</span><br><span class="line">    testImplementation(<span class="string">&quot;org.junit.jupiter:junit-jupiter-api:5.8.2&quot;</span>)</span><br><span class="line">    testImplementation(<span class="string">&quot;org.junit.jupiter:junit-jupiter-params:5.8.2&quot;</span>)</span><br><span class="line">    testRuntimeOnly(<span class="string">&quot;org.junit.jupiter:junit-jupiter-engine:5.8.2&quot;</span>)</span><br><span class="line">    testRuntimeOnly(<span class="string">&quot;org.junit.vintage:junit-vintage-engine:5.8.2&quot;</span>)</span><br><span class="line">    testRuntimeOnly(<span class="string">&quot;org.junit.platform:junit-platform-runner:1.8.2&quot;</span>)</span><br><span class="line">    testImplementation(<span class="string">&quot;org.mockito:mockito-core:4.3.1&quot;</span>)</span><br><span class="line">    testImplementation(<span class="string">&quot;jakarta.inject:jakarta.inject-tck:2.0.1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">tasks.withType&lt;Test&gt;() &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br><span class="line">java &#123;</span><br><span class="line">    sourceCompatibility = JavaVersion.VERSION_17</span><br><span class="line">    targetCompatibility = JavaVersion.VERSION_17</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="开始红-绿-重构循环"><a href="#开始红-绿-重构循环" class="headerlink" title="开始红-绿-重构循环"></a>开始红-绿-重构循环</h1><p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContainerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组件构造相关的测试类</span></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentConstruction</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依赖选择相关的测试类</span></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependenciesSelection</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生命周期管理相关的测试类</span></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifecycleManagement</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先将要测试的内容使用@Nested注解隔离成不同的范围，这种结构可以帮助你更好地组织和编写测试。</p>
<blockquote>
<p>在JUnit 5中，<code>@Nested</code>注解用于表示内部类，这些内部类可以作为特定测试的一部分。这种结构可以帮助你更好地组织和编写测试，特别是当你需要对一个类的不同方面或不同状态进行大量测试时。</p>
<p>使用<code>@Nested</code>注解的内部类可以有它们自己的测试方法，<code>@BeforeEach</code>和<code>@AfterEach</code>方法，甚至它们自己的<code>@BeforeAll</code>和<code>@AfterAll</code>方法。这使得你可以在每个内部类级别上设置和清理测试环境，从而为每个测试提供独立的环境。</p>
<p>如上代码中，<code>ComponentConstruction</code>类被标记为<code>@Nested</code>，这意味着它可以包含一组相关的测试，这些测试可以共享相同的初始化和清理代码。</p>
</blockquote>
<p>将ComponentConstruction中的测试再细分为构造器注入、字段注入、方法注入等测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nested</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentConstruction</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> instance</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> abstract class</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> interface</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorInjection</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldInjection</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInjection</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给ConstructorInjection增加一些todo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nested</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorInjection</span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> No args constructor</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> with dependencies</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> A -&gt; B -&gt; C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TODO-instance"><a href="#TODO-instance" class="headerlink" title="TODO: instance"></a>TODO: instance</h1><p>直接向容器中注册实例。</p>
<h3 id="构造测试"><a href="#构造测试" class="headerlink" title="构造测试"></a>构造测试</h3><p>新建测试，并使编译通过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> instance</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_bind_type_to_a_specific_instance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个实现了 Component 接口的匿名内部类实例</span></span><br><span class="line">    <span class="type">Component</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Component</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    context.bind(Component.class, instance);</span><br><span class="line"></span><br><span class="line">    assertSame(instance, context.get(Component.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建了一个匿名内部类（即 <code>new Component() &#123;&#125;</code>），它实现了 <code>Component</code> 接口。由于这是一个匿名内部类，所以它没有名字，但它的行为与任何其他实现了 <code>Component</code> 接口的类是一样的。</p>
</blockquote>
<p>要使编译通过，需要创建Context和其中的bind、get方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;ComponentType&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;ComponentType&gt; type, ComponentType instance)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;ComponentType&gt; ComponentType <span class="title function_">get</span><span class="params">(Class&lt;ComponentType&gt; typeClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译通过，如果运行测试，那么这时会有异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">org.opentest4j.AssertionFailedError: expected: &lt;world.nobug.tdd.di.ContainerTest$ComponentConstruction$1@2dc9b0f5&gt; but was: &lt;null&gt;</span><br><span class="line">	at org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:55)</span><br><span class="line">	at org.junit.jupiter.api.AssertSame.failNotSame(AssertSame.java:48)</span><br><span class="line">	at org.junit.jupiter.api.AssertSame.assertSame(AssertSame.java:37)</span><br><span class="line">	at org.junit.jupiter.api.AssertSame.assertSame(AssertSame.java:32)</span><br><span class="line">	at org.junit.jupiter.api.Assertions.assertSame(Assertions.java:2851)</span><br></pre></td></tr></table></figure>

<h3 id="快速实现"><a href="#快速实现" class="headerlink" title="快速实现"></a>快速实现</h3><p>将bind的信息存入一个map中即可实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; components = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;ComponentType&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;ComponentType&gt; type, ComponentType instance)</span> &#123;</span><br><span class="line">        components.put(type, instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;ComponentType&gt; ComponentType <span class="title function_">get</span><span class="params">(Class&lt;ComponentType&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (ComponentType) components.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来继续实现其他todo，一般我们先从happy path开始，这里先从构造器注入开始</p>
<h1 id="TODO-No-args-constructor"><a href="#TODO-No-args-constructor" class="headerlink" title="TODO: No args constructor"></a>TODO: No args constructor</h1><p>向容器中注册一个类型，该类型有一个默认构造函数。</p>
<p>当需要从容器中获取get这个类型的实例时，容器应该调用这个默认构造函数以创建一个实例。</p>
<h3 id="构造测试-1"><a href="#构造测试-1" class="headerlink" title="构造测试"></a>构造测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> No args constructor</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_bind_type_to_a_class_with_default_constructor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line"></span><br><span class="line">    context.bind(Component.class, ComponentWithDefaultConstructor.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">Component</span> <span class="variable">instance</span> <span class="operator">=</span> context.get(Component.class);</span><br><span class="line"></span><br><span class="line">    assertNotNull(instance);</span><br><span class="line">    assertInstanceOf(ComponentWithDefaultConstructor.class, instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Context新增bind方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;ComponentType, ComponentImplementation <span class="keyword">extends</span> <span class="title class_">ComponentType</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;ComponentType&gt; type, Class&lt;ComponentImplementation&gt; implementation)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速实现-1"><a href="#快速实现-1" class="headerlink" title="快速实现"></a>快速实现</h3><p>因为要支持两种bind方式，所以要快速实现并不容易。</p>
<p>当然如果在不计任何罪恶的情况下，也可以再新建一个Map保存这种bind形式的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; components = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; componentImplementations = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;ComponentType&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;ComponentType&gt; type, ComponentType instance)</span> &#123;</span><br><span class="line">        components.put(type, instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;ComponentType&gt; ComponentType <span class="title function_">get</span><span class="params">(Class&lt;ComponentType&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (components.containsKey(type))</span><br><span class="line">            <span class="keyword">return</span> (ComponentType) components.get(type);</span><br><span class="line">        Class&lt;?&gt; implementation = componentImplementations.get(type);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取到默认构造函数，并创建实例</span></span><br><span class="line">            <span class="keyword">return</span> (ComponentType)implementation.getConstructor().newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;ComponentType, ComponentImplementation <span class="keyword">extends</span> <span class="title class_">ComponentType</span>&gt;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;ComponentType&gt; type, Class&lt;ComponentImplementation&gt; implementation)</span> &#123;</span><br><span class="line">        componentImplementations.put(type, implementation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>两个map并不是一个合理的实现方式，并且还有if else，这些都是坏味道。需要重构，并且前面的测试已经证明了功能的可用性。有了测试的保证就可以进行安全的重构。</p>
<p>如何重构：将这两个map中的value值类型合并为使用同一个interface，或者说使用同一种形式的API。</p>
<p>在JSR330中已经提供了一个Provider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Provider</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实这就是一个Factory</p>
</blockquote>
<p>在注册时，将这两个注册的方法，分别的变成Provider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Provider&lt;?&gt;&gt; providers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java8提供了与Provider接口类似的Supplier函数式接口，这里只是选用了JSR330的接口，功能是一样的</p>
</blockquote>
<p>接下来就是进行逐步替换掉这两个Map</p>
<h4 id="替换components"><a href="#替换components" class="headerlink" title="替换components"></a>替换components</h4><p>先替换第一个bind方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;ComponentType&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;ComponentType&gt; type, ComponentType instance)</span> &#123;</span><br><span class="line">    components.put(type, instance);</span><br><span class="line">    providers.put(type, () -&gt; instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的修改get方法，将用到components的地方替换为使用providers</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;ComponentType&gt; ComponentType <span class="title function_">get</span><span class="params">(Class&lt;ComponentType&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (providers.containsKey(type))</span><br><span class="line">        <span class="keyword">return</span> (ComponentType) providers.get(type).get();</span><br><span class="line">    Class&lt;?&gt; implementation = componentImplementations.get(type);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (ComponentType)implementation.getConstructor().newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改代码后，运行测试</p>
<p>紧接着移除，bind方法中的components语句，就会发现components的map就不需要使用了，可以将这个map移除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; componentImplementations = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Provider&lt;?&gt;&gt; providers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;ComponentType&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;ComponentType&gt; type, ComponentType instance)</span> &#123;</span><br><span class="line">    providers.put(type, () -&gt; instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="替换componentImplementations"><a href="#替换componentImplementations" class="headerlink" title="替换componentImplementations"></a>替换componentImplementations</h4><p>同理，针对componentImplementations这个map做替换，替换完成后Context的现实如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Provider&lt;?&gt;&gt; providers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;ComponentType&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;ComponentType&gt; type, ComponentType instance)</span> &#123;</span><br><span class="line">        providers.put(type, () -&gt; instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;ComponentType, ComponentImplementation <span class="keyword">extends</span> <span class="title class_">ComponentType</span>&gt;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;ComponentType&gt; type, Class&lt;ComponentImplementation&gt; implementation)</span> &#123;</span><br><span class="line">        providers.put(type, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> implementation.getConstructor().newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;ComponentType&gt; ComponentType <span class="title function_">get</span><span class="params">(Class&lt;ComponentType&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (ComponentType) providers.get(type).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，就已经实现了一个基本的DI容器的结构，之后就是要围绕 DI 容器的基本结构，对其进行更多功能上的完善。</p>
<h3 id="重构总结"><a href="#重构总结" class="headerlink" title="重构总结"></a>重构总结</h3><p>在重构的时候，我采用的是增加一个平行实现（Parallel Implementation）。用平行实现替换原有功能，然后再删除原有实现的做法。</p>
<h1 id="简单重构"><a href="#简单重构" class="headerlink" title="简单重构"></a>简单重构</h1><p>在继续后面的功能之前，先梳理一下测试，进行一些简单的重构。</p>
<p>目前每一个测试中都需要构造一个新的Context，可以预见到后续的每一个测试也都需要构造Context。</p>
<p>重构测试，将构造新的Context的动作放到setup中，并移除掉后续方法中创建Context的语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Context context;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">    context = <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重构测试，将Component接口，及其相关子类移动到ContainerTest的外部，方便阅读。</p>
<p><img src="/blogs/25729/Snipaste_2024-08-08_16-20-52.png" alt="Snipaste_2024-08-08_16-20-52"></p>
<h1 id="TODO-with-dependencies"><a href="#TODO-with-dependencies" class="headerlink" title="TODO: with dependencies"></a>TODO: with dependencies</h1><p>构造被<code>@Inject</code>标注的构造函数的测试，并通过编译</p>
<h2 id="构造测试-2"><a href="#构造测试-2" class="headerlink" title="构造测试"></a>构造测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> with dependencies</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_bind_type_to_a_class_with_inject_constructor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Dependency</span> <span class="variable">dependency</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dependency</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    context.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line">    context.bind(Dependency.class, dependency);</span><br><span class="line"></span><br><span class="line">    <span class="type">Component</span> <span class="variable">instance</span> <span class="operator">=</span> context.get(Component.class);</span><br><span class="line">    assertNotNull(instance);</span><br><span class="line">    assertSame(dependency, ((ComponentWithInjectConstructor) instance).getDependency());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dependency</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComponentWithInjectConstructor</span> <span class="keyword">implements</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Dependency dependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ComponentWithInjectConstructor</span><span class="params">(Dependency dependency)</span>&#123;</span><br><span class="line">        <span class="comment">// 注意，一定要记得赋值</span></span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于测试验证dependency是否被注入</span></span><br><span class="line">    <span class="keyword">public</span> Dependency <span class="title function_">getDependency</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单重构-1"><a href="#简单重构-1" class="headerlink" title="简单重构"></a>简单重构</h2><p>简单重构，重命名范型名称，简短一点</p>
<p>ComponetType -&gt; Type</p>
<p>-&gt; Implementation</p>
<h2 id="快速实现-2"><a href="#快速实现-2" class="headerlink" title="快速实现"></a>快速实现</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>修改newInstance时的代码，创建时应该传入依赖的实例，但目前还是使用默认构造函数，所以还是依然会出错，但这只是第一步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type, Implementation <span class="keyword">extends</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation)</span> &#123;</span><br><span class="line">    providers.put(type, () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;Implementation&gt; injectConstructor = implementation.getConstructor();</span><br><span class="line">            <span class="comment">// 根据构造函数的参数，获取依赖的实例</span></span><br><span class="line">            Object[] dependencies = Arrays.stream(injectConstructor.getParameters())</span><br><span class="line">                    .map(p -&gt; get(p.getType()))</span><br><span class="line">                    .toArray(Object[]::<span class="keyword">new</span>);</span><br><span class="line">            <span class="keyword">return</span> injectConstructor.newInstance(dependencies);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>提取获取构造器的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type, Implementation <span class="keyword">extends</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation)</span> &#123;</span><br><span class="line">    providers.put(type, () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;Implementation&gt; injectConstructor = getInjectConstructor(implementation);</span><br><span class="line">            <span class="comment">// 根据构造函数的参数，获取依赖的实例</span></span><br><span class="line">            Object[] dependencies = Arrays.stream(injectConstructor.getParameters())</span><br><span class="line">                    .map(p -&gt; get(p.getType()))</span><br><span class="line">                    .toArray(Object[]::<span class="keyword">new</span>);</span><br><span class="line">            <span class="keyword">return</span> injectConstructor.newInstance(dependencies);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取带<code>@Inject</code>的构造器或默认构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;Type&gt; Constructor&lt;Type&gt; <span class="title function_">getInjectConstructor</span><span class="params">(</span></span><br><span class="line"><span class="params">        Class&lt;Type&gt; implementation)</span> &#123;</span><br><span class="line">    Stream&lt;Constructor&lt;?&gt;&gt; injectConstructors = Arrays.stream(implementation.getConstructors())</span><br><span class="line">            .filter(c -&gt; c.isAnnotationPresent(Inject.class));</span><br><span class="line">    <span class="keyword">return</span> (Constructor&lt;Type&gt;) injectConstructors.findFirst().orElseGet(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> implementation.getConstructor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TODO-A-B-C"><a href="#TODO-A-B-C" class="headerlink" title="TODO: A -&gt; B -&gt; C"></a>TODO: A -&gt; B -&gt; C</h1><p>有传递性的依赖</p>
<h2 id="构造测试-3"><a href="#构造测试-3" class="headerlink" title="构造测试"></a>构造测试</h2><p>构造并运行测试，会发现测试直接通过，说明当前的生产代码已经满足了我们的功能需求，不需要修改生产代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> A -&gt; B -&gt; C</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_bind_type_to_a_class_with_inject_transitive_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    context.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line">    context.bind(Dependency.class, DependencyWithInjectConstructor.class);</span><br><span class="line">    context.bind(String.class, <span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Component</span> <span class="variable">instance</span> <span class="operator">=</span> context.get(Component.class);</span><br><span class="line">    assertNotNull(instance);</span><br><span class="line"></span><br><span class="line">    <span class="type">Dependency</span> <span class="variable">dependency</span> <span class="operator">=</span> context.get(Dependency.class);</span><br><span class="line">    assertNotNull(dependency);</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">&quot;Hello World!&quot;</span>, ((DependencyWithInjectConstructor) dependency).getDependency());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DependencyWithInjectConstructor</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span>&#123;</span><br><span class="line">    <span class="comment">// 直接使用字符串类型，不新建接口，简化开发</span></span><br><span class="line">    <span class="keyword">private</span> String dependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DependencyWithInjectConstructor</span><span class="params">(String dependency)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDependency</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="何时处理sad-path"><a href="#何时处理sad-path" class="headerlink" title="何时处理sad path"></a>何时处理sad path</h1><p>到目前为止，部分happy path已经完成，还剩下一些sad path，这样我们就有了一个选择，就是继续做happy path（去做FieldInjection、MethodInjection）还是做sad path</p>
<p>两种选择都可以，但是有些不一样的地方。</p>
<p>应该在经过一定时间的happy path的任务编写后，应该转到sad path，前面的happy path是为了尽快确定我们的代码结构，同时sad path也会需要我们调整代码结构，所以应该及时在开发了一段时间的happy path需求后引入一些sad path来促进代码结构的变化。</p>
<h1 id="TODO：multi-inject-constructors"><a href="#TODO：multi-inject-constructors" class="headerlink" title="TODO：multi inject constructors"></a>TODO：multi inject constructors</h1><p>有多个构造函数被<code>@Inject</code>注解标记的情况，JSR330中规定只能有一个构造函数被<code>@Inject</code>标注</p>
<h2 id="构造测试-4"><a href="#构造测试-4" class="headerlink" title="构造测试"></a>构造测试</h2><p>创建包含两个被<code>@Inject</code>注解标记的构造方法的类作为测试数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ComponentWithMultiInjectConstructors</span> <span class="keyword">implements</span> <span class="title class_">Component</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ComponentWithMultiInjectConstructors</span><span class="params">(String name, Double value)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ComponentWithMultiInjectConstructors</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO：multi inject constructors</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_multi_inject_constructors_provided</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalComponentException.class, () -&gt; &#123;</span><br><span class="line">        context.bind(Component.class, ComponentWithMultiInjectConstructors.class);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是在bind的时候校验是否异常，也可以在get的时候校验异常:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assertThrows(IllegalComponentException.class, () -&gt; &#123;</span><br><span class="line">    context.get(Component.class);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>但是这里选择在bind是校验的原因是，可以及时短路，也会使后续的代码更加简单。</strong></p>
<p>创建IllegalComponentException异常类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IllegalComponentException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速实现-3"><a href="#快速实现-3" class="headerlink" title="快速实现"></a>快速实现</h2><p>在bind方法中增加校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] injectConstructors =</span><br><span class="line">                Arrays.stream(implementation.getConstructors()).filter(c -&gt; c.isAnnotationPresent(Inject.class))</span><br><span class="line">                        .toArray(Constructor&lt;?&gt;[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">if</span> (injectConstructors.length &gt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br></pre></td></tr></table></figure>

<h1 id="TODO-no-default-constructor-and-inject-constructor"><a href="#TODO-no-default-constructor-and-inject-constructor" class="headerlink" title="TODO: no default constructor and inject constructor"></a>TODO: no default constructor and inject constructor</h1><p>没有默认构造函数且没有被<code>@Inject</code>注解标注的构造函数的情况</p>
<h2 id="构造测试-5"><a href="#构造测试-5" class="headerlink" title="构造测试"></a>构造测试</h2><p>构造没有默认构造函数和被<code>@Inject</code>注解标注的构造函数的测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ComponentWithNoInjectConstructorNorDefaultConstructor</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ComponentWithNoInjectConstructorNorDefaultConstructor</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> no default constructor and inject constructor</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_no_inject_constructor_nor_default_constructor_provided</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalComponentException.class, () -&gt; &#123;</span><br><span class="line">        context.bind(Component.class, ComponentWithNoInjectConstructorNorDefaultConstructor.class);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速实现-4"><a href="#快速实现-4" class="headerlink" title="快速实现"></a>快速实现</h2><p>在bind方法中增加校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (injectConstructors.length &lt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">                Arrays.stream(implementation.getConstructors()).noneMatch(c -&gt; c.getParameterCount() == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br></pre></td></tr></table></figure>

<h1 id="重构-1"><a href="#重构-1" class="headerlink" title="重构"></a>重构</h1><h2 id="调整-bind-中对默认构造函数的校验逻辑"><a href="#调整-bind-中对默认构造函数的校验逻辑" class="headerlink" title="调整 bind 中对默认构造函数的校验逻辑"></a>调整 bind 中对默认构造函数的校验逻辑</h2><p>通过观察发现在 bind 中找校验构造函数是否合规的方法，和后面的 getInjectConstructor 的方法的逻辑是有部分重叠的，都需要获取到构造函数的列表。</p>
<p>在 getInjectConstructor 中会校验默认构造函数的情况，只需要在 getInjectConstructor 方法中抛出 IllegalComponentException 异常，并将 providers.put 方法中的 getInjectConstructor 方法提前到 put 方法之前，就可以移除掉 bind 方法中对默认构造函数的校验。</p>
<blockquote>
<p>将 providers.put 方法中的 getInjectConstructor 方法提前到 put 方法之前，是因为 put 时只是创建一个匿名内部类，并不会执行 getInjectConstructor 方法，getInjectConstructor 方法是在 get 时调用。</p>
</blockquote>
<p><img src="/blogs/25729/Snipaste_2024-08-09_15-41-19.png"></p>
<p><img src="/blogs/25729/Snipaste_2024-08-09_15-41-51.png"></p>
<h2 id="调整-bind-中对多个被-Inject-标注的构造函数的校验逻辑"><a href="#调整-bind-中对多个被-Inject-标注的构造函数的校验逻辑" class="headerlink" title="调整 bind 中对多个被 Inject 标注的构造函数的校验逻辑"></a>调整 bind 中对多个被 Inject 标注的构造函数的校验逻辑</h2><p>同理，也可将校验是否有多个被 Inject 标注的构造函数的逻辑放到 getInjectConstructor 方法中</p>
<p>这样就可以将 bind 中的校验代码移除，改写后的 getInjectConstructor 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;Type&gt; Constructor&lt;Type&gt; <span class="title function_">getInjectConstructor</span><span class="params">(</span></span><br><span class="line"><span class="params">        Class&lt;Type&gt; implementation)</span> &#123;</span><br><span class="line">    List&lt;Constructor&lt;?&gt;&gt; injectConstructors = Arrays.stream(implementation.getConstructors())</span><br><span class="line">            .filter(c -&gt; c.isAnnotationPresent(Inject.class)).toList();</span><br><span class="line">    <span class="keyword">if</span> (injectConstructors.size() &gt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (Constructor&lt;Type&gt;) injectConstructors.stream().findFirst().orElseGet(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> implementation.getConstructor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TODO-dependencies-not-exist"><a href="#TODO-dependencies-not-exist" class="headerlink" title="TODO: dependencies not exist"></a>TODO: dependencies not exist</h1><p>组件中的依赖不存在的情况</p>
<h2 id="构造测试-6"><a href="#构造测试-6" class="headerlink" title="构造测试"></a>构造测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> dependencies not exist</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_dependency_not_found</span><span class="params">()</span> &#123;</span><br><span class="line">    context.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line"></span><br><span class="line">    assertThrows(DependencyNotFoundException.class, () -&gt; &#123;context.get(Component.class);&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复用了 ComponentWithInjectConstructor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ComponentWithInjectConstructor</span> <span class="keyword">implements</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Dependency dependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ComponentWithInjectConstructor</span><span class="params">(Dependency dependency)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于测试验证dependency是否被注入</span></span><br><span class="line">    <span class="keyword">public</span> Dependency <span class="title function_">getDependency</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 DependencyNotFoundException 异常类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，会抛异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.NullPointerException: Cannot invoke <span class="string">&quot;jakarta.inject.Provider.get()&quot;</span> because the <span class="keyword">return</span> value of <span class="string">&quot;java.util.Map.get(Object)&quot;</span> is <span class="literal">null</span></span><br><span class="line">	at world.nobug.tdd.di.Context.get(Context.java:<span class="number">52</span>)</span><br><span class="line">	at world.nobug.tdd.di.Context.lambda$bind$<span class="number">1</span>(Context.java:<span class="number">27</span>)</span><br><span class="line">	at java.base/java.util.stream.ReferencePipeline$<span class="number">3</span>$<span class="number">1.</span>accept(ReferencePipeline.java:<span class="number">197</span>)</span><br><span class="line">	at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:<span class="number">992</span>)</span><br><span class="line">	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:<span class="number">509</span>)</span><br><span class="line">	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:<span class="number">499</span>)</span><br><span class="line">	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="number">575</span>)</span><br><span class="line">	at java.base/java.util.stream.AbstractPipeline.evaluateToArrayNode(AbstractPipeline.java:<span class="number">260</span>)</span><br><span class="line">	at java.base/java.util.stream.ReferencePipeline.toArray(ReferencePipeline.java:<span class="number">616</span>)</span><br><span class="line">	at world.nobug.tdd.di.Context.lambda$bind$<span class="number">3</span>(Context.java:<span class="number">28</span>)</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>根据以上的异常，定位到的问题是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type&gt; Type <span class="title function_">get</span><span class="params">(Class&lt;Type&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Type) providers.get(type).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注入依赖时，需要先 get 到对应依赖的实例，但是当前没有实例，这里会抛 NullPointerException 异常。</p>
<p>快速的实现方式是在 get 时校验实例是否存在：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type&gt; Type <span class="title function_">get</span><span class="params">(Class&lt;Type&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!providers.containsKey(type)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DependencyNotFoundException</span>();</span><br><span class="line">    <span class="keyword">return</span> (Type) providers.get(type).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在 bind 方法中，需要修改软化异常的代码，仅将跟反射调用相关的异常软化为 RuntimeException</p>
<p><img src="/blogs/25729/image-20240809161723867.png" alt="image-20240809161723867"></p>
<h1 id="TODO-component-does-not-exist"><a href="#TODO-component-does-not-exist" class="headerlink" title="TODO: component does not exist"></a>TODO: component does not exist</h1><p>基于前面的测试，我们还可以想到有直接获取组件的情况。</p>
<p>上一个测试用例是通过依赖关系去组件不存在的情况，这个测试用例是直接取组件但是不存在的情况。</p>
<h2 id="构造测试-7"><a href="#构造测试-7" class="headerlink" title="构造测试"></a>构造测试</h2><p>在这个场景下，get 方法会返回 DependencyNotFoundException 异常，因为这个 get 方法也是一个直接对外的 API，直接抛 DependencyNotFoundException 很多时候都不太合理，而且这个异常的名称也不太合理。</p>
<p>按目前的编程风格，我们更倾向于这种情况返回一个 null，返回一个 Optional</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> component does not exist</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_</span><span class="params">()</span> &#123;</span><br><span class="line">    Optional&lt;Component&gt; component = context.get_(Component.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码调用的是 <code>get_</code>，因为 get 方法在即对外开放也被内部多个地方调用，并且返回值也发生了变化，所以考虑定义一个新的方法。</p>
<p>这么做的化其实也是为了适应测试的需要在做重构。</p>
<h2 id="为测试做重构"><a href="#为测试做重构" class="headerlink" title="为测试做重构"></a>为测试做重构</h2><p>第一步，新建 get_ 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type&gt; Type <span class="title function_">get</span><span class="params">(Class&lt;Type&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!providers.containsKey(type)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DependencyNotFoundException</span>();</span><br><span class="line">    <span class="keyword">return</span> (Type) providers.get(type).get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 签名原来的 get 方法保持一致就可以了</span></span><br><span class="line"><span class="keyword">public</span> &lt;Type&gt; Optional&lt;Type&gt; <span class="title function_">get_</span><span class="params">(Class&lt;Type&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，基于这个 get_ 方法，重构测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> component does not exist</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_return_empty_if_component_not_defined</span><span class="params">()</span> &#123;</span><br><span class="line">    Optional&lt;Component&gt; component = context.get_(Component.class);</span><br><span class="line">    assertTrue(component.isEmpty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>第一步，修改 get_ 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type&gt; Optional&lt;Type&gt; <span class="title function_">get_</span><span class="params">(Class&lt;Type&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(providers.get(type)).map(provider -&gt; (Type)provider.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，所有测试通过。</p>
<p>第二步，修改 get 方法，将 get 方法的实现委托给 get_ 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type&gt; Type <span class="title function_">get</span><span class="params">(Class&lt;Type&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get_(type).orElseThrow(DependencyNotFoundException::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，inline get 方法，即可以将 get 方法移除掉</p>
<p>第四步，将 get_ 方法重命名为 get</p>
<p>第五步，移除部分 get 方法后的 <code>.orElseThrow()</code> ，修改为 <code>.get()</code></p>
<h1 id="TODO：-cyclic-dependencies"><a href="#TODO：-cyclic-dependencies" class="headerlink" title="TODO： cyclic dependencies"></a>TODO： cyclic dependencies</h1><p>循环依赖的场景</p>
<p>希望在出现循环依赖时抛出指示循环依赖的异常</p>
<h2 id="直接循环依赖"><a href="#直接循环依赖" class="headerlink" title="直接循环依赖"></a>直接循环依赖</h2><p>A -&gt; B -&gt; A</p>
<h3 id="构造测试-8"><a href="#构造测试-8" class="headerlink" title="构造测试"></a>构造测试</h3><p>这个 DependencyDependedOnComponent 依赖于 Component</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DependencyDependedOnComponent</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DependencyDependedOnComponent</span><span class="params">(Component component)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO： cyclic dependencies</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_cyclic_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    context.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line">    context.bind(Dependency.class, DependencyDependedOnComponent.class);</span><br><span class="line"></span><br><span class="line">    assertThrows(CyclicDependenciesException.class, () -&gt; context.get(Component.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，抛出如下 StackOverflowError 异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.StackOverflowError</span><br><span class="line">	at java.base/java.lang.reflect.Executable.getParameters(Executable.java:<span class="number">370</span>)</span><br><span class="line">	at world.nobug.tdd.di.Context.lambda$bind$<span class="number">3</span>(Context.java:<span class="number">28</span>)</span><br><span class="line">	at world.nobug.tdd.di.Context.lambda$get$<span class="number">6</span>(Context.java:<span class="number">54</span>)</span><br><span class="line">	at java.base/java.util.Optional.map(Optional.java:<span class="number">260</span>)</span><br><span class="line">	at world.nobug.tdd.di.Context.get(Context.java:<span class="number">54</span>)</span><br><span class="line">	at world.nobug.tdd.di.Context.lambda$bind$<span class="number">1</span>(Context.java:<span class="number">29</span>)</span><br><span class="line">	at java.base/java.util.stream.ReferencePipeline$<span class="number">3</span>$<span class="number">1.</span>accept(ReferencePipeline.java:<span class="number">197</span>)</span><br><span class="line">	at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:<span class="number">992</span>)</span><br><span class="line">	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:<span class="number">509</span>)</span><br><span class="line">	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:<span class="number">499</span>)</span><br><span class="line">	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="number">575</span>)</span><br></pre></td></tr></table></figure>

<p>出现这个异常的原因是，get 时会去递归调用 get 方法用于获取依赖的组件的实例。</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>目前创建组件实例方式，是通过在 bind 时 put 一个类型对应的 Provider 工厂，并在 get 时使用这个工厂来创建实例。</p>
<p>在目前的情况下，我们是无法知道哪个哪个实例正在创建中的，所以就会一直递归执行 get 方法。</p>
<p>我们预期的实现方式是为需要构造的组件增加一个正在构造的标记，那么当第二次尝试构造这个组件时发现这个组件正在构造，那么就产生了循环依赖。</p>
<p>在我们的实现中是使用匿名的 Provider 来 new 对象。那么如果我们能识别出访问过两次同一个 Provider，那么就产生了循环依赖。</p>
<p>这里需要做的就是将匿名的 Provider，变成具体的类，并在这个类上保持一个是否正在创建的标志。</p>
<h4 id="重构-2"><a href="#重构-2" class="headerlink" title="重构"></a>重构</h4><p>将 bind 方法中的匿名内部类创建方法提取为函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type, Implementation <span class="keyword">extends</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation)</span> &#123;</span><br><span class="line">    Constructor&lt;Implementation&gt; injectConstructor = getInjectConstructor(implementation);</span><br><span class="line"></span><br><span class="line">    providers.put(type, getTypeProvider(injectConstructor));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;Type&gt; Provider&lt;Object&gt; <span class="title function_">getTypeProvider</span><span class="params">(Constructor&lt;Type&gt; injectConstructor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; getImplementation(injectConstructor); <span class="comment">// 预期将变成，new xxxx(injectConstructor)的形式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;Type&gt; Type <span class="title function_">getImplementation</span><span class="params">(Constructor&lt;Type&gt; injectConstructor)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据构造函数的参数，获取依赖的实例</span></span><br><span class="line">        Object[] dependencies = Arrays.stream(injectConstructor.getParameters())</span><br><span class="line">                .map(p -&gt; get(p.getType()).orElseThrow(DependencyNotFoundException::<span class="keyword">new</span>))</span><br><span class="line">                .toArray(Object[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">return</span> injectConstructor.newInstance(dependencies);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重构-3"><a href="#重构-3" class="headerlink" title="重构"></a>重构</h4><p>新建 Provider 的实现类：ConstructorInjectionProvider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Provider</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Constructor&lt;T&gt; injectConstructor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstructorInjectionProvider</span><span class="params">(Constructor&lt;T&gt; injectConstructor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.injectConstructor = injectConstructor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getImplementation(injectConstructor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改获取 Provider 的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Type&gt; Provider&lt;Object&gt; <span class="title function_">getTypeProvider</span><span class="params">(Constructor&lt;Type&gt; injectConstructor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>(injectConstructor); <span class="comment">// 变成，new xxxx(injectConstructor)的形式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，依然之后循环依赖的代码失败。</p>
<p>inline 提取的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type, Implementation <span class="keyword">extends</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation)</span> &#123;</span><br><span class="line">    Constructor&lt;Implementation&gt; injectConstructor = getInjectConstructor(implementation);</span><br><span class="line"></span><br><span class="line">    providers.put(type, <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>(injectConstructor));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Provider</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Constructor&lt;T&gt; injectConstructor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstructorInjectionProvider</span><span class="params">(Constructor&lt;T&gt; injectConstructor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.injectConstructor = injectConstructor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据构造函数的参数，获取依赖的实例</span></span><br><span class="line">            Object[] dependencies = Arrays.stream(injectConstructor.getParameters())</span><br><span class="line">                    .map(p -&gt; Context.<span class="built_in">this</span>.get(p.getType()).orElseThrow(DependencyNotFoundException::<span class="keyword">new</span>))</span><br><span class="line">                    .toArray(Object[]::<span class="keyword">new</span>);</span><br><span class="line">            <span class="keyword">return</span> injectConstructor.newInstance(dependencies);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>在 Provider 的实现类 ConstructorInjectionProvider 中增加 constructing标志位，以指示是否在构建中，并实现循环依赖的检测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Provider</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Constructor&lt;T&gt; injectConstructor;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">constructing</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstructorInjectionProvider</span><span class="params">(Constructor&lt;T&gt; injectConstructor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.injectConstructor = injectConstructor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果在构建中就抛异常</span></span><br><span class="line">        <span class="keyword">if</span> (constructing) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CyclicDependenciesException</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            constructing = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 根据构造函数的参数，获取依赖的实例</span></span><br><span class="line">            Object[] dependencies = Arrays.stream(injectConstructor.getParameters())</span><br><span class="line">                    .map(p -&gt; Context.<span class="built_in">this</span>.get(p.getType()).orElseThrow(DependencyNotFoundException::<span class="keyword">new</span>))</span><br><span class="line">                    .toArray(Object[]::<span class="keyword">new</span>);</span><br><span class="line">            <span class="keyword">return</span> injectConstructor.newInstance(dependencies);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            constructing = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传递性的循环依赖"><a href="#传递性的循环依赖" class="headerlink" title="传递性的循环依赖"></a>传递性的循环依赖</h2><p>A -&gt; B -&gt; C -&gt; A</p>
<h3 id="构造测试-9"><a href="#构造测试-9" class="headerlink" title="构造测试"></a>构造测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> <span class="comment">// A -&gt; B -&gt; C -&gt; A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_transitive_cyclic_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    context.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line">    context.bind(Dependency.class, DependencyDependedOnAnotherDependency.class);</span><br><span class="line">    context.bind(AnotherDependency.class, AnotherDependencyDependedOnComponent.class);</span><br><span class="line"></span><br><span class="line">    assertThrows(CyclicDependenciesException.class, () -&gt; context.get(Component.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增两个测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherDependencyDependedOnComponent</span> <span class="keyword">implements</span> <span class="title class_">AnotherDependency</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnotherDependencyDependedOnComponent</span><span class="params">(Component component)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DependencyDependedOnAnotherDependency</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AnotherDependency anotherDependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DependencyDependedOnAnotherDependency</span><span class="params">(AnotherDependency anotherDependency)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.anotherDependency = anotherDependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，所有测试依然可以通过。</p>
<h1 id="重构-4"><a href="#重构-4" class="headerlink" title="重构"></a>重构</h1><h2 id="整理代码位置"><a href="#整理代码位置" class="headerlink" title="整理代码位置"></a>整理代码位置</h2><p>移动代码的位置，使容器的接口都集中到一起。</p>
<p><img src="/blogs/25729/image-20240809184214486.png" alt="image-20240809184214486"></p>
<h1 id="优化异常信息"><a href="#优化异常信息" class="headerlink" title="优化异常信息"></a>优化异常信息</h1><p>从API的角度来看，目前的异常处理部分返回的信息并不清晰，作为一个使用者，希望能从异常中获取到更多的有效信息。</p>
<h2 id="DependencyNotFoundException"><a href="#DependencyNotFoundException" class="headerlink" title="DependencyNotFoundException"></a>DependencyNotFoundException</h2><p>对于依赖不存在的情况，使用者希望明确知道是哪个依赖不存在。</p>
<h3 id="直接依赖缺失的情况"><a href="#直接依赖缺失的情况" class="headerlink" title="直接依赖缺失的情况"></a>直接依赖缺失的情况</h3><p>修改测试用例，在异常中增加缺失的依赖的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dependencies not exist</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_dependency_not_found</span><span class="params">()</span> &#123;</span><br><span class="line">    context.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyNotFoundException</span> <span class="variable">exception</span> <span class="operator">=</span> assertThrows(DependencyNotFoundException.class, () -&gt; &#123;</span><br><span class="line">        context.get(Component.class).get();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    assertEquals(Dependency.class, exception.getDependency());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 DependencyNotFoundException 以适应需求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; dependency;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DependencyNotFoundException</span><span class="params">(Class&lt;?&gt; dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getDependency() &#123;</span><br><span class="line">        <span class="keyword">return</span> dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改异常的定义后，需要修改抛出异常时的创建代码:</p>
<p><img src="/blogs/25729/image-20240809185759277.png" alt="image-20240809185759277"></p>
<p>编译通过后，运行测试，所有测试都通过。</p>
<h3 id="传递性中的依赖缺失的情况"><a href="#传递性中的依赖缺失的情况" class="headerlink" title="传递性中的依赖缺失的情况"></a>传递性中的依赖缺失的情况</h3><p>新增一个测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_transitive_dependency_not_found</span><span class="params">()</span> &#123;</span><br><span class="line">    context.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line">    context.bind(Dependency.class, DependencyWithInjectConstructor.class); <span class="comment">// 缺失 String 类型的依赖</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyNotFoundException</span> <span class="variable">exception</span> <span class="operator">=</span> assertThrows(DependencyNotFoundException.class, () -&gt; &#123;</span><br><span class="line">        context.get(Component.class);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    assertEquals(String.class, exception.getDependency());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，DependencyNotFoundException 异常中，只能返回缺失的依赖是哪个，但是并不知道是哪个组件缺失依赖。</p>
<p>所以，使用者还希望在 DependencyNotFoundException 中获取到缺失依赖的组件的信息。</p>
<p>修改测试代码，异常中增加缺失依赖的组件的信息：</p>
<p><img src="/blogs/25729/image-20240809191402158.png" alt="image-20240809191402158"></p>
<p>修改 DependencyNotFoundException，增加 component 属性信息和构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; dependency;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; component;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DependencyNotFoundException</span><span class="params">(Class&lt;?&gt; dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DependencyNotFoundException</span><span class="params">(Class&lt;?&gt; component, Class&lt;?&gt; dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getDependency() &#123;</span><br><span class="line">        <span class="keyword">return</span> dependency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getComponent() &#123;</span><br><span class="line">        <span class="keyword">return</span> component;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 Find Usages 找到，单个参数的构造函数在哪里被使用，这里是只被一处地方使用，我们现在需要将使用的地方修改为使用两个参数的构造函数</p>
<blockquote>
<p>如果有多个地方使用了这个构造函数的话，建议通过工厂方法的方式替换掉这个构造函数</p>
</blockquote>
<p>在抛出异常时返回缺失依赖的组件信息，由于创建 ConstructorInjectionProvider 时并没有传入组件的信息</p>
<p>所以需要修改 ConstructorInjectionProvider 记录组件的信息，在其中增加 componentType 字段信息，并相应的修改必要代码</p>
<p><img src="/blogs/25729/image-20240809194930682.png" alt="image-20240809194930682"></p>
<blockquote>
<p>另外一种可行的方案是直接通过 injectConstructor 的 getDeclaringClass 方法，返回该构造器所属的类。</p>
<p><img src="/blogs/25729/Snipaste_2024-08-09_19-43-11.png" alt="Snipaste_2024-08-09_19-43-11"></p>
<p>但是这个方法返回的就不是 Dependency，而是其子类 DependencyWithInjectConstructor</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected :interface world.nobug.tdd.di.Dependency</span><br><span class="line">Actual   :class world.nobug.tdd.di.DependencyWithInjectConstructor</span><br></pre></td></tr></table></figure>

<p>如果使用这个方法的话就需要修改测试为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(DependencyWithInjectConstructor.class, exception.getComponent());</span><br></pre></td></tr></table></figure>

<p>我们是将 DependencyWithInjectConstructor 绑定到 Dependency</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.bind(Dependency.class, DependencyWithInjectConstructor.class); </span><br></pre></td></tr></table></figure>

<p>所以，最好还是校验：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(Dependency.class, exception.getComponent());</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="CyclicDependenciesException"><a href="#CyclicDependenciesException" class="headerlink" title="CyclicDependenciesException"></a>CyclicDependenciesException</h2><p>同理，和 DependencyNotFoundException 类似，使用者希望从循环依赖异常中获得更多的异常信息，比如是哪两个组件之间出现了循环依赖或引发循环依赖的组件是哪一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> <span class="comment">// A -&gt; B -&gt; A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_cyclic_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    context.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line">    context.bind(Dependency.class, DependencyDependedOnComponent.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">CyclicDependenciesException</span> <span class="variable">exception</span> <span class="operator">=</span></span><br><span class="line">            assertThrows(CyclicDependenciesException.class, () -&gt; context.get(Component.class));</span><br><span class="line"></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classes = Sets.newSet(exception.getComponents());</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">2</span>, classes.size());</span><br><span class="line">    assertTrue(classes.contains(Component.class));</span><br><span class="line">    assertTrue(classes.contains(Dependency.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改异常，在异常中增加组件相互循环依赖的组件信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicDependenciesException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt;[] getComponents() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[<span class="number">0</span>]; <span class="comment">// 并没有实际的功能，只是为了使编译通过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>find usages 发现，只有在 Provider 的 get 方法中会抛出循环依赖的异常，那么需要在抛出异常时传入当前类型的信息</p>
<p><img src="/blogs/25729/image-20240810095457438.png" alt="image-20240810095457438"></p>
<p>修改异常类，创建构造函数，并增加保存循环依赖的容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicDependenciesException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; components = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CyclicDependenciesException</span><span class="params">(Class&lt;?&gt; componentType)</span> &#123;</span><br><span class="line">        components.add(componentType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt;[] getComponents() &#123;</span><br><span class="line">        <span class="keyword">return</span> components.toArray(Class&lt;?&gt;[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又因为，get 方法是一个递归调用的方法，所以第一次抛出循环依赖的异常是内层的 get 方法抛出的，那么外层的 get 方法不能吞掉&#x2F;软化循环依赖的异常，并且需要在这个异常中增加外层的组件类型信息。</p>
<p><img src="/blogs/25729/image-20240810101133637.png" alt="image-20240810101133637"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicDependenciesException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; components = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CyclicDependenciesException</span><span class="params">(Class&lt;?&gt; componentType)</span> &#123;</span><br><span class="line">        components.add(componentType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CyclicDependenciesException</span><span class="params">(Class&lt;?&gt; componentType, Class&lt;?&gt;[] components)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.components.add(componentType);</span><br><span class="line">        <span class="built_in">this</span>.components.addAll(Set.of(components));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt;[] getComponents() &#123;</span><br><span class="line">        <span class="keyword">return</span> components.toArray(Class&lt;?&gt;[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补全具有传递性依赖的测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> <span class="comment">// A -&gt; B -&gt; C -&gt; A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_transitive_cyclic_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    context.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line">    context.bind(Dependency.class, DependencyDependedOnAnotherDependency.class);</span><br><span class="line">    context.bind(AnotherDependency.class, AnotherDependencyDependedOnComponent.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">CyclicDependenciesException</span> <span class="variable">exception</span> <span class="operator">=</span></span><br><span class="line">            assertThrows(CyclicDependenciesException.class, () -&gt; context.get(Component.class));</span><br><span class="line"></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; components = Arrays.stream(exception.getComponents()).toList();</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">3</span>, components.size());</span><br><span class="line">    assertTrue(components.contains(Component.class));</span><br><span class="line">    assertTrue(components.contains(Dependency.class));</span><br><span class="line">    assertTrue(components.contains(AnotherDependency.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="将依赖的检查提前到获取实例之前"><a href="#将依赖的检查提前到获取实例之前" class="headerlink" title="将依赖的检查提前到获取实例之前"></a>将依赖的检查提前到获取实例之前</h1><p>目前对循环依赖的检查是在调用 get 方法从容器中获取实例时触发的，更好的方式是在 bind 时就校验是否存在循环依赖。</p>
<p>如果直接在 bind 中检查循环依赖的话，那么在当前类型在 bind 时必须保证其依赖的类型先被 bind，但是这对 API 的使用者来说是很不友好的，这样会要求使用者必须自己控制相互依赖的类型的 bind 顺序。</p>
<blockquote>
<p>通常我们对于IOC容器的要求是：根据配置文件构建容器上下文之后，很少进行修改。</p>
<p>IOC 容器是有一个明确的生命周期的，所有配置文件都被 load 好了，然后把容器 build 出来，一但上下文 build 好了，很少要求对上下文进行修改。</p>
</blockquote>
<p><strong>所以还是要在获取容器时检查依赖。</strong></p>
<p>所以预期修改后的结果大致是，从 context 中 get 一个 container，再从 container 中获取实例。</p>
<p>这个时候 context 就类似于一个 configuration。</p>
<p>这样就将构造的环境和真正构造好的对象的使用环节分开了，就是利用构造器模式来解决这个问题。</p>
<h2 id="重构-将-Builder-和-Context-上下文分开"><a href="#重构-将-Builder-和-Context-上下文分开" class="headerlink" title="重构-将 Builder 和 Context 上下文分开"></a>重构-将 Builder 和 Context 上下文分开</h2><p>将 Context 改名为 ContextConfig</p>
<h3 id="移动-get-方法"><a href="#移动-get-方法" class="headerlink" title="移动 get 方法"></a>移动 get 方法</h3><p>接着需要将 get 方法从 Context 中移动到其他地方，因为现在 ContextConfig 是要作为一个配置文件，不应该包含 get 实例的方法。</p>
<blockquote>
<p>bind 方法可以视为设置配置文件的操作</p>
</blockquote>
<p>最简单的做法是，先将 ContextConfig 实现一个 Context 接口</p>
<blockquote>
<p>因为在我们当前的代码中，ContextConfig 即是配置文件也是上下文容器本身。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextConfig</span> <span class="keyword">implements</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 Context 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着需要将 get 方法挪到 Context 接口中去</p>
<p>使用 Pull Members Up 重构方法，来挪动</p>
<p><img src="/blogs/25729/image-20240810110504080.png" alt="image-20240810110504080"></p>
<p><img src="/blogs/25729/image-20240810110639340.png" alt="image-20240810110639340"></p>
<p>挪动之后，Context 接口的变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    &lt;Type&gt; Optional&lt;Type&gt; <span class="title function_">get</span><span class="params">(Class&lt;Type&gt; type)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blogs/25729/image-20240810110805138.png" alt="image-20240810110805138"></p>
<p>接下来需要做的就是，让 get 方法不再直接调用 contextConfig 的内容，即需要将 get 方法从 config 中移除掉，但同时还要保持现在的功能。</p>
<p>第一查找替换的方式重构</p>
<p>创建一个获取 Context 的方法，这样才能在</p>
<blockquote>
<p>预期要做的就是将 Context 中的 get 方法实现为和当前 ContextConfig 中的 get 方法一致。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Context <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Context</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;Type&gt; Optional&lt;Type&gt; <span class="title function_">get</span><span class="params">(Class&lt;Type&gt; type)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.empty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 get 方法的实现提取为方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;Type&gt; Optional&lt;Type&gt; <span class="title function_">get</span><span class="params">(Class&lt;Type&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getType(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;Type&gt; Optional&lt;Type&gt; <span class="title function_">getType</span><span class="params">(Class&lt;Type&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(providers.get(type)).map(provider -&gt; (Type) provider.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 getContext 方法的实现委托给上一步提取的 getType 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Context <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Context</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;Type&gt; Optional&lt;Type&gt; <span class="title function_">get</span><span class="params">(Class&lt;Type&gt; type)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getType(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inline 掉 getType 方法，这样 getContext 中的实现方法，就和 get 方法一致了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Context <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Context</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;Type&gt; Optional&lt;Type&gt; <span class="title function_">get</span><span class="params">(Class&lt;Type&gt; type)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.ofNullable(providers.get(type)).map(provider -&gt; (Type) provider.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;Type&gt; Optional&lt;Type&gt; <span class="title function_">get</span><span class="params">(Class&lt;Type&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(providers.get(type)).map(provider -&gt; (Type) provider.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再将 get 方法的实现委给 getContext 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;Type&gt; Optional&lt;Type&gt; <span class="title function_">get</span><span class="params">(Class&lt;Type&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getContext().get(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着可以移除掉 get 方法的 Override，也移除掉 ContextConfig 需要实现的接口：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-10_11-36-38.png"></p>
<p><img src="/blogs/25729/image-20240810113656568.png" alt="image-20240810113656568"></p>
<p>接着，inline 掉 get 方法，那么之前使用 get 方法的地方都变成了调用 <code>getContext().get(type)</code></p>
<p><img src="/blogs/25729/Snipaste_2024-08-10_11-39-45.png" alt="Snipaste_2024-08-10_11-39-45"></p>
<p>那么，ContextConfig 中就只剩下两个 bind 方法，和 getContext 方法，这样就无法在修改上下文了。</p>
<p>这样，ContextConfig 就符合了我们将其用于配置上下文的要求。</p>
<p>这样就调整了它对外的接口，并将实现了 Config 和实际的 Context 容器的使用做了分离。</p>
<h2 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h2><p>经过上面的重构，就可以在 getContext 来进行必要的检查，比如<strong>检查循环依赖、依赖是否有缺失</strong>，等等情况。</p>
<p>当前，在 Provider 内部需要为当前组件注入依赖时，都需要从容器中查找依赖的实例（获取容器的方式都是调用 getContext 方法），但是，现在 getContext 时都会创建一个新的 Context，这不符合实际使用的要求。</p>
<p><img src="/blogs/25729/image-20240810115120039.png" alt="image-20240810115120039"></p>
<p>但是当前并不能从 Provider 中获取到容器上下文的实例，并且也无法在创建 Provider 时传入容器实例（此时容器还未创建）</p>
<p>那么只能通过在调用 get 方法时，传入已经存在的 Context</p>
<p>但是我们现在实现的 Provider 是 <code>jakarta.inject.Provider</code> 其中的 get 方法是一个无参方法，无法满足我们的需求，那么我们就需要创建一个有参的函数式接口。</p>
<h3 id="新建-Provider-接口"><a href="#新建-Provider-接口" class="headerlink" title="新建 Provider 接口"></a>新建 Provider 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ComponentProvider</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">(Context context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完之后，需要使用这个 ComponentProvider 来替换所有用到 Provider 的地方。</p>
<p>最直接的修改方式就是 人工手动的来做这个替换。</p>
<p>如果一定要按照严格的重构去做的话就需要平行的一步步替换，即先增加并逐步替换掉功能，再移除掉旧的功能。</p>
<p><strong>使用重构式的方式可以保证在代码量比较大的时候仍然能使代码修改成功。</strong></p>
<h3 id="逐步重构"><a href="#逐步重构" class="headerlink" title="逐步重构"></a>逐步重构</h3><p>新建一个 componentProviders</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Provider&lt;?&gt;&gt; providers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;?&gt;, ComponentProvider&lt;?&gt;&gt; componentProviders = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>修改 bind 的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Type instance)</span> &#123;</span><br><span class="line">    providers.put(type, () -&gt; instance);</span><br><span class="line">    componentProviders.put(type, context -&gt; instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;Type, Implementation <span class="keyword">extends</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation)</span> &#123;</span><br><span class="line">    Constructor&lt;Implementation&gt; injectConstructor = getInjectConstructor(implementation);</span><br><span class="line"></span><br><span class="line">    providers.put(type, <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>(type, injectConstructor));</span><br><span class="line">    componentProviders.put(type, <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>(type, injectConstructor));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 ConstructorInjectionProvider 的实现，通过实现两个接口来实现后续的平行替换。</p>
<p><img src="/blogs/25729/image-20240812095213493.png" alt="image-20240812095213493"></p>
<p>将 get 方法的实现提取为函数 getT，并将里面的 getContext() 抽取为函数参数</p>
<blockquote>
<p>使用 Ctrl + Alt + P 将 getContext() 提取为参数</p>
</blockquote>
<p>那么 ComponentProvider 的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getT(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，将 getT 方法 inline 并将 Provider 的实现修改为委托给  ComponentProvider 的 get 方法：</p>
<p>ComponentProvider 的 get 方法 inline：</p>
<p><img src="/blogs/25729/image-20240812100841607.png" alt="image-20240812100841607"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (constructing) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CyclicDependenciesException</span>(componentType);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        constructing = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 根据构造函数的参数，获取依赖的实例</span></span><br><span class="line">        Object[] dependencies = Arrays.stream(injectConstructor.getParameters())</span><br><span class="line">                .map(p -&gt; &#123;</span><br><span class="line">                    Class&lt;?&gt; type = p.getType();</span><br><span class="line">                    <span class="keyword">return</span> context.get(type)</span><br><span class="line">                            .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">DependencyNotFoundException</span>(</span><br><span class="line">                                    componentType, p.getType()));</span><br><span class="line">                &#125;)</span><br><span class="line">                .toArray(Object[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">return</span> injectConstructor.newInstance(dependencies);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CyclicDependenciesException e) &#123;</span><br><span class="line">        Class&lt;?&gt;[] components = e.getComponents();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CyclicDependenciesException</span>(componentType, components);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        constructing = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>inline getT 方法后，getT 方法就没有地方使用了，可以删除了</p>
</blockquote>
<p>接着，移除掉所有使用 providers 的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Provider&lt;?&gt;&gt; providers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>并将容器中的 Provider 改为 componentProviders，并在 get 时，传入当前的容器上下文 Context</p>
<p><img src="/blogs/25729/Snipaste_2024-08-12_10-27-52.png" alt="Snipaste_2024-08-12_10-27-52"></p>
<p>经过上面的重构，我们已经具备了在 bind 时检查依赖的能力。</p>
<p>这里还可以将 componProviders 重命名为 providers</p>
<h2 id="在获取容器时检查依赖缺失的情况"><a href="#在获取容器时检查依赖缺失的情况" class="headerlink" title="在获取容器时检查依赖缺失的情况"></a>在获取容器时检查依赖缺失的情况</h2><p>目前对依赖缺失的检查是在 get 时进行的。</p>
<p><img src="/blogs/25729/image-20240812104907259.png" alt="image-20240812104907259"></p>
<h3 id="构造测试-10"><a href="#构造测试-10" class="headerlink" title="构造测试"></a>构造测试</h3><p>那么，需要在获取容器时时检查，只需要将 <code>.get(Component.class)</code> 方法移除就可以了</p>
<blockquote>
<p>注意，这里可以同时修改传递性依赖缺失的测试用例</p>
<p><img src="/blogs/25729/Snipaste_2024-08-12_11-40-11.png" alt="Snipaste_2024-08-12_11-40-11"></p>
</blockquote>
<p>移除后运行测试，测试不通过：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.opentest4j.AssertionFailedError: Expected world.nobug.tdd.di.DependencyNotFoundException to be thrown, but nothing was thrown.</span><br></pre></td></tr></table></figure>

<h3 id="快速实现-5"><a href="#快速实现-5" class="headerlink" title="快速实现"></a>快速实现</h3><p>需要在 getContext 时检查依赖：</p>
<p><img src="/blogs/25729/image-20240812110730534.png" alt="image-20240812110730534"></p>
<p>实现：在 bind 时同时记录注册的组件需要哪些依赖的类型，并在创建 Context 之前校验所有组件的依赖的类型是否都已经注册到容器中了</p>
<p>新建一个字段记录组件的依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; dependencies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>在 bind 时记录组件需要的依赖的类型：</p>
<p><img src="/blogs/25729/image-20240812111635721.png" alt="image-20240812111635721"></p>
<p>在创建容器上下文之前，先检查所有注册的组件所需要的所有依赖是否都已经注册到容器中:</p>
<p><img src="/blogs/25729/image-20240812112111509.png" alt="image-20240812112111509"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; component : dependencies.keySet()) &#123; <span class="comment">// 遍历所有需要注册到容器中的组件</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; dependency : dependencies.get(component)) &#123; <span class="comment">// 获取当前遍历的组件的所有依赖的类型，并遍历这些依赖的类型</span></span><br><span class="line">        <span class="keyword">if</span> (!componentProviders.containsKey(dependency)) <span class="comment">// 检查容器中是否已经注册了这些依赖的类型</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DependencyNotFoundException</span>(component, dependency);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在没有循环依赖的情况下，直接检查依赖的类型是否注册到容器是有效的。</p>
</blockquote>
<p>同理，对于间接的依赖缺失的测试，也需要修改</p>
<p><img src="/blogs/25729/Snipaste_2024-08-12_11-40-11.png" alt="Snipaste_2024-08-12_11-40-11"></p>
<p>移除<code>.get(Component.class)</code> ，运行测试，测试也会通过。</p>
<h2 id="简单重构-简化命名"><a href="#简单重构-简化命名" class="headerlink" title="简单重构-简化命名"></a>简单重构-简化命名</h2><p>将 componentProviders 重命名为 providers</p>
<p>将 contextConfig 重命名为 config</p>
<h2 id="在获取容器时检查循环依赖的情况"><a href="#在获取容器时检查循环依赖的情况" class="headerlink" title="在获取容器时检查循环依赖的情况"></a>在获取容器时检查循环依赖的情况</h2><h3 id="构造测试-11"><a href="#构造测试-11" class="headerlink" title="构造测试"></a>构造测试</h3><p>同理这里也是需要移除<code>.get(Component.class)</code></p>
<blockquote>
<p>循环依赖的测试也有两个，一个是直接循环依赖，一个是间接&#x2F;传递循环依赖，都需要修改测试</p>
</blockquote>
<h3 id="快速实现-6"><a href="#快速实现-6" class="headerlink" title="快速实现"></a>快速实现</h3><p>这里的实现原理就是基于图算法：给定一个图的连接表，寻找图上是否存在环。</p>
<p>深度优先遍历，检查是否会重复回到某个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深度优先遍历 检查 component 的依赖的访问记录</span></span><br><span class="line"><span class="comment">// visiting 保存正在被访问的记录，如果发现正在被访问的记录再次被访问，说明存在循环依赖</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkDependencies</span><span class="params">(Class&lt;?&gt; component, Stack&lt;Class&lt;?&gt;&gt; visiting)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; dependency : dependencies.get(component)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visiting.contains(dependency)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CyclicDependenciesException</span>(visiting);</span><br><span class="line">        visiting.push(dependency);</span><br><span class="line">        checkDependencies(dependency, visiting);</span><br><span class="line">        visiting.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getContext 时深度优先遍历，检查每一个组件的依赖链上是否有环</p>
<p><img src="/blogs/25729/image-20240812140847037.png" alt="image-20240812140847037"></p>
<p>运行测试，<code>should_throw_exception_if_transitive_dependency_not_found</code> 会有空指针异常，异常发生在</p>
<p><img src="/blogs/25729/image-20240812142838411.png" alt="image-20240812142838411"></p>
<p>因为在这个测试中，String 类型并没有注册到容器中，即没有执行 <code>bind(String.class, &quot;Hello&quot;)</code>方法，所以递归到 <code>dependencies.get(String.class)</code> 时，会返回 null，就会引发空指针异常。</p>
<p>修改，提前判断依赖是否存在，如果不存在就不必再进行下一步的递归了，避免了空指针异常。</p>
<p><img src="/blogs/25729/Snipaste_2024-08-12_14-42-35.png" alt="Snipaste_2024-08-12_14-42-35"></p>
<p>那么以下的代码，就是重复了，可以移除了</p>
<p><img src="/blogs/25729/image-20240812144651351.png" alt="image-20240812144651351"></p>
<p>将 for 循环的代码改成 foreach 形式</p>
<p><img src="/blogs/25729/Snipaste_2024-08-12_14-50-35.png" alt="Snipaste_2024-08-12_14-50-35"></p>
<h2 id="移除获取实例时（get时）往外抛异常的代码"><a href="#移除获取实例时（get时）往外抛异常的代码" class="headerlink" title="移除获取实例时（get时）往外抛异常的代码"></a>移除获取实例时（get时）往外抛异常的代码</h2><p>因为在创建容器前就已经做了依赖相关的检查，所以就不需要在 ConstructorInjectionProvider 的 get 方法中再往外抛异常了</p>
<p><img src="/blogs/25729/image-20240812145737955.png" alt="image-20240812145737955"></p>
<blockquote>
<p>注意，这里移除掉 orElseThrow 后需要调用 get方法，否在会报 IllegalArgumentException。</p>
</blockquote>
<p>移掉掉 get 方法中的异常校验后，代码如下：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-12_15-02-46.png" alt="Snipaste_2024-08-12_15-02-46"></p>
<p>接着，移除掉异常类中不在使用的构造方法：</p>
<p><img src="/blogs/25729/image-20240812150633641.png" alt="image-20240812150633641"></p>
<p>再移除些不在使用的代码：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-12_15-09-43.png" alt="Snipaste_2024-08-12_15-09-43"></p>
<p>这个字段现在只在构造方法中使用，也可以移除掉。</p>
<h1 id="重构-将-dependencies-移入-providers"><a href="#重构-将-dependencies-移入-providers" class="headerlink" title="重构-将 dependencies 移入 providers"></a>重构-将 dependencies 移入 providers</h1><p>目前，我们可以观察到在providers中添加数据时同步也会在dependencies中添加数据</p>
<p>你会发现 dependencies 和 providers 一直是伴生的，这实际上意味着，dependencies 是 providers 的额外信息。</p>
<p>这就是一个代码的坏味道，我们需要将其重构的更加高内聚，需要将 dependencies 的关系，放回到 providers 当中去。</p>
<p><img src="/blogs/25729/Snipaste_2024-08-12_15-15-52.png" alt="Snipaste_2024-08-12_15-15-52"></p>
<p>给 ComponentProvider 接口增加 getDependencies 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ComponentProvider</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; getDependencies();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现接口，绑定实例时，已经无法使用lambda表达式，应该使用匿名类</p>
<p><img src="/blogs/25729/image-20240812153821742.png" alt="image-20240812153821742"></p>
<p>修改 ConstructorInjectionProvider 中的 getDependencies 方法的实现，实现为：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-12_15-42-40.png" alt="Snipaste_2024-08-12_15-42-40">	<img src="/blogs/25729/Snipaste_2024-08-12_15-43-10.png" alt="Snipaste_2024-08-12_15-43-10"></p>
<p>通过 提取方法 + inline 的重构方式实现。</p>
<p>接着，需要将使用 dependencies 的地方，修改为通过 providers 来获取。</p>
<p>目前使用到 dependencies 的地方就是在创建容器前对依赖缺失、循环依赖的校验上。</p>
<p>可以观察到 providers 和 dependencies 的 key 是一样的，所以，所有对于 dependencies 的 key 访问都可以修改为对 providers 的 key 访问。</p>
<p>需要修改的代码如下，分别将其修改为对 providers 的调用</p>
<blockquote>
<p>每改动一处跑一次测试，通过小步持续跑测试的方式是改进</p>
</blockquote>
<p><img src="/blogs/25729/image-20240812160514288.png" alt="image-20240812160514288"></p>
<p>修改后：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-12_16-10-12.png" alt="Snipaste_2024-08-12_16-10-12"></p>
<p>接着需要移除 dependencies，观察发现，目前 dependencies 只会用来保存数据，所以可以直接将其移除。</p>
<p>可以观察到 getInjectConstructor 除了用于构造 ConstructorInjectionProvider 之外，没有其他的用处。</p>
<p>那么，可以将这个方法，移动到 ConstructorInjectionProvider 里面去，然后在其构造函数中直接调用就好了，这也是一种让代码变得高内聚的方式。</p>
<p>使用 Move Members 的重构方式移动</p>
<p><img src="/blogs/25729/image-20240812162507968.png" alt="image-20240812162507968"></p>
<p><img src="/blogs/25729/Snipaste_2024-08-12_16-26-15.png" alt="Snipaste_2024-08-12_16-26-15"></p>
<p>接着会发现，对这个方法的调用，变成了如下形式：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-12_16-26-45.png" alt="Snipaste_2024-08-12_16-26-45"></p>
<p>inline 一下会发现，new ConstructorInjectionProvider 时，调用了一个 ConstructorInjectionProvider 的静态方法，这也是一种很无聊的做法（坏味道）</p>
<p><img src="/blogs/25729/image-20240812162800695.png" alt="image-20240812162800695"></p>
<p>那么只需要将 ConstructorInjectionProvider 的构造方法修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConstructorInjectionProvider</span><span class="params">(Class&lt;T&gt; component)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.injectConstructor = getInjectConstructor(component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="重构-减少ContextConfig的代码量"><a href="#重构-减少ContextConfig的代码量" class="headerlink" title="重构-减少ContextConfig的代码量"></a>重构-减少ContextConfig的代码量</h1><p>将 ConstructorInjectionProvider 从 ContextConfig 中移除形成一个新的单元（组件）</p>
<p><img src="/blogs/25729/image-20240812164601445.png" alt="image-20240812164601445"></p>
<p><img src="/blogs/25729/image-20240812164702951.png" alt="image-20240812164702951"></p>
<p><img src="/blogs/25729/Snipaste_2024-08-12_16-51-08.png" alt="Snipaste_2024-08-12_16-51-08"></p>
<h1 id="Field-Injection"><a href="#Field-Injection" class="headerlink" title="Field Injection"></a>Field Injection</h1><h2 id="如何构造测试"><a href="#如何构造测试" class="headerlink" title="如何构造测试"></a>如何构造测试</h2><blockquote>
<p>这节个人感觉比较重要的就是对于同样的功能，在不同上下文环境下对测试风格的选择方式问题。 在某些情况下，不同的风格传递的信息或者说知识是不太一样的。而伴随你不同风格的选择可能直接影响后续功能实现的难易程度。TDD主要的难点还是在于设计，在于你对知识的理解，究竟是以一种怎样的方式呈现出来。</p>
</blockquote>
<p>对于重构过后的代码，如何以何种方式来完成测试？</p>
<p>根据不同环境下会有不同的考量，甚至在同样的功能中选择不同风格的测试</p>
<blockquote>
<p>测试不仅仅是测试，测试中还蕴含着知识的传递</p>
</blockquote>
<p>字段注入</p>
<ul>
<li>通过 Inject 标注将字段声明为依赖组件</li>
<li>如果组件需要的依赖不存在，则抛出异常</li>
<li>如果字段为 final 则抛出异常</li>
<li>如果组件间存在循环依赖，则抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> field injection</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> throw exception if dependency not found</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> throw exception if filed is final</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> throw exception if cyclic dependency</span></span><br></pre></td></tr></table></figure>

<p>我们把 ConstructorInjectionProvider 从 ContextConfig 中分离出来，也可以说我们的架构改变了，原来我们可以说是一个单体的结构，没有组件和组件间的交互。</p>
<p>字段注入应该是有如下形式的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ComponentWithFieldInjection</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Dependency dependency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即，这个类中包含一个被 <code>@Inject</code> 标注的字段。</p>
<p>如果还是按照之前的形式构造测试的话，我们会构造出如下测测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> field injection</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_inject_dependency_via_field</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Dependency</span> <span class="variable">dependency</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dependency</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    config.bind(Dependency.class, dependency);</span><br><span class="line">    config.bind(ComponentWithFieldInjection.class, ComponentWithFieldInjection.class);</span><br><span class="line">    <span class="type">ComponentWithFieldInjection</span> <span class="variable">component</span> <span class="operator">=</span> config.getContext().get(ComponentWithFieldInjection.class).get();</span><br><span class="line"></span><br><span class="line">    assertSame(dependency, component.dependency);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在之前的课上也讲过，如果你的架构变了，那么你的任务也可以变。也可以用一些更小范围的测试去测。</p>
<p>所以，另外的写法呢就可以是如下形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_create_component_with_field_injection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> Mockito.mock(Context.class);</span><br><span class="line">    <span class="type">Dependency</span> <span class="variable">dependency</span> <span class="operator">=</span> Mockito.mock(Dependency.class);</span><br><span class="line">    Mockito.when(context.get(eq(Dependency.class)))</span><br><span class="line">            .thenReturn(Optional.of(dependency)); <span class="comment">// Provider 内部需要使用context.get方法获取依赖</span></span><br><span class="line"></span><br><span class="line">    ConstructorInjectionProvider&lt;ComponentWithFieldInjection&gt; provider =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(ComponentWithFieldInjection.class);</span><br><span class="line">    <span class="type">ComponentWithFieldInjection</span> <span class="variable">component</span> <span class="operator">=</span> provider.get(context); <span class="comment">// 会返回一个实例</span></span><br><span class="line"></span><br><span class="line">    assertSame(dependency, component.dependency);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，在重构过程中，随着架构的变化，你实现测试的选择也会有所不同。</p>
<p>对比以上两个测试，可以发现，第一个测试是一个更完整的、范围更大的端到端的功能测试，而第二个它更多的是集中在被我们抽离出来的单元本身，从某种意义上来讲，第二个测试更接近传统意义上的单元测试。</p>
<p>这两个测试并没有什么差别，只是选择的粒度和范围不同而已。也就是对功能上下文、功能点进行了进一步分解。</p>
<blockquote>
<p><strong>并不是功能架构拆分之后，就应该按照更小的粒度来做测试。</strong></p>
<p>因为测试不仅仅是测试，其中还蕴含着功能上下文中的知识，如果使用测试替身的方式构造测试的话，就需要在测试中管理知识，有可能让新人不会很容易理解。</p>
<p>所以在构造测试方法时不仅包含测试的成本，也隐含着测试传递的知识。</p>
</blockquote>
<p>再看看这两种测试策略在其他的功能上下文中有什么不一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> throw exception if dependency not found</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_filed_dependency_not_found</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(ComponentWithFieldInjection.class, ComponentWithFieldInjection.class);</span><br><span class="line"></span><br><span class="line">    assertThrows(DependencyNotFoundException.class, () -&gt; config.getContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果缩小测试范围，仅针对单元本身做测试的话，测试应该会被构造成如下形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_include_field_dependency_in_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    ConstructorInjectionProvider&lt;ComponentWithFieldInjection&gt; provider =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(ComponentWithFieldInjection.class);</span><br><span class="line"></span><br><span class="line">    assertArrayEquals(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;Dependency.class&#125;, provider.getDependencies().toArray(Class&lt;?&gt;[]::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么是构造成这种形式呢？</p>
<p>从源码我们可知，对依赖的检查，只需要从 provider 的 getDependencies 获取到其<strong>所需的所有的正确的依赖</strong>就可以进行正确的检查了。</p>
<blockquote>
<p>后续的检查是在 getContext 时，即创建容器时（new 之前）做的，检查时需要获取到每一个组件的依赖。</p>
<p>所以只要 getDependencies 能返回正确的结果，那么就可以保证后续依赖缺失和循环依赖检查的代码能正确实现。</p>
</blockquote>
<p><img src="/blogs/25729/image-20240813102203192.png" alt="image-20240813102203192"></p>
<p>但是目前这个方法只返回了构造函数参数所需的依赖，那么后续实现只需要在这个方法返回中增加 field 中所需的依赖即可。</p>
<p><img src="/blogs/25729/image-20240813102811774.png" alt="image-20240813102811774"></p>
<blockquote>
<p>你会发现，实际上无论是 dependency not found 还是 循环依赖，实际上都是在 ContextConfig 中去实现的。</p>
</blockquote>
<p>同理，循环依赖的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> throw exception if cyclic dependency</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DependencyWithFieldInjection</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    ComponentWithFieldInjection component;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_when_filed_has_cyclic_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(ComponentWithFieldInjection.class, ComponentWithFieldInjection.class);</span><br><span class="line">    config.bind(Dependency.class, DependencyWithFieldInjection.class);</span><br><span class="line"></span><br><span class="line">    assertThrows(CyclicDependenciesException.class, () -&gt; config.getContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实这里 DependencyWithFieldInjection 可以不必实现 Dependency</p>
</blockquote>
<p>如果减小测试的粒度，我们会发现循环依赖的测试，其实和依赖不存在的测试是一样的：</p>
<blockquote>
<p>因为检查依赖不存在和检查循环依赖都是在 checkDependencies 方法中做的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_include_field_dependency_in_dependencies_</span><span class="params">()</span> &#123;</span><br><span class="line">    ConstructorInjectionProvider&lt;ComponentWithFieldInjection&gt; provider =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(ComponentWithFieldInjection.class);</span><br><span class="line"></span><br><span class="line">    assertArrayEquals(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;Dependency.class&#125;, provider.getDependencies().toArray(Class&lt;?&gt;[]::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以对<code>TODO: throw exception if dependency not found</code> 和 <code>TODO: throw exception if cyclic dependency</code> 的测试任务可以合并为一个任务，比如：<code>TODO: provide dependencies information for field injection</code>，即：依赖中应包含 Inject Field 声明的依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> provide dependencies information for field injection</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_include_field_dependency_in_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    ConstructorInjectionProvider&lt;ComponentWithFieldInjection&gt; provider =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(ComponentWithFieldInjection.class);</span><br><span class="line"></span><br><span class="line">    assertArrayEquals(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;Dependency.class&#125;, provider.getDependencies().toArray(Class&lt;?&gt;[]::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过取舍，我们选择保留以下的测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ComponentWithFieldInjection</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Dependency dependency;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> field injection</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_inject_dependency_via_field</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Dependency</span> <span class="variable">dependency</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dependency</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    config.bind(Dependency.class, dependency);</span><br><span class="line">    config.bind(ComponentWithFieldInjection.class, ComponentWithFieldInjection.class);</span><br><span class="line">    <span class="type">ComponentWithFieldInjection</span> <span class="variable">component</span> <span class="operator">=</span> config.getContext().get(ComponentWithFieldInjection.class).get();</span><br><span class="line"></span><br><span class="line">    assertSame(dependency, component.dependency);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> provide dependencies information for field injection</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_include_field_dependency_in_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    ConstructorInjectionProvider&lt;ComponentWithFieldInjection&gt; provider =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(ComponentWithFieldInjection.class);</span><br><span class="line"></span><br><span class="line">    assertArrayEquals(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;Dependency.class&#125;, provider.getDependencies().toArray(Class&lt;?&gt;[]::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-should-inject-dependency-via-field"><a href="#实现-should-inject-dependency-via-field" class="headerlink" title="实现 should_inject_dependency_via_field"></a>实现 should_inject_dependency_via_field</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> field injection</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_inject_dependency_via_field</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Dependency</span> <span class="variable">dependency</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dependency</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    config.bind(Dependency.class, dependency);</span><br><span class="line">    config.bind(ComponentWithFieldInjection.class, ComponentWithFieldInjection.class);</span><br><span class="line">    <span class="type">ComponentWithFieldInjection</span> <span class="variable">component</span> <span class="operator">=</span> config.getContext().get(ComponentWithFieldInjection.class).get();</span><br><span class="line"></span><br><span class="line">    assertSame(dependency, component.dependency);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，会有因为无法获取到构造函数（NoSuchMethodException）而抛出 IllegalComponentException 异常</p>
<p><img src="/blogs/25729/Snipaste_2024-08-13_11-02-35.png" alt="Snipaste_2024-08-13_11-02-35"></p>
<p>首先需要将 ComponentWithFieldInjection 修改为静态内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ComponentWithFieldInjection</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Dependency dependency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里也可以将这个类定义为最顶层的类，就和前面构造的 Component 、Dependency 一样，那么修改的代码就要少一点。</p>
</blockquote>
<p>并且需要使用 <code>getDeclaredConstructor</code> 来获取构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> implementation.getDeclaredConstructor();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ComponentWithFieldInjection</code> 是一个非静态内部类（即它是在另一个类的内部定义的类，并且不带有 <code>static</code> 关键字），它的构造函数需要调用外部类的构造函数。如果是静态内部类，则不需要这样做。</p>
</blockquote>
<blockquote>
<p>对于非静态内部类（即没有使用 <code>static</code> 关键字修饰的内部类），其构造函数实际上是私有的，并且会附加一个对外部类实例的引用。这意味着，即使您没有显式定义构造函数，编译器也会为您生成一个私有的构造函数，该构造函数接受一个外部类的实例作为参数。</p>
<p>假设您有一个外部类 <code>OuterClass</code> 和一个非静态内部类 <code>ComponentWithFieldInjection</code>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> Dependency dependency;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentWithFieldInjection</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> Dependency dependency;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，您不能直接通过 <code>getConstructor</code> 获取到 <code>ComponentWithFieldInjection</code> 的构造函数，因为该构造函数是私有的，并且它实际上接受一个 <code>OuterClass</code> 实例作为参数。</p>
<p>为了获取非静态内部类的构造函数，您需要使用 <code>getDeclaredConstructor</code> 并且指定参数类型，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> Constructor&lt;ComponentWithFieldInjection&gt; constructor =</span><br><span class="line">     OuterClass.class.getDeclaredConstructor(OuterClass.class);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line"> <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，上述代码中的 <code>getDeclaredConstructor</code> 要求您知道构造函数的确切签名。由于构造函数是私有的，您还需要调用 <code>setAccessible(true)</code> 来允许访问它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>但是，通常情况下，您并不需要直接通过反射来创建非静态内部类的实例。通常的做法是通过外部类的实例来创建内部类的实例。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OuterClass</span> <span class="variable">outerInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line"><span class="type">ComponentWithFieldInjection</span> <span class="variable">component</span> <span class="operator">=</span> outerInstance.<span class="keyword">new</span> <span class="title class_">ComponentWithFieldInjection</span>();</span><br></pre></td></tr></table></figure>

<p>总结一下，对于非静态内部类，您不能直接使用 <code>getConstructor</code> 来获取其构造函数，而需要使用 <code>getDeclaredConstructor</code> 并且可能需要调用 <code>setAccessible(true)</code> 来访问私有构造函数。</p>
</blockquote>
<blockquote>
<p>在Java中，<code>getDeclaredConstructor</code>和<code>getConstructor</code>都是用于通过反射来获取类的构造函数的方法，但它们之间存在一些重要的区别：</p>
<ol>
<li><p><strong><code>getConstructor</code></strong>:</p>
<ul>
<li>这个方法是从<code>Class</code>类继承来的，用于获取公开的构造函数。</li>
<li>它可以获取到类的公共构造函数，包括从父类继承来的构造函数。</li>
<li>如果类中有多个公共构造函数，你可以通过指定参数类型数组来获取特定的构造函数。</li>
<li>如果类没有公共构造函数或者没有匹配给定参数类型的构造函数，这个方法会抛出<code>NoSuchMethodException</code>。</li>
</ul>
</li>
<li><p><strong><code>getDeclaredConstructor</code></strong>:</p>
<ul>
<li>这个方法也是从<code>Class</code>类继承来的，但它用于获取类中声明的构造函数，无论这些构造函数是否是公共的。</li>
<li>它可以获取到类本身的构造函数，包括私有的、受保护的、包私有的以及公共的构造函数，但不会获取从父类继承的构造函数。</li>
<li>同样地，你可以通过指定参数类型数组来获取特定的构造函数。</li>
<li>如果类中没有声明匹配给定参数类型的构造函数，这个方法会抛出<code>NoSuchMethodException</code>。</li>
</ul>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设我们有一个类<code>MyClass</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123; &#125;  <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(String name)</span> &#123; &#125;  <span class="comment">// 公共构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以这样使用这两个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;MyClass&gt; clazz = MyClass.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取公共构造函数</span></span><br><span class="line">    Constructor&lt;MyClass&gt; publicConstructor = clazz.getConstructor(String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取声明的构造函数（包括私有的）</span></span><br><span class="line">    Constructor&lt;MyClass&gt; declaredPrivateConstructor = clazz.getDeclaredConstructor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问私有构造函数</span></span><br><span class="line">    declaredPrivateConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">MyClass</span> <span class="variable">instance</span> <span class="operator">=</span> declaredPrivateConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>getConstructor</code> 主要用于获取类的公共构造函数。</li>
<li><code>getDeclaredConstructor</code> 主要用于获取类中声明的所有构造函数，包括非公共的构造函数。</li>
</ul>
<p>如果你想要获取一个类中的所有构造函数，不论它们的访问级别如何，应该使用<code>getDeclaredConstructors</code>方法，而不是单个构造函数的版本。</p>
</blockquote>
<p>获取到构造函数之后，就可以创建实例，因为依赖是字段不是构造函数的参数，所以还需要知道有哪些被 <code>@Inject</code> 标注的字段</p>
<p><img src="/blogs/25729/Snipaste_2024-08-13_11-40-48.png" alt="Snipaste_2024-08-13_11-40-48"></p>
<p>获取到字段，并创建好实例后就需要给字段赋值：</p>
<p><img src="/blogs/25729/image-20240813114315788.png" alt="image-20240813114315788"></p>
<p>即，根据依赖的字段的类型，从容器中获取该类型的实例，并赋值到该字段中。</p>
<p>运行测试，测试通过。</p>
<h2 id="实现-provide-dependencies-information-for-field-injection"><a href="#实现-provide-dependencies-information-for-field-injection" class="headerlink" title="实现 provide dependencies information for field injection"></a>实现 provide dependencies information for field injection</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> provide dependencies information for field injection</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_include_field_dependency_in_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    ConstructorInjectionProvider&lt;ComponentWithFieldInjection&gt; provider =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(ComponentWithFieldInjection.class);</span><br><span class="line"></span><br><span class="line">    assertArrayEquals(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;Dependency.class&#125;, provider.getDependencies().toArray(Class&lt;?&gt;[]::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要在 getDependencies 方法的返回结果中增加字段注入的依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Class&lt;?&gt;&gt; getDependencies() &#123;</span><br><span class="line">    Stream&lt;? <span class="keyword">extends</span> <span class="title class_">Class</span>&lt;?&gt;&gt; b = injectFields.stream().map(Field::getType);</span><br><span class="line">    Stream&lt;? <span class="keyword">extends</span> <span class="title class_">Class</span>&lt;?&gt;&gt; a = Arrays.stream(injectConstructor.getParameters()).map(Parameter::getType);</span><br><span class="line">    <span class="keyword">return</span> Stream.concat(a, b).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对-Subclass-的支持"><a href="#对-Subclass-的支持" class="headerlink" title="对 Subclass 的支持"></a>对 Subclass 的支持</h2><p>新建一个子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SubclassWithFieldInjection</span> <span class="keyword">extends</span> <span class="title class_">ComponentWithFieldInjection</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_inject_dependency_via_superclass_inject_filed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Dependency</span> <span class="variable">dependency</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dependency</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    config.bind(Dependency.class, dependency);</span><br><span class="line">    config.bind(SubclassWithFieldInjection.class, SubclassWithFieldInjection.class);</span><br><span class="line">    <span class="type">SubclassWithFieldInjection</span> <span class="variable">component</span> <span class="operator">=</span> config.getContext().get(SubclassWithFieldInjection.class).get();</span><br><span class="line"></span><br><span class="line">    assertSame(dependency, component.dependency);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected :world.nobug.tdd.di.ContainerTest$ComponentConstruction$FieldInjection$2@479cbee5</span><br><span class="line">Actual   :null</span><br></pre></td></tr></table></figure>

<p>这是因为，当前在取注入的字段时，只取了当前类的字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; List&lt;Field&gt; <span class="title function_">getInjectFields</span><span class="params">(Class&lt;T&gt; component)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(component.getDeclaredFields())</span><br><span class="line">            .filter(f -&gt; f.isAnnotationPresent(Inject.class)).toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，还需要获取到父类的字段，可以通过递归的方式，找到父类的所有的注入字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; List&lt;Field&gt; <span class="title function_">getInjectFields</span><span class="params">(Class&lt;T&gt; component)</span> &#123;</span><br><span class="line">    List&lt;Field&gt; injectFields = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Class&lt;?&gt; current = component;</span><br><span class="line">    <span class="keyword">while</span> (current != Object.class) &#123;</span><br><span class="line">        injectFields.addAll(Arrays.stream(current.getDeclaredFields())</span><br><span class="line">                .filter(f -&gt; f.isAnnotationPresent(Inject.class)).toList());</span><br><span class="line">        current = current.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> injectFields;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Method-Injection"><a href="#Method-Injection" class="headerlink" title="Method Injection"></a>Method Injection</h1><p>方法注入</p>
<ul>
<li><p>通过 Inject 标注的方法，其参数为依赖组件</p>
</li>
<li><p>通过 Inject 标注的无参数方法，会被调用</p>
</li>
<li><p>按照子类中的规则，覆盖父类中的 Inject 方法</p>
</li>
<li><p>如果组件需要的依赖不存在，则抛出异常</p>
</li>
<li><p>如果方法定义类型参数，则抛出异常</p>
</li>
<li><p>如果组件间存在循环依赖，则抛出异常</p>
</li>
</ul>
<p>方法测试的任务列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO inject method with no dependencies will be called</span></span><br><span class="line"><span class="comment">// TODO inject method with dependencies will be injected</span></span><br><span class="line"><span class="comment">// TODO override inject method from superclass</span></span><br><span class="line"><span class="comment">// TODO include dependencies from inject methods</span></span><br><span class="line"><span class="comment">// TODO throw exception if type parameter defined</span></span><br></pre></td></tr></table></figure>

<h2 id="无参方法注入"><a href="#无参方法注入" class="headerlink" title="无参方法注入"></a>无参方法注入</h2><p>定义一个带有无参方法注入的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InjectMethodWithNoDependencies</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">called</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 用于验证方法是否被调用</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> inject method with no dependencies will be called</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_call_inject_method_with_no_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(InjectMethodWithNoDependencies.class, InjectMethodWithNoDependencies.class);</span><br><span class="line">    <span class="type">InjectMethodWithNoDependencies</span> <span class="variable">instance</span> <span class="operator">=</span> config.getContext().get(InjectMethodWithNoDependencies.class).get();</span><br><span class="line"></span><br><span class="line">    assertTrue(instance.called);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现，同理先找到并记录所有被 <code>@Inject</code> 标注的方法</p>
<p><img src="/blogs/25729/Snipaste_2024-08-13_14-51-24.png" alt="Snipaste_2024-08-13_14-51-24"></p>
<p>获取实例时，调用这些方法注入依赖：</p>
<p><img src="/blogs/25729/image-20240813151931496.png" alt="image-20240813151931496"></p>
<h2 id="有参方法注入"><a href="#有参方法注入" class="headerlink" title="有参方法注入"></a>有参方法注入</h2><p>新建有参方法注入类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InjectMethodWithDependencies</span> &#123;</span><br><span class="line">    Dependency dependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(Dependency dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> inject method with dependencies will be injected</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_call_inject_method_with_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Dependency</span> <span class="variable">dependency</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dependency</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    config.bind(Dependency.class, dependency);</span><br><span class="line">    config.bind(InjectMethodWithDependencies.class, InjectMethodWithDependencies.class);</span><br><span class="line">    <span class="type">InjectMethodWithDependencies</span> <span class="variable">instance</span> <span class="operator">=</span> config.getContext().get(InjectMethodWithDependencies.class).get();</span><br><span class="line"></span><br><span class="line">    assertSame(dependency, instance.dependency);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，直接通过，说明不需要修改生产代码。</p>
<h2 id="对依赖的检查"><a href="#对依赖的检查" class="headerlink" title="对依赖的检查"></a>对依赖的检查</h2><p>检查依赖是否存在、是否存在循环依赖</p>
<p>构造测试，减小测试的粒度，直接对 ConstructorInjectionProvider 进行测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> include dependencies from inject methods</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_include_method_dependency_in_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    ConstructorInjectionProvider&lt;InjectMethodWithDependencies&gt; provider =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(InjectMethodWithDependencies.class);</span><br><span class="line"></span><br><span class="line">    assertArrayEquals(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;Dependency.class&#125;, provider.getDependencies().toArray(Class&lt;?&gt;[]::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理需要在 getDependencies 方法中增加返回方法注入点所需的依赖参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Class&lt;?&gt;&gt; getDependencies() &#123;</span><br><span class="line">    Stream&lt;? <span class="keyword">extends</span> <span class="title class_">Class</span>&lt;?&gt;&gt; b = injectFields.stream().map(Field::getType);</span><br><span class="line">    Stream&lt;? <span class="keyword">extends</span> <span class="title class_">Class</span>&lt;?&gt;&gt; a = Arrays.stream(injectConstructor.getParameters()).map(Parameter::getType);</span><br><span class="line">    Stream&lt;Class&lt;?&gt;&gt; c = injectMethods.stream().flatMap(m -&gt; Arrays.stream(m.getParameterTypes()));</span><br><span class="line">    Stream&lt;Class&lt;?&gt;&gt; concat = Stream.concat(a, b);</span><br><span class="line">    <span class="keyword">return</span> Stream.concat(concat, c).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 flatMap 的原因：</p>
<p>由于 <code>getParameterTypes()</code> 返回的是一个 <code>Class&lt;?&gt;[]</code> 数组，每次调用都会返回多个元素，而不是单个元素。因此，如果你直接使用 <code>map</code> 操作来转换这些数组，你将得到一个由多个 <code>Class&lt;?&gt;[]</code> 组成的流，而不是一个扁平化的流，其中包含所有的 <code>Class&lt;?&gt;</code> 对象。</p>
<p>为了解决这个问题，你需要使用 <code>flatMap</code> 操作来“展平”这些数组，将它们合并成一个单一的流，这样你就可以继续对这个流进行操作，比如收集结果到一个列表中。</p>
</blockquote>
<h2 id="父类和子类的方法注入"><a href="#父类和子类的方法注入" class="headerlink" title="父类和子类的方法注入"></a>父类和子类的方法注入</h2><p>方法注入的难点，主要是在子类和父类之间方法注入的调用关系</p>
<h3 id="子类注册时，需要调用父类的注入点方法"><a href="#子类注册时，需要调用父类的注入点方法" class="headerlink" title="子类注册时，需要调用父类的注入点方法"></a>子类注册时，需要调用父类的注入点方法</h3><p>新建父子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> override inject method from superclass</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SuperClassWithInjectMethod</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">superCalled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">        superCalled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SubclassWithInjectMethod</span> <span class="keyword">extends</span> <span class="title class_">SuperClassWithInjectMethod</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">subCalled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">installAnother</span><span class="params">()</span> &#123;</span><br><span class="line">        subCalled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_inject_dependencies_via_inject_method_from_superclass</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(SubclassWithInjectMethod.class, SubclassWithInjectMethod.class);</span><br><span class="line">    <span class="type">SubclassWithInjectMethod</span> <span class="variable">instance</span> <span class="operator">=</span> config.getContext().get(SubclassWithInjectMethod.class).get();</span><br><span class="line"></span><br><span class="line">    assertTrue(instance.superCalled);</span><br><span class="line">    assertTrue(instance.subCalled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，测试不通过，父类的注入方法不会被调用，superCalled 为 false：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected :true</span><br><span class="line">Actual   :false</span><br></pre></td></tr></table></figure>

<p>原因是，获取方法注入点时，只获取了当前类的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Method&gt; <span class="title function_">getInjectMethods</span><span class="params">(Class&lt;T&gt; component)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(component.getDeclaredMethods())</span><br><span class="line">            .filter(m -&gt; m.isAnnotationPresent(Inject.class))</span><br><span class="line">            .toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于获取父类字段注入点的逻辑，通过递归找到父类注入方法的形式获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Method&gt; <span class="title function_">getInjectMethods</span><span class="params">(Class&lt;T&gt; component)</span> &#123;</span><br><span class="line">    Class&lt;T&gt; current = component;</span><br><span class="line">    List&lt;Method&gt; injectMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (current != Object.class) &#123;</span><br><span class="line">        injectMethods.addAll(Arrays.stream(current.getDeclaredMethods())</span><br><span class="line">                .filter(m -&gt; m.isAnnotationPresent(Inject.class))</span><br><span class="line">                .toList());</span><br><span class="line">        current = (Class&lt;T&gt;) current.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> injectMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子类注册时，先调用父类的注入点方法"><a href="#子类注册时，先调用父类的注入点方法" class="headerlink" title="子类注册时，先调用父类的注入点方法"></a>子类注册时，先调用父类的注入点方法</h3><p>在注册子类时，不仅要调用父类的注入点方法，而且需要让父类的注入点方法优先于子类的注入点方法调用</p>
<p>修改父子类的内部状态，通过数值确定调用的顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> override inject method from superclass</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SuperClassWithInjectMethod</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">superCalled</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">        superCalled = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SubclassWithInjectMethod</span> <span class="keyword">extends</span> <span class="title class_">SuperClassWithInjectMethod</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">subCalled</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">installAnother</span><span class="params">()</span> &#123;</span><br><span class="line">        subCalled = superCalled + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_inject_dependencies_via_inject_method_from_superclass</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(SubclassWithInjectMethod.class, SubclassWithInjectMethod.class);</span><br><span class="line">    <span class="type">SubclassWithInjectMethod</span> <span class="variable">instance</span> <span class="operator">=</span> config.getContext().get(SubclassWithInjectMethod.class).get();</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">1</span>, instance.superCalled);</span><br><span class="line">    assertEquals(<span class="number">2</span>, instance.subCalled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，测试不通过，说明子类先于父类执行注入点方法。</p>
<p>因为，子类的注入点方法是先于父类的注入点方法加入到方法列表的，这里最简单的实现就是将方法列表 reverse 倒序一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Method&gt; <span class="title function_">getInjectMethods</span><span class="params">(Class&lt;T&gt; component)</span> &#123;</span><br><span class="line">    Class&lt;T&gt; current = component;</span><br><span class="line">    List&lt;Method&gt; injectMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (current != Object.class) &#123;</span><br><span class="line">        injectMethods.addAll(Arrays.stream(current.getDeclaredMethods())</span><br><span class="line">                .filter(m -&gt; m.isAnnotationPresent(Inject.class))</span><br><span class="line">                .toList());</span><br><span class="line">        current = (Class&lt;T&gt;) current.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(injectMethods);</span><br><span class="line">    <span class="keyword">return</span> injectMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Override-注入点方法的情况"><a href="#Override-注入点方法的情况" class="headerlink" title="Override 注入点方法的情况"></a>Override 注入点方法的情况</h3><p>在 <code>@Inject</code> 的描述中，关于方法的注入有如下的限制：</p>
<blockquote>
<p>A method annotated with @Inject that overrides another method annotated with @Inject will only be injected once per injection request per instance. A method with no @Inject annotation that overrides a method annotated with @Inject will not be injected.</p>
<p>被 @Inject 注解的方法如果覆盖了另一个同样被 @Inject 注解的方法，则在每次实例的注入请求中只会被注入一次。没有 @Inject 注解的方法如果覆盖了一个被 @Inject 注解的方法，则不会被注入。</p>
<blockquote>
<p>说明：这里的调用一次是指只调用子类中的方法，不会调用父类的方法。</p>
</blockquote>
</blockquote>
<h4 id="子类覆盖的方法被-Inject-标注"><a href="#子类覆盖的方法被-Inject-标注" class="headerlink" title="子类覆盖的方法被 Inject 标注"></a>子类覆盖的方法被 Inject 标注</h4><p>修改测试的父类：</p>
<blockquote>
<p>更好的方法是子类和父类设置不同的值，使用++递增的话，不能很明确的知道是应该调用哪个方法。这里应该调用的是子类中的方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> override inject method from superclass</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SuperClassWithInjectMethod</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">superCalled</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">        superCalled++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造测试，验证父类的注入点方法被带有Inject方法覆盖时，父类的注入点方法不会被调用，只会调用一次子类的调用点方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SubclassWithOverrideInjectMethod</span> <span class="keyword">extends</span> <span class="title class_">SuperClassWithInjectMethod</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.install();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_only_call_once_if_subclass_override_superclass_inject_method_with_inject</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(SubclassWithOverrideInjectMethod.class, SubclassWithOverrideInjectMethod.class);</span><br><span class="line">    <span class="type">SubclassWithOverrideInjectMethod</span> <span class="variable">instance</span> <span class="operator">=</span> config.getContext().get(SubclassWithOverrideInjectMethod.class).get();</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">1</span>, instance.superCalled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现，在获取注入点方法时，需要判断如果父类的注入点方法被覆盖，那么可以将其过滤掉，即可以不用被调用。</p>
<p>因为这里是先找到子类的方法，所以可以从目前找到的方法中再判断是否有和当前类（父类）同名、同签名的方法（即覆盖的方法），有则过滤掉。</p>
<p><img src="/blogs/25729/image-20240813170732077.png" alt="image-20240813170732077"></p>
<h4 id="子类覆盖的方法未被-Inject-标注"><a href="#子类覆盖的方法未被-Inject-标注" class="headerlink" title="子类覆盖的方法未被 Inject 标注"></a>子类覆盖的方法未被 Inject 标注</h4><p>这里子类和父类的方法应该要都不会被调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SuperClassWithInjectMethod</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">superCalled</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">        superCalled++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SubclassWithOverrideInjectMethodWithoutInject</span> <span class="keyword">extends</span> <span class="title class_">SuperClassWithInjectMethod</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.install();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_only_call_once_if_subclass_override_superclass_inject_method_without_inject</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(SubclassWithOverrideInjectMethodWithoutInject.class, SubclassWithOverrideInjectMethodWithoutInject.class);</span><br><span class="line">    <span class="type">SubclassWithOverrideInjectMethodWithoutInject</span> <span class="variable">instance</span> <span class="operator">=</span> config.getContext().get(SubclassWithOverrideInjectMethodWithoutInject.class).get();</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">0</span>, instance.superCalled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试不通过，所以就是有一个被 Inject 标注的方法被加入到了注入点列表中。</p>
<blockquote>
<p>子类的方法中需要调用 super.install(); 应该是因为该方法被覆盖，调用时执行的是子类的方法。</p>
<p>所以要解决这个问题，还是要避免将父类的被 Inject 标注的方法加入的注入点方法列表。</p>
</blockquote>
<p>实现：</p>
<p><img src="/blogs/25729/image-20240813175302973.png" alt="image-20240813175302973"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Method&gt; <span class="title function_">getInjectMethods</span><span class="params">(Class&lt;T&gt; component)</span> &#123;</span><br><span class="line">    Class&lt;T&gt; current = component;</span><br><span class="line">    List&lt;Method&gt; injectMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (current != Object.class) &#123;</span><br><span class="line">        injectMethods.addAll(Arrays.stream(current.getDeclaredMethods())</span><br><span class="line">                .filter(m -&gt; m.isAnnotationPresent(Inject.class))</span><br><span class="line">                .filter(m -&gt; injectMethods.stream().noneMatch(im -&gt; im.getName().equals(m.getName()) &amp;&amp;</span><br><span class="line">                        Arrays.equals(im.getParameterTypes(), m.getParameterTypes())))</span><br><span class="line">                .filter(m -&gt; Arrays.stream(component.getDeclaredMethods())</span><br><span class="line">                        .filter(m1 -&gt; !m1.isAnnotationPresent(Inject.class))</span><br><span class="line">                        .noneMatch(m1 -&gt; m1.getName().equals(m.getName()) &amp;&amp;</span><br><span class="line">                                Arrays.equals(m1.getParameterTypes(), m.getParameterTypes())))</span><br><span class="line">                .toList());</span><br><span class="line">        current = (Class&lt;T&gt;) current.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(injectMethods);</span><br><span class="line">    <span class="keyword">return</span> injectMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Sad-Path"><a href="#Sad-Path" class="headerlink" title="Sad Path"></a>Sad Path</h1><p>目前，还剩下几个 sad path，完成这几个 sad path 那么注入部分就大体上完成了。</p>
<ul>
<li><p>如果注册的组件不可实例化，则抛出异常</p>
<ul>
<li><p>抽象类</p>
</li>
<li><p>接口</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> abstract class</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> interface</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字段注入<ul>
<li>如果字段为 final 则抛出异常</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> throw exception if filed is final</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方法注入<ul>
<li>如果方法定义类型参数，则抛出异常</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> throw exception if type parameter defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">在 Inject 的注释中有一个 do not declare type parameters of their own. 的注释，即不要在方法上声明类型参数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在Java中，类型参数（Type Parameter）是泛型编程的基础概念之一。它允许你在定义类或方法时使用一种占位类型的机制，这种占位类型可以在使用这些类或方法时具体化为实际的类型。类型参数通常用于实现泛型类、接口或方法，以便它们可以处理多种数据类型而不需要为每种类型重复代码。</p>
<p>类型参数通常用一个大写字母表示，如 <code>E</code>, <code>T</code>, <code>K</code> 等，但也可以使用任何有效的标识符。例如，在定义一个泛型类时，你可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line"> <span class="keyword">private</span> T item;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T item)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.item = item;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> item;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>T</code> 就是一个类型参数。当你创建 <code>Box</code> 类的实例时，你需要指定 <code>T</code> 的实际类型，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;(); <span class="comment">// T is String</span></span><br><span class="line">Box&lt;Integer&gt; intBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();   <span class="comment">// T is Integer</span></span><br></pre></td></tr></table></figure>

<p>这里，<code>T</code> 分别被具体化为 <code>String</code> 和 <code>Integer</code> 类型。</p>
<p>类型参数还可以有边界限制，这意味着你可以指定一个类型参数必须是某个特定类的子类或者实现某个特定接口。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这表示 <code>T</code> 必须实现 <code>Comparable</code> 接口。这样，你就可以在类内部安全地调用 <code>T</code> 的 <code>compareTo</code> 方法。</p>
</blockquote>
<h2 id="注册抽象类"><a href="#注册抽象类" class="headerlink" title="注册抽象类"></a>注册抽象类</h2><p>创建抽象类：</p>
<blockquote>
<p>这里使用构造器注入，其实这里不用实现 Component 也是可以的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractComponent</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_component_is_abstract</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalComponentException.class, () -&gt; <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(AbstractComponent.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现，创建 ConstructorInjectionProvider 时校验其是否为抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConstructorInjectionProvider</span><span class="params">(Class&lt;T&gt; component)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Modifier.isAbstract(component.getModifiers())) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.injectConstructor = getInjectConstructor(component);</span><br><span class="line">    <span class="built_in">this</span>.injectFields = getInjectFields(component);</span><br><span class="line">    <span class="built_in">this</span>.injectMethods = getInjectMethods(component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册接口"><a href="#注册接口" class="headerlink" title="注册接口"></a>注册接口</h2><p>不需要创建新类，直接可以注册 Component 接口</p>
<p>构造测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> interface</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_component_is_interface</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalComponentException.class, () -&gt; <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(Component.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，直接通过，因为接口的 Modifier 本身就是抽象的。</p>
<h2 id="字段注入时，字段为-final-时"><a href="#字段注入时，字段为-final-时" class="headerlink" title="字段注入时，字段为 final 时"></a>字段注入时，字段为 final 时</h2><p>新建测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FinalInjectField</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Dependency</span> <span class="variable">dependency</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_field_is_final</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalComponentException.class, () -&gt; <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(FinalInjectField.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现：</p>
<blockquote>
<p>可以在 getInjectFields 中检查并抛出异常，也可以在 ConstructorInjectionProvider 构造函数中检查并抛出异常，这里是在构造函数中检查。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConstructorInjectionProvider</span><span class="params">(Class&lt;T&gt; component)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Modifier.isAbstract(component.getModifiers())) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.injectConstructor = getInjectConstructor(component);</span><br><span class="line">        <span class="built_in">this</span>.injectFields = getInjectFields(component);</span><br><span class="line">        <span class="built_in">this</span>.injectMethods = getInjectMethods(component);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (injectFields.stream().anyMatch(f -&gt; Modifier.isFinal(f.getModifiers()))) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法定义类型参数"><a href="#方法定义类型参数" class="headerlink" title="方法定义类型参数"></a>方法定义类型参数</h2><p>新建类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InjectMethodWithTypeParameter</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    &lt;T&gt; <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_method_has_type_parameter</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalComponentException.class, () -&gt; <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(InjectMethodWithTypeParameter.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现：</p>
<p><img src="/blogs/25729/image-20240814102238573.png" alt="image-20240814102238573"></p>
<h1 id="重构测试代码"><a href="#重构测试代码" class="headerlink" title="重构测试代码"></a>重构测试代码</h1><p>目前，我们的测试是按照构造器注入、字段注入、方法注入的方式组织的。但是我们的生产代码的架构是有调整的。</p>
<p>这就造成了生产代码和测试之间存在一些不一致的情况。</p>
<p>也造成了随着TDD的进行，我们前后实现类似功能的测试会因为重构导致的生产代码的变化而变化，比如，在构造器注入中我们对依赖的检查是完整的端到端的功能测试，而经过重构后，我们后面的字段注入和方法注入都是更细粒度的测试。</p>
<blockquote>
<p>我们通过TDD的测试，可以还原整个开发流程，但是从结果上看，这并不意味着我们得到了最好的一整套测试用例。</p>
<p>所以我们就需要使用重构的方式，对我们的测试代码进行重构，以得到更好的组织形式的测试。</p>
<p>这才能保证，我们在TDD之后我们能得到结构优秀的代码，同时在测试中真实反映代码的意图，而不仅仅是单纯的展现我们实现功能的过程。</p>
</blockquote>
<blockquote>
<p>代码不仅仅是资产，也是负债。需要持续不断的维护。</p>
</blockquote>
<h2 id="删除不必要的测试"><a href="#删除不必要的测试" class="headerlink" title="删除不必要的测试"></a>删除不必要的测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dependencies not exist</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_dependency_not_found</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyNotFoundException</span> <span class="variable">exception</span> <span class="operator">=</span> assertThrows(DependencyNotFoundException.class, () -&gt; &#123;</span><br><span class="line">        config.getContext();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    assertEquals(Dependency.class, exception.getDependency());</span><br><span class="line">    assertEquals(Component.class, exception.getComponent());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_transitive_dependency_not_found</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line">    config.bind(Dependency.class, DependencyWithInjectConstructor.class); <span class="comment">// 缺失 String 类型的依赖</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyNotFoundException</span> <span class="variable">exception</span> <span class="operator">=</span> assertThrows(DependencyNotFoundException.class, () -&gt; &#123;</span><br><span class="line">        config.getContext();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    assertEquals(String.class, exception.getDependency());</span><br><span class="line">    assertEquals(Dependency.class, exception.getComponent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这两个依赖不存在的测试，后一个测试是没有必要的，因为在我们的生产代码进行重构后，对依赖的检查不在要求？？？？？</p>
<h2 id="移动部分测试到新的测试上下文"><a href="#移动部分测试到新的测试上下文" class="headerlink" title="移动部分测试到新的测试上下文"></a>移动部分测试到新的测试上下文</h2><p>对于一下三个对依赖进行检查的测试，目前在 ConstructorInjection 上下文中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dependencies not exist</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_dependency_not_found</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyNotFoundException</span> <span class="variable">exception</span> <span class="operator">=</span> assertThrows(DependencyNotFoundException.class, () -&gt; &#123;</span><br><span class="line">        config.getContext();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    assertEquals(Dependency.class, exception.getDependency());</span><br><span class="line">    assertEquals(Component.class, exception.getComponent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// cyclic dependencies</span></span><br><span class="line"><span class="meta">@Test</span> <span class="comment">// A -&gt; B -&gt; A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_cyclic_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line">    config.bind(Dependency.class, DependencyDependedOnComponent.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">CyclicDependenciesException</span> <span class="variable">exception</span> <span class="operator">=</span></span><br><span class="line">            assertThrows(CyclicDependenciesException.class, () -&gt; config.getContext());</span><br><span class="line"></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classes = Sets.newSet(exception.getComponents());</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">2</span>, classes.size());</span><br><span class="line">    assertTrue(classes.contains(Component.class));</span><br><span class="line">    assertTrue(classes.contains(Dependency.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span> <span class="comment">// A -&gt; B -&gt; C -&gt; A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_transitive_cyclic_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line">    config.bind(Dependency.class, DependencyDependedOnAnotherDependency.class);</span><br><span class="line">    config.bind(AnotherDependency.class, AnotherDependencyDependedOnComponent.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">CyclicDependenciesException</span> <span class="variable">exception</span> <span class="operator">=</span></span><br><span class="line">            assertThrows(CyclicDependenciesException.class, () -&gt; config.getContext());</span><br><span class="line"></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; components = Arrays.stream(exception.getComponents()).toList();</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">3</span>, components.size());</span><br><span class="line">    assertTrue(components.contains(Component.class));</span><br><span class="line">    assertTrue(components.contains(Dependency.class));</span><br><span class="line">    assertTrue(components.contains(AnotherDependency.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将这三个测试移动到一个新的上下文中，这个上下文要体现出我们的意图，这里我们定义一个名为 DependencyCheck 的测试上下文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nested</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyCheck</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将前文提到的三个测试移动到这个上下文中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nested</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyCheck</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dependencies not exist</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_dependency_not_found</span><span class="params">()</span> &#123;</span><br><span class="line">        config.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">DependencyNotFoundException</span> <span class="variable">exception</span> <span class="operator">=</span> assertThrows(DependencyNotFoundException.class, () -&gt; &#123;</span><br><span class="line">            config.getContext();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        assertEquals(Dependency.class, exception.getDependency());</span><br><span class="line">        assertEquals(Component.class, exception.getComponent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cyclic dependencies</span></span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">// A -&gt; B -&gt; A</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_cyclic_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">        config.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line">        config.bind(Dependency.class, DependencyDependedOnComponent.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">CyclicDependenciesException</span> <span class="variable">exception</span> <span class="operator">=</span></span><br><span class="line">                assertThrows(CyclicDependenciesException.class, () -&gt; config.getContext());</span><br><span class="line"></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = Sets.newSet(exception.getComponents());</span><br><span class="line"></span><br><span class="line">        assertEquals(<span class="number">2</span>, classes.size());</span><br><span class="line">        assertTrue(classes.contains(Component.class));</span><br><span class="line">        assertTrue(classes.contains(Dependency.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">// A -&gt; B -&gt; C -&gt; A</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_transitive_cyclic_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">        config.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line">        config.bind(Dependency.class, DependencyDependedOnAnotherDependency.class);</span><br><span class="line">        config.bind(AnotherDependency.class, AnotherDependencyDependedOnComponent.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">CyclicDependenciesException</span> <span class="variable">exception</span> <span class="operator">=</span></span><br><span class="line">                assertThrows(CyclicDependenciesException.class, () -&gt; config.getContext());</span><br><span class="line"></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; components = Arrays.stream(exception.getComponents()).toList();</span><br><span class="line"></span><br><span class="line">        assertEquals(<span class="number">3</span>, components.size());</span><br><span class="line">        assertTrue(components.contains(Component.class));</span><br><span class="line">        assertTrue(components.contains(Dependency.class));</span><br><span class="line">        assertTrue(components.contains(AnotherDependency.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重构-ConstructorInjection-上下文"><a href="#重构-ConstructorInjection-上下文" class="headerlink" title="重构 ConstructorInjection 上下文"></a>重构 ConstructorInjection 上下文</h2><p>以下的这两个方法，与当前的架构不一致，</p>
<p><img src="/blogs/25729/image-20240814114238683.png" alt="image-20240814114238683"></p>
<p>抽取出 getBind 方法，修改这两个方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sad path</span></span><br><span class="line"><span class="comment">// multi inject constructors</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_multi_inject_constructors_provided</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalComponentException.class, () -&gt; &#123;</span><br><span class="line">        getBind(ComponentWithMultiInjectConstructors.class);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getBind</span><span class="params">(Class&lt;? extends Component&gt; implementation)</span> &#123;</span><br><span class="line">    config.bind(Component.class, implementation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no default constructor and inject constructor</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_no_inject_constructor_nor_default_constructor_provided</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalComponentException.class, () -&gt; &#123;</span><br><span class="line">        getBind(ComponentWithNoInjectConstructorNorDefaultConstructor.class);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 getBind的实现修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getBind</span><span class="params">(Class&lt;? extends Component&gt; implementation)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(implementation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inline getBind 方法</p>
<blockquote>
<p>inline 后需要稍微调整一下，比如移除不必要的型转</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sad path</span></span><br><span class="line"><span class="comment">// multi inject constructors</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_multi_inject_constructors_provided</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalComponentException.class, () -&gt; <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(ComponentWithMultiInjectConstructors.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no default constructor and inject constructor</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_no_inject_constructor_nor_default_constructor_provided</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalComponentException.class, () -&gt; <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(ComponentWithNoInjectConstructorNorDefaultConstructor.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改之后，这几个测试就有了一样的结构：</p>
<p><img src="/blogs/25729/image-20240814115236417.png" alt="image-20240814115236417"></p>
<h2 id="在-ConstructorInjection-中增加对依赖校验的测试"><a href="#在-ConstructorInjection-中增加对依赖校验的测试" class="headerlink" title="在 ConstructorInjection 中增加对依赖校验的测试"></a>在 ConstructorInjection 中增加对依赖校验的测试</h2><p>增加这个测试为了统一与FieldInjection、MethodInjection测试上下文的测试组织形式，使得这几个测试上下文都保持一个一致的结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_include_dependency_from_inject_constructor</span><span class="params">()</span> &#123;</span><br><span class="line">    ConstructorInjectionProvider&lt;ComponentWithInjectConstructor&gt; provider =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(ComponentWithInjectConstructor.class);</span><br><span class="line"></span><br><span class="line">    assertArrayEquals(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;Dependency.class&#125;, provider.getDependencies().toArray(Class&lt;?&gt;[]::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建-InjectionTest-并移出-ContainerTest"><a href="#创建-InjectionTest-并移出-ContainerTest" class="headerlink" title="创建 InjectionTest 并移出 ContainerTest"></a>创建 InjectionTest 并移出 ContainerTest</h2><p>将关于注入的三个测试上下文，放入一个 InjectionTest 上下文中，用于后续将其移出 ContainerTest，以形成一个独立的测试类，减少ContainerTest 类中的代码数量，便于理解。</p>
<p><img src="/blogs/25729/Snipaste_2024-08-14_12-03-14.png" alt="Snipaste_2024-08-14_12-03-14"></p>
<p>因为当前上下文中，大量依赖 config，所以也需要将 setUp的代码移入 InjectionTest</p>
<p><img src="/blogs/25729/Snipaste_2024-08-14_13-43-13.png"></p>
<p>接着需要将 InjectionTest 移出 ContainerTest，这里对 InjectionTest 执行两次 Move Inner Class to Upper Level 重构，就可以将其从 ContainerTest 中移出：</p>
<p><img src="/blogs/25729/image-20240814134740365.png" alt="image-20240814134740365"></p>
<p>最终移出到测试目录的最顶层：</p>
<p><img src="/blogs/25729/image-20240814135151138.png" alt="image-20240814135151138"></p>
<h1 id="重构-InjectionTest"><a href="#重构-InjectionTest" class="headerlink" title="重构 InjectionTest"></a>重构 InjectionTest</h1><p>目前在 InjectionTest 的测试上下文中，存在不同的测试粒度</p>
<p><img src="/blogs/25729/image-20240814135657701.png" alt="image-20240814135657701"></p>
<p>在同一个测试上下文中，我们最好希望它们的测试粒度是一样的。</p>
<p>这里，我们就希望将对 config 粒度的功能测试，都能重构为对 ConstructorInjectionProvider 粒度的单元测试。</p>
<p>观察：</p>
<p><img src="/blogs/25729/image-20240814151410275.png" alt="image-20240814151410275"></p>
<p>对于 config 的测试都需要执行 <code>config.bind(XXX)</code> + <code>config.getContext().get(XXX).get()</code> 方法来获取一个组件，所以这里重构方向就是将 <code>config.getContext().get(XXX).get()</code> 方法，修改为通过创建 <code>ConstructorInjectionProvider</code> 的方式来获取一个组件。</p>
<p>先将 <code>config.bind(XXX)</code> + <code>config.getContext().get(XXX).get()</code>  提取为一个通用的方法。</p>
<p>第一步，因为需要支持很多类型，这里先提取参数：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-14_15-26-55.png" alt="Snipaste_2024-08-14_15-26-55"></p>
<p>再提取方法：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-14_15-28-06.png" alt="Snipaste_2024-08-14_15-28-06"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Component <span class="title function_">getComponent</span><span class="params">(Class&lt;Component&gt; type, Class&lt;ComponentWithDefaultConstructor&gt; implementation)</span> &#123;</span><br><span class="line">    config.bind(type, implementation);</span><br><span class="line">    <span class="type">Component</span> <span class="variable">instance</span> <span class="operator">=</span> config.getContext().get(type).get();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提取的方法的签名无法支持我们其他代码的类型，需要做一些范型调整：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T, I <span class="keyword">extends</span> <span class="title class_">T</span>&gt; T <span class="title function_">getComponent</span><span class="params">(Class&lt;T&gt; type, Class&lt;I&gt; implementation)</span> &#123;</span><br><span class="line">    config.bind(type, implementation);</span><br><span class="line">    <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> config.getContext().get(type).get();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将提取的参数先 inline 回去：</p>
<p><img src="/blogs/25729/image-20240814153437033.png" alt="image-20240814153437033"></p>
<p>inline 后，这段代码就会变成如下形式：</p>
<p><img src="/blogs/25729/image-20240814153602000.png" alt="image-20240814153602000"></p>
<p>观察其他测试代码，可以发现，有很多相似的代码，可以改为调用上一步提取出的 getComponent，比如：</p>
<p><img src="/blogs/25729/image-20240814153744147.png" alt="image-20240814153744147"></p>
<p><img src="/blogs/25729/image-20240814153851651.png" alt="image-20240814153851651"></p>
<p>接下来就是，逐步将这些代码替换为调用 getComponent 来获取组件。</p>
<p>替换完成后，我们还会发现，这些测试代码中很多都使用了一个 Dependency 实例：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-14_15-59-28.png" alt="Snipaste_2024-08-14_15-59-28"></p>
<p>可以将这个放到 setUp 中去：</p>
<p><img src="/blogs/25729/image-20240814160224365.png" alt="image-20240814160224365"></p>
<p>接着就可以逐个移除掉测试用例中的创建并bind dependecy 的代码。</p>
<p>接着，替换掉 getComponent中的实现，就可以通过 ConstructorInjectionProvider 返回一个实例，如下所示，只要 执行 provider.get 方法就可以返回实例，但是这里的问题是，该方法需要一个 context 容器作为参数：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-14_16-12-35.png" alt="Snipaste_2024-08-14_16-12-35"></p>
<p>可以通过测试替身的方式创建 context 容器，并且我们知道，provider 使用这个 context 是用来从容器中获取 provider 需要的依赖的，也就是 provider 需要调用 context 的 get 方法。并且当前 provider 需要的依赖类型就是 Dependency。</p>
<p>所以 setUp 可以是实现为：</p>
<p><img src="/blogs/25729/image-20240814162037571-1723623638469-6.png" alt="image-20240814162037571"></p>
<p>并把 getComponent 方法的实现修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T, I <span class="keyword">extends</span> <span class="title class_">T</span>&gt; T <span class="title function_">getComponent</span><span class="params">(Class&lt;T&gt; type, Class&lt;I&gt; implementation)</span> &#123;</span><br><span class="line">    ConstructorInjectionProvider&lt;I&gt; provider = <span class="keyword">new</span> <span class="title class_">ConstructorInjectionProvider</span>&lt;&gt;(implementation);</span><br><span class="line">    <span class="keyword">return</span> provider.get(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，也可为 Dependency 创建测试替身：</p>
<p><img src="/blogs/25729/image-20240814162619203.png" alt="image-20240814162619203"></p>
<p>如果下面的测试抛异常的话，需要修改一下测试替身的返回数据：</p>
<p><img src="/blogs/25729/image-20240814163326742.png" alt="image-20240814163326742"></p>
<p>接着，将 getComponent 方法 inline 一下：</p>
<p><img src="/blogs/25729/image-20240814163812035.png" alt="image-20240814163812035"></p>
<p>至此，原来使用 config 获取实例的方法，都变成了使用 ConstructorInjectionProvider 来获取实例。也就是说我们绝大多数的测试的粒度都调整到了 ConstructorInjectionProvider 之上。</p>
<p>现在，只剩下一个地方在使用 config ：</p>
<p><img src="/blogs/25729/image-20240814164435758.png" alt="image-20240814164435758"></p>
<p>稍微调整一下这个测试，我们会发现，把 config 删掉也不会有什么影响：</p>
<p><img src="/blogs/25729/image-20240814165056094.png" alt="image-20240814165056094"></p>
<p>同样的，现在 setUp 中的 config 也没什么用了：</p>
<p><img src="/blogs/25729/image-20240814165358387.png" alt="image-20240814165358387"></p>
<p>删掉 config 后，测试依然通过。就此，config 就与我们的测试上下文彻底无关了。</p>
<blockquote>
<p>另外呢，还可以将在 ContainerTest 中定义的类也移动到 InjectionTest中，或在 InjectionTest 中重新定义并使用在这个测试上下文中使用的类。</p>
<p>比如说 ComponentWithDefaultConstructor 只在 InjectionTest 中被使用，但是却是在 ContainerTest 定义，好的做法是将其移动到 InjectionTest 中，但是这里最好还是重新定义一个新的类（不必实现任何接口），因为这个 ComponentWithDefaultConstructor 还实现了 Component 接口。这个需要自己去实现。</p>
</blockquote>
<blockquote>
<p>另外，以下的这两个测试其实功能是一样的，下面的测试可以删掉</p>
<p><img src="/blogs/25729/image-20240814170235565.png" alt="image-20240814170235565"></p>
</blockquote>
<h1 id="测试文档化"><a href="#测试文档化" class="headerlink" title="测试文档化"></a>测试文档化</h1><p>我们说测试应该是文档，但是文档不应该是我们实现的过程，因为在TDD中测试就是实现过程中的里程碑。</p>
<blockquote>
<p>对于TDD来说，测试天然并不是文档，测试是实现过程中的里程碑（或记录）。需要将测试变为文档是需要经过很多努力的。</p>
<p>只有在这个过程中间我们将我们需要知识和需要表达的内容进行足够的提取和刻意地组织，才能使测试变成一个文档。</p>
</blockquote>
<blockquote>
<p>因为TDD的测试主要是一种里程碑，帮助我们驱动开发的，它并不是真的站在软件测试的角度上去写的。</p>
<blockquote>
<p>开发人员所写的测试，和测试人员所希望看到的测试的类型其实是不同的。测试人员更多的是关注测试的完备性、对条件的覆盖。这两种测试之间是存在鸿沟的，需要刻意的调整和梳理。</p>
</blockquote>
<p>一旦我们把TDD测试的功能写完，其实我们可以通过扩展（不能讲是重构了），把它 Convert 成一个更接近于测试需要的测试。</p>
<p>因为这个时候测试的骨架已经形成，我们只需要把它变成参数化或是数据驱动的方式去做，使测试可以覆盖更大范围的场景。</p>
</blockquote>
<p>对测试进行分类分组、保持一致的命名，使其更加文档化。</p>
<h2 id="文档化-InjectionTest"><a href="#文档化-InjectionTest" class="headerlink" title="文档化 InjectionTest"></a>文档化 InjectionTest</h2><h3 id="统一命名"><a href="#统一命名" class="headerlink" title="统一命名"></a>统一命名</h3><p>统一测试命名，使其更加文档化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">should_bind_type_to_a_class_with_default_constructor</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">should_call_default_constructor_if_no_inject_constructor</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为 bind 是针对 config 描述的测试</p>
</blockquote>
<p>再一个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">should_bind_type_to_a_class_with_inject_constructor</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">should_inject_dependency_via_inject_constructor</span><br></pre></td></tr></table></figure>

<h3 id="细化分组"><a href="#细化分组" class="headerlink" title="细化分组"></a>细化分组</h3><p>将 ConstructorInjection、FieldInjection、MethodInjection 分别再按 Injection 和 IllegalInjectXXX 进行分组。</p>
<blockquote>
<p>具体的结果，请查看 commit id 为 a9590a2a 的 commit 记录。</p>
</blockquote>
<p><img src="/blogs/25729/image-20240814175622797.png" alt="image-20240814175622797"></p>
<p>当然，视情况，还可以进行更细一步的分组。</p>
<h2 id="文档化-ContainerTest"><a href="#文档化-ContainerTest" class="headerlink" title="文档化 ContainerTest"></a>文档化 ContainerTest</h2><p>目前 ContainerTest 中还剩下的测试有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">ContextConfig config;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">    config = <span class="keyword">new</span> <span class="title class_">ContextConfig</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件构造相 关的测试类</span></span><br><span class="line"><span class="meta">@Nested</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentConstruction</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// instance</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_bind_type_to_a_specific_instance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个实现了 Component 接口的匿名内部类实例</span></span><br><span class="line">        <span class="type">Component</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Component</span>() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">        config.bind(Component.class, instance);</span><br><span class="line"></span><br><span class="line">        assertSame(instance, config.getContext().get(Component.class).get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// component does not exist</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_return_empty_if_component_not_defined</span><span class="params">()</span> &#123;</span><br><span class="line">        Optional&lt;Component&gt; component = config.getContext().get(Component.class);</span><br><span class="line">        assertTrue(component.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyCheck</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dependencies not exist</span></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_dependency_not_found</span><span class="params">()</span> &#123;</span><br><span class="line">            config.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line"></span><br><span class="line">            <span class="type">DependencyNotFoundException</span> <span class="variable">exception</span> <span class="operator">=</span> assertThrows(DependencyNotFoundException.class, () -&gt; &#123;</span><br><span class="line">                config.getContext();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            assertEquals(Dependency.class, exception.getDependency());</span><br><span class="line">            assertEquals(Component.class, exception.getComponent());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// cyclic dependencies</span></span><br><span class="line">        <span class="meta">@Test</span> <span class="comment">// A -&gt; B -&gt; A</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_cyclic_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">            config.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line">            config.bind(Dependency.class, DependencyDependedOnComponent.class);</span><br><span class="line"></span><br><span class="line">            <span class="type">CyclicDependenciesException</span> <span class="variable">exception</span> <span class="operator">=</span></span><br><span class="line">                    assertThrows(CyclicDependenciesException.class, () -&gt; config.getContext());</span><br><span class="line"></span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; classes = Sets.newSet(exception.getComponents());</span><br><span class="line"></span><br><span class="line">            assertEquals(<span class="number">2</span>, classes.size());</span><br><span class="line">            assertTrue(classes.contains(Component.class));</span><br><span class="line">            assertTrue(classes.contains(Dependency.class));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Test</span> <span class="comment">// A -&gt; B -&gt; C -&gt; A</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_transitive_cyclic_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">            config.bind(Component.class, ComponentWithInjectConstructor.class);</span><br><span class="line">            config.bind(Dependency.class, DependencyDependedOnAnotherDependency.class);</span><br><span class="line">            config.bind(AnotherDependency.class, AnotherDependencyDependedOnComponent.class);</span><br><span class="line"></span><br><span class="line">            <span class="type">CyclicDependenciesException</span> <span class="variable">exception</span> <span class="operator">=</span></span><br><span class="line">                    assertThrows(CyclicDependenciesException.class, () -&gt; config.getContext());</span><br><span class="line"></span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; components = Arrays.stream(exception.getComponents()).toList();</span><br><span class="line"></span><br><span class="line">            assertEquals(<span class="number">3</span>, components.size());</span><br><span class="line">            assertTrue(components.contains(Component.class));</span><br><span class="line">            assertTrue(components.contains(Dependency.class));</span><br><span class="line">            assertTrue(components.contains(AnotherDependency.class));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些测试都是在 Context 上下文之上的测试，我们也可以将这些测试移动到一个独立的测试类中，比如 ContextTest 中。</p>
<p>参考 DependencyCheck 的测试分组，这里也可以将前两个测试归类到一个名为 TypeBinding 的分类中：</p>
<p><img src="/blogs/25729/image-20240815115724375.png" alt="image-20240815115724375"></p>
<p>将</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">should_return_empty_if_component_not_defined</span><br></pre></td></tr></table></figure>

<p>改名为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">should_retrieve_empty_for_unbind_type</span><br></pre></td></tr></table></figure>

<h3 id="TypeBinding-注入方式参数化"><a href="#TypeBinding-注入方式参数化" class="headerlink" title="TypeBinding 注入方式参数化"></a>TypeBinding 注入方式参数化</h3><p>在 TypeBinding 分类中增加一个测试，并且使用参数化，将一个测试泛化为多个测试，分别测试根据：构造器注入、字段注入和方法注入的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个测试泛化为多个测试，分别测试根据：构造器注入、字段注入和方法注入的情况</span></span><br><span class="line"><span class="meta">@ParameterizedTest(name = &quot;supporting &#123;0&#125;&quot;)</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_bind_type_to_an_injectable_component</span><span class="params">(Class&lt;? extends Component&gt; componentType)</span> &#123;</span><br><span class="line">    <span class="type">Dependency</span> <span class="variable">dependency</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dependency</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    config.bind(Dependency.class, dependency);</span><br><span class="line">    config.bind(Component.class, componentType); <span class="comment">// 参数化测试不同的注入方式</span></span><br><span class="line"></span><br><span class="line">    Optional&lt;Component&gt; component = config.getContext().get(Component.class);</span><br><span class="line"></span><br><span class="line">    assertTrue(component.isPresent());</span><br><span class="line">    assertSame(dependency, component.get().dependency());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Arguments&gt; <span class="title function_">should_bind_type_to_an_injectable_component</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(</span><br><span class="line">            Arguments.of(Named.of(<span class="string">&quot;Constructor Injection&quot;</span>, TypeBinding.ConstructorInjection.class)),</span><br><span class="line">            Arguments.of(Named.of(<span class="string">&quot;Field Injection&quot;</span>, TypeBinding.FieldInjection.class)),</span><br><span class="line">            Arguments.of(Named.of(<span class="string">&quot;Method Injection&quot;</span>, TypeBinding.MethodInjection.class))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConstructorInjection</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Dependency dependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstructorInjection</span><span class="params">(Dependency dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dependency <span class="title function_">dependency</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FieldInjection</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Dependency dependency; <span class="comment">// 目前不支持注入私有字段</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dependency <span class="title function_">dependency</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MethodInjection</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Dependency dependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(Dependency dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dependency <span class="title function_">dependency</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，需要修改一下 Component 的定义，增加默认方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">    <span class="keyword">default</span> Dependency <span class="title function_">dependency</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DependencyCheck-参数化"><a href="#DependencyCheck-参数化" class="headerlink" title="DependencyCheck 参数化"></a>DependencyCheck 参数化</h3><p>同理将 DependencyCheck 中的三个测试分别参数化。</p>
<h4 id="依赖缺失"><a href="#依赖缺失" class="headerlink" title="依赖缺失"></a>依赖缺失</h4><p>测试三种不同的注入方式是否满足依赖缺失的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dependencies not exist</span></span><br><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_dependency_not_found</span><span class="params">(Class&lt;? extends Component&gt; componentType)</span> &#123;</span><br><span class="line">    config.bind(Component.class, componentType);</span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyNotFoundException</span> <span class="variable">exception</span> <span class="operator">=</span> assertThrows(DependencyNotFoundException.class, () -&gt; &#123;</span><br><span class="line">        config.getContext();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    assertEquals(Dependency.class, exception.getDependency());</span><br><span class="line">    assertEquals(Component.class, exception.getComponent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Arguments&gt; <span class="title function_">should_throw_exception_if_dependency_not_found</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(</span><br><span class="line">            Arguments.of(Named.of(<span class="string">&quot;Constructor Injection&quot;</span>, DependencyCheck.MissingDependencyConstructor.class)),</span><br><span class="line">            Arguments.of(Named.of(<span class="string">&quot;Field Injection&quot;</span>, DependencyCheck.MissingDependencyField.class)),</span><br><span class="line">            Arguments.of(Named.of(<span class="string">&quot;Method Injection&quot;</span>, DependencyCheck.MissingDependencyMethod.class))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MissingDependencyConstructor</span> <span class="keyword">implements</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MissingDependencyConstructor</span><span class="params">(Dependency dependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MissingDependencyField</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Dependency dependency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MissingDependencyMethod</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(Dependency dependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blogs/25729/image-20240815135153837.png" alt="image-20240815135153837"></p>
<h4 id="直接循环依赖-1"><a href="#直接循环依赖-1" class="headerlink" title="直接循环依赖"></a>直接循环依赖</h4><p>测试不同的注入方式的组合是否满足循环依赖的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cyclic dependencies</span></span><br><span class="line"><span class="comment">// A -&gt; B -&gt; A</span></span><br><span class="line"><span class="meta">@ParameterizedTest(name = &quot;cyclic dependency between &#123;0&#125; and &#123;1&#125;&quot;)</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_cyclic_dependencies</span><span class="params">(Class&lt;? extends Component&gt; componentType,</span></span><br><span class="line"><span class="params">                                                          Class&lt;? extends Dependency&gt; dependencyType)</span> &#123;</span><br><span class="line">    config.bind(Component.class, componentType);</span><br><span class="line">    config.bind(Dependency.class, dependencyType);</span><br><span class="line"></span><br><span class="line">    <span class="type">CyclicDependenciesException</span> <span class="variable">exception</span> <span class="operator">=</span></span><br><span class="line">            assertThrows(CyclicDependenciesException.class, () -&gt; config.getContext());</span><br><span class="line"></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classes = Sets.newSet(exception.getComponents());</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">2</span>, classes.size());</span><br><span class="line">    assertTrue(classes.contains(Component.class));</span><br><span class="line">    assertTrue(classes.contains(Dependency.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Arguments&gt; <span class="title function_">should_throw_exception_if_cyclic_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Arguments&gt; arguments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Named component : List.of(Named.of(<span class="string">&quot;Constructor Injection&quot;</span>, DependencyCheck.CyclicComponentInjectConstructor.class),</span><br><span class="line">            Named.of(<span class="string">&quot;Field Injection&quot;</span>, DependencyCheck.CyclicComponentInjectField.class),</span><br><span class="line">            Named.of(<span class="string">&quot;Method Injection&quot;</span>, DependencyCheck.CyclicComponentInjectMethod.class))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Named dependency : List.of(Named.of(<span class="string">&quot;Constructor Injection&quot;</span>, DependencyCheck.CyclicDependencyInjectConstructor.class),</span><br><span class="line">                Named.of(<span class="string">&quot;Field Injection&quot;</span>, DependencyCheck.CyclicDependencyInjectField.class),</span><br><span class="line">                Named.of(<span class="string">&quot;Method Injection&quot;</span>, DependencyCheck.CyclicDependencyInjectMethod.class))) &#123;</span><br><span class="line">            arguments.add(Arguments.of(component, dependency));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arguments.stream();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicComponentInjectConstructor</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CyclicComponentInjectConstructor</span><span class="params">(Dependency dependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicComponentInjectField</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Dependency dependency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicComponentInjectMethod</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(Dependency dependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicDependencyInjectConstructor</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CyclicDependencyInjectConstructor</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicDependencyInjectField</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Component component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicDependencyInjectMethod</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blogs/25729/image-20240815135326871.png" alt="image-20240815135326871"></p>
<h4 id="间接循环依赖"><a href="#间接循环依赖" class="headerlink" title="间接循环依赖"></a>间接循环依赖</h4><p>测试不同的注入方式的组合是否能满足间接循环依赖的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A -&gt; B -&gt; C -&gt; A</span></span><br><span class="line"><span class="meta">@ParameterizedTest(name = &quot;transitive cyclic dependency between &#123;0&#125;, &#123;1&#125; and &#123;2&#125;&quot;)</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_transitive_cyclic_dependencies</span><span class="params">(Class&lt;? extends Component&gt; componentType,</span></span><br><span class="line"><span class="params">                                                                    Class&lt;? extends Dependency&gt; dependencyType,</span></span><br><span class="line"><span class="params">                                                                    Class&lt;? extends AnotherDependency&gt; anotherDependencyType)</span> &#123;</span><br><span class="line">    config.bind(Component.class, componentType);</span><br><span class="line">    config.bind(Dependency.class, dependencyType);</span><br><span class="line">    config.bind(AnotherDependency.class, anotherDependencyType);</span><br><span class="line"></span><br><span class="line">    <span class="type">CyclicDependenciesException</span> <span class="variable">exception</span> <span class="operator">=</span></span><br><span class="line">            assertThrows(CyclicDependenciesException.class, () -&gt; config.getContext());</span><br><span class="line"></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; components = Arrays.stream(exception.getComponents()).toList();</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">3</span>, components.size());</span><br><span class="line">    assertTrue(components.contains(Component.class));</span><br><span class="line">    assertTrue(components.contains(Dependency.class));</span><br><span class="line">    assertTrue(components.contains(AnotherDependency.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Arguments&gt; <span class="title function_">should_throw_exception_if_transitive_cyclic_dependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Arguments&gt; arguments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Named component : List.of(Named.of(<span class="string">&quot;Constructor Injection&quot;</span>, DependencyCheck.CyclicComponentInjectConstructor.class),</span><br><span class="line">            Named.of(<span class="string">&quot;Field Injection&quot;</span>, DependencyCheck.CyclicComponentInjectField.class),</span><br><span class="line">            Named.of(<span class="string">&quot;Method Injection&quot;</span>, DependencyCheck.CyclicComponentInjectMethod.class))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Named dependency : List.of(Named.of(<span class="string">&quot;Constructor Injection&quot;</span>, DependencyCheck.CyclicDependencyInjectConstructorWithAnotherDependency.class),</span><br><span class="line">                Named.of(<span class="string">&quot;Field Injection&quot;</span>, DependencyCheck.CyclicDependencyInjectFieldWithAnotherDependency.class),</span><br><span class="line">                Named.of(<span class="string">&quot;Method Injection&quot;</span>, DependencyCheck.CyclicDependencyInjectMethodWithAnotherDependency.class))) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Named anotherDependency : List.of(Named.of(<span class="string">&quot;Constructor Injection&quot;</span>, DependencyCheck.CyclicDependencyInjectConstructorWithComponent.class),</span><br><span class="line">                    Named.of(<span class="string">&quot;Field Injection&quot;</span>, DependencyCheck.CyclicDependencyInjectFieldWithComponent.class),</span><br><span class="line">                    Named.of(<span class="string">&quot;Method Injection&quot;</span>, DependencyCheck.CyclicDependencyInjectMethodWithComponent.class))) &#123;</span><br><span class="line">                arguments.add(Arguments.of(component, dependency, anotherDependency));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arguments.stream();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicDependencyInjectConstructorWithAnotherDependency</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CyclicDependencyInjectConstructorWithAnotherDependency</span><span class="params">(AnotherDependency anotherDependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicDependencyInjectFieldWithAnotherDependency</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    AnotherDependency anotherDependency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicDependencyInjectMethodWithAnotherDependency</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(AnotherDependency anotherDependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicDependencyInjectConstructorWithComponent</span> <span class="keyword">implements</span> <span class="title class_">AnotherDependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CyclicDependencyInjectConstructorWithComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicDependencyInjectFieldWithComponent</span> <span class="keyword">implements</span> <span class="title class_">AnotherDependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Component component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicDependencyInjectMethodWithComponent</span> <span class="keyword">implements</span> <span class="title class_">AnotherDependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blogs/25729/image-20240815135441506.png" alt="image-20240815135441506"></p>
<h2 id="移动-ContainerTest-中的部分测试用例类"><a href="#移动-ContainerTest-中的部分测试用例类" class="headerlink" title="移动 ContainerTest 中的部分测试用例类"></a>移动 ContainerTest 中的部分测试用例类</h2><p>ContainerTest 中的部分测试用例类现在只会在 InjectionTest 中使用，应该使用 Move Class 方法重构，将这些类移动到 InjectionTest 中。</p>
<p><img src="/blogs/25729/image-20240815140852626.png" alt="image-20240815140852626"></p>
<p>整理好之后，测试目录的代码结构如下所示：</p>
<p><img src="/blogs/25729/image-20240815141206661.png" alt="image-20240815141206661"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这里的 ContextTest 中的测试更接近于 API，所以也适合参数化进而更加文档化。</p>
<blockquote>
<p>对于TDD来说，测试天然并不是文档，测试是实现过程中的里程碑（或记录）。需要将测试变为文档是需要经过很多努力的。</p>
<p>只有在这个过程中间我们将我们需要知识和需要表达的内容进行足够的提取和刻意地组织，才能使测试变成一个文档。</p>
</blockquote>
<blockquote>
<p>因为TDD的测试主要是一种里程碑，帮助我们驱动开发的，它并不是真的站在软件测试的角度上去写的。</p>
<blockquote>
<p>开发人员所写的测试，和测试人员所希望看到的测试的类型其实是不同的。测试人员更多的是关注测试的完备性、对条件的覆盖。这两种测试之间是存在鸿沟的，需要刻意的调整和梳理。</p>
</blockquote>
<p>一旦我们把TDD测试的功能写完，其实我们可以通过扩展（不能讲是重构了），把它 Convert 成一个更接近于测试需要的测试。</p>
<p>因为这个时候测试的骨架已经形成，我们只需要把它变成参数化或是数据驱动的方式去做，就可以使测试覆盖更大范围的场景。</p>
</blockquote>
<h1 id="重构生产代码"><a href="#重构生产代码" class="headerlink" title="重构生产代码"></a>重构生产代码</h1><p>目前，我们的生产代码主要集中在 ContextConfig 和 ConstructorInjectionProvider 中。</p>
<h2 id="重构-ContextConfig"><a href="#重构-ContextConfig" class="headerlink" title="重构 ContextConfig"></a>重构 ContextConfig</h2><p>这两个类里面的功能不多，如果非要重构的话</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ComponentProvider</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; getDependencies();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ComponentProvider</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> List&lt;Class&lt;?&gt;&gt; getDependencies() &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将其改为一个函数式的接口，即将 getDependencies 方法定义为接口的默认方法。</p>
<p>那么就可以将下面的代码改写为使用lambda：</p>
<p><img src="/blogs/25729/image-20240814190544963.png" alt="image-20240814190544963"></p>
<p><img src="/blogs/25729/image-20240814190717435.png" alt="image-20240814190717435"></p>
<h2 id="重构-ConstructorInjectionProvider"><a href="#重构-ConstructorInjectionProvider" class="headerlink" title="重构 ConstructorInjectionProvider"></a>重构 ConstructorInjectionProvider</h2><p>首先，重命名 ConstructorInjectionProvider 的名字，因为现在不仅仅是关于构造器的注入，而是所有的 Injection 都在里面。</p>
<p>重命名为 InjectionProvider</p>
<p>其他问题就是易读性比较差，并且还有一些重复。</p>
<p>很多地方都需要判断是否被 <code>Inject</code>注解标记，这里有比较多的重复代码：</p>
<p><img src="/blogs/25729/image-20240814193426209.png" alt="image-20240814193426209"></p>
<p>先提取方法：</p>
<p><img src="/blogs/25729/image-20240814193907824.png" alt="image-20240814193907824"></p>
<p>因为不止是用在 Field，还需要支持构造函数、方法注入等场景的判断，就需要将这个方法修改为支持范型的方法。</p>
<p>因为 isAnnotationPresent 方法是在一个接口（公共的基类）上定义的：</p>
<p><img src="/blogs/25729/image-20240814194214679.png" alt="image-20240814194214679"></p>
<p>这里就可以把这个范型转换为 AnnotatedElement，那么这个方法的定义就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">AnnotatedElement</span>&gt; Stream&lt;T&gt; <span class="title function_">injectable</span><span class="params">(T[] declaredFields)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(declaredFields)</span><br><span class="line">            .filter(f -&gt; f.isAnnotationPresent(Inject.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，使用这个函数替换掉判断被Inject标注的构造函数、字段和方法的代码。</p>
<p>提取判断子类覆盖父类的方法：</p>
<p><img src="/blogs/25729/image-20240814195736380.png" alt="image-20240814195736380"></p>
<p>提取方法，判断子父类方法都被Inject标注</p>
<p><img src="/blogs/25729/image-20240814200226834.png" alt="image-20240814200226834"></p>
<p>提取方法，判断子类没有被 Inject 标注</p>
<p><img src="/blogs/25729/image-20240814200548328.png" alt="image-20240814200548328"></p>
<p>稍微调整一下，可以得到相似的代码：</p>
<p><img src="/blogs/25729/image-20240814202044074.png" alt="image-20240814202044074"></p>
<p>提取方法：</p>
<p><img src="/blogs/25729/image-20240814202352826.png" alt="image-20240814202352826"></p>
<p>同样的为了支持Method，需要范型化，而Method 和 Contructor 具有同一个基类 Executable：</p>
<p><img src="/blogs/25729/image-20240814201633717.png" alt="image-20240814201633717"></p>
<p><img src="/blogs/25729/image-20240814201652190.png" alt="image-20240814201652190"></p>
<p>所以，将提取的方法修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; Object[] toDependencies(Context context, Executable executable) &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(executable.getParameterTypes())</span><br><span class="line">            .map(t -&gt; context.get(t).get()).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 Method 的方法：</p>
<p><img src="/blogs/25729/image-20240814202727618.png" alt="image-20240814202727618"></p>
<p>将 getArray inline 一下可以实现替换，inline 掉一些方法和变量后，变为：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-14_20-30-15.png" alt="Snipaste_2024-08-14_20-30-15"></p>
<p>为了使这块代码看上去更一致，也可以将 Feild 获取依赖的代码提取为方法：</p>
<p><img src="/blogs/25729/image-20240814203236723.png" alt="image-20240814203236723"></p>
<p>提取方法，用函数名表达含义，起到了注释的作用，下面的这段代码是用于获取默认构造函数的：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-14_20-35-47.png" alt="Snipaste_2024-08-14_20-35-47"></p>
<p><img src="/blogs/25729/Snipaste_2024-08-14_20-38-27.png" alt="Snipaste_2024-08-14_20-38-27"></p>
<p>结构类似的方法，如何优化？</p>
<p>以下的两个方法结构非常类似，只是实现不同</p>
<p><img src="/blogs/25729/image-20240814204107708.png" alt="image-20240814204107708"></p>
<p>把中间的地方变成一个算法，通过Lambda，把要变化的部分传进去。</p>
<p>先把中间变化的部分提取为方法：</p>
<p><img src="/blogs/25729/image-20240814205149449.png" alt="image-20240814205149449"></p>
<p>先修改 getInjectFields 方法：</p>
<blockquote>
<p>其中使用一个 function 来引用 getList 方法</p>
</blockquote>
<p><img src="/blogs/25729/image-20240814212142865.png" alt="image-20240814212142865"></p>
<p>同样的，在 getInjectMethods 方法中也用一个 function 来间接引用 getList 方法</p>
<p><img src="/blogs/25729/image-20240814212502434.png" alt="image-20240814212502434"></p>
<p>接着，我们可以发现，getInjectMethods 和 getInjectFields 的代码几乎是一样的，除了部分变量的范型不同。</p>
<p><img src="/blogs/25729/image-20240814212621229.png" alt="image-20240814212621229"></p>
<p>如果，我们将这两段都提取成一个同名方法，你会发现这两个方法是一样的，除了范型不一样。后续我们希望做到的就是将这两个方法重构为一个方法。</p>
<blockquote>
<p>仅范型不一样，所以会报错。这里需要先给其中一个方法改为不同的名字。这里先把报红的方法名修改为 traverse1</p>
</blockquote>
<p><img src="/blogs/25729/image-20240814213050948.png" alt="image-20240814213050948"></p>
<p>接着，修改其中一个方法的签名，也满足两个方法的要求。这里修改 traverse。</p>
<p>将 component 的类型从 <code>Class&lt;T&gt;</code> 修改为  <code>Class&lt;?&gt;</code>，然后使用范型参数 T 来支持同时接收 Field 和 Method 的参数，并将 injectFields 变量重命名为更加中性的 members ，并将 function 重命名为含义更丰富的 finder</p>
<p><img src="/blogs/25729/image-20240815093415791.png" alt="image-20240815093415791"></p>
<p>使用 traverse 替换掉 traverse1 的调用。之后就可以将 traverse1 删掉。</p>
<p>稍微调整，并并通过 inline 重构下面的代码，让其变得更加简洁点：</p>
<p><img src="/blogs/25729/image-20240815095344716.png" alt="image-20240815095344716"></p>
<p>其中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(injectConstructor.getParameters()).map(Parameter::getType);</span><br></pre></td></tr></table></figure>

<p>可以修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(injectConstructor.getParameterTypes());</span><br></pre></td></tr></table></figure>

<p> 另外</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.collect(Collectors.toList())</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.toList()</span><br></pre></td></tr></table></figure>

<p>再 inline 这些变量：</p>
<p><img src="/blogs/25729/image-20240815095814592.png" alt="image-20240815095814592"></p>
<h1 id="增加新功能-支持注入Provider"><a href="#增加新功能-支持注入Provider" class="headerlink" title="增加新功能-支持注入Provider"></a>增加新功能-支持注入Provider</h1><p>截至到目前为止，我们实现的功能基本上和2003年左右的DI注入容器的功能是差不多的。</p>
<blockquote>
<p>2003年的 <a target="_blank" rel="noopener" href="http://picocontainer.com/introduction.html">PicoContainer</a> 就基本上和我们当前的功能差不多，Spring 的话还多了更多的对 Configuration 的支持。</p>
</blockquote>
<p>接下来需要增加依赖选择相关的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖选择相关的测试类</span></span><br><span class="line"><span class="meta">@Nested</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependenciesSelection</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderType</span> &#123;</span><br><span class="line">        <span class="comment">// Context</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> could get Provider&lt;T&gt; from context</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// InjectionProvider</span></span><br><span class="line">        <span class="comment">// TODO：support inject constructor</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> support inject field</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> support inject method</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Qualifier</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据任务所属不同的上下文，可以将这些任务列表放到不同的测试中。</p>
<p>将</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> could get Provider&lt;T&gt; from context</span></span><br></pre></td></tr></table></figure>

<p>放到 ContextTest 中的 TypeBinding 中</p>
<p>将</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InjectionProvider</span></span><br><span class="line"><span class="comment">// TODO：support inject constructor</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> support inject field</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> support inject method</span></span><br></pre></td></tr></table></figure>

<p>分别放到 InjectionTest 中的 ConstructorInjection、FieldInjection、MethodInjection 中。</p>
<h2 id="从-Context-中获取-Provider"><a href="#从-Context-中获取-Provider" class="headerlink" title="从 Context 中获取 Provider"></a>从 Context 中获取 Provider</h2><blockquote>
<p>实现从 Context 中获取 Provider 的功能，是为了后续实现注入 Provider 的功能。</p>
<p>作用：</p>
<p>DI（Dependency Injection，依赖注入）容器中的 <code>Provider</code> 模式是一种常见的设计模式，用于延迟实例化依赖项。使用 <code>Provider</code> 注入有以下几个主要用途：</p>
<h3 id="1-延迟实例化"><a href="#1-延迟实例化" class="headerlink" title="1. 延迟实例化"></a>1. 延迟实例化</h3><p><code>Provider</code> 允许你在<strong>运行时</strong>决定何时创建依赖项的实例。这对于那些耗时较长的初始化过程或资源密集型对象非常有用。例如，如果你有一个数据库连接池，你可能不希望在应用程序启动时就创建所有的连接，而是等到真正需要的时候再创建。</p>
<h3 id="2-控制依赖的生命周期"><a href="#2-控制依赖的生命周期" class="headerlink" title="2. 控制依赖的生命周期"></a>2. 控制依赖的生命周期</h3><p>通过 <code>Provider</code>，你可以控制依赖项的生命周期。例如，你可以配置一个 <code>Provider</code> 使得每次请求都创建一个新的实例（即每次都需要一个全新的对象），或者复用同一个实例（单例模式）。这有助于管理内存使用和资源分配。</p>
<h3 id="3-测试友好"><a href="#3-测试友好" class="headerlink" title="3. 测试友好"></a>3. 测试友好</h3><p><code>Provider</code> 使测试变得更加容易。在单元测试或集成测试中，你可以轻松地为依赖项提供不同的实现或模拟对象，而不必修改生产代码。</p>
<h3 id="4-动态配置"><a href="#4-动态配置" class="headerlink" title="4. 动态配置"></a>4. 动态配置</h3><p>使用 <code>Provider</code> 可以让你在运行时根据不同的配置或环境动态地改变依赖项的行为。例如，在开发环境中使用本地数据库，而在生产环境中使用远程数据库。</p>
<h3 id="5-解耦"><a href="#5-解耦" class="headerlink" title="5. 解耦"></a>5. 解耦</h3><p><code>Provider</code> 的使用有助于降低代码之间的耦合度。依赖项的创建逻辑与业务逻辑分离，使得代码更易于维护和扩展。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设你有一个 <code>UserService</code> 类，它依赖于一个 <code>DatabaseConnection</code> 对象。你可以使用 <code>Provider</code> 来管理这个依赖关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DatabaseConnection</span> &#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Provider&lt;DatabaseConnection&gt; dbConnectionProvider;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(Provider&lt;DatabaseConnection&gt; dbConnectionProvider)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.dbConnectionProvider = dbConnectionProvider;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performOperation</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">DatabaseConnection</span> <span class="variable">connection</span> <span class="operator">=</span> dbConnectionProvider.get();</span><br><span class="line">     connection.connect();</span><br><span class="line">     <span class="comment">// 执行业务逻辑</span></span><br><span class="line">     connection.disconnect();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>UserService</code> 依赖于一个 <code>DatabaseConnection</code> 的 <code>Provider</code>。每当需要连接到数据库时，<code>UserService</code> 就会调用 <code>dbConnectionProvider.get()</code> 来获取一个新的连接。这使得 <code>UserService</code> 可以灵活地处理连接的创建和关闭，同时也简化了单元测试的实现。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>使用 <code>Provider</code> 注入可以提高代码的灵活性和可测试性，同时还能有效地管理依赖项的生命周期。这在大型应用中特别有用，因为它可以帮助减少内存消耗和提高性能。</p>
</blockquote>
<p>我们预期的功能大致如下所示，即希望能从 Context 中获取指定类型的 Provider，但是目前 Java 的范型不支持这种语法。</p>
<blockquote>
<p>Provider 是：jakarta.inject.Provider</p>
</blockquote>
<p><img src="/blogs/25729/image-20240815144345057.png" alt="image-20240815144345057"></p>
<p>要想实现这个功能，需要先定义一个范型的包装类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TypeLiteral</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> ParameterizedType <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (ParameterizedType) ((ParameterizedType)(getClass().getGenericSuperclass()))</span><br><span class="line">            .getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ParameterizedType</code> 是 Java 泛型类型的一种表示形式，用于描述带有类型参数的类型（例如 <code>List&lt;String&gt;</code>）</p>
</blockquote>
<p>如何使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Disabled</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">java_api</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Component</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">ParameterizedType</span> <span class="variable">type</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeLiteral</span>&lt;Provider&lt;Component&gt;&gt;() &#123;&#125;.getType();</span><br><span class="line"></span><br><span class="line">    assertEquals(Provider.class, type.getRawType());</span><br><span class="line">    assertEquals(Component.class, type.getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以测试，应该如下：</p>
<p><img src="/blogs/25729/image-20240815155136365.png" alt="image-20240815155136365"></p>
<p>在 Context 接口中创建这个 get 方法：</p>
<p><img src="/blogs/25729/image-20240815155834612.png" alt="image-20240815155834612"></p>
<p>接着在 ContextConfig 中快速实现这个方法，使编译通过：</p>
<p><img src="/blogs/25729/image-20240815160013631.png" alt="image-20240815160013631"></p>
<p>现在运行测试，是无法通过的。</p>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Optional <span class="title function_">get</span><span class="params">(ParameterizedType type)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; componentType = (Class&lt;?&gt;)type.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(providers.get(componentType))</span><br><span class="line">            .map(provider -&gt; (Provider&lt;Object&gt;) () -&gt; provider.get(<span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>.map(provider -&gt; (Provider&lt;Object&gt;) () -&gt; provider.get(this))</code>: 如果 <code>providers.get(componentType)</code> 不为 <code>null</code>，那么这里会将找到的提供者转换为一个新的 <code>Provider&lt;Object&gt;</code> 实例。这个 lambda 表达式创建了一个新的函数，当被调用时，它通过调用原始提供者的 <code>get</code> 方法来获取一个对象实例。注意这里进行了类型转换 <code>(Provider&lt;Object&gt;)</code>，这表示期望的结果是一个能够提供 <code>Object</code> 类型的提供者。</p>
</blockquote>
<p>sad path</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_not_retrieve_provider_bind_type_as_unsupported_container</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Component</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    config.bind(Component.class, component);</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> config.getContext();</span><br><span class="line"></span><br><span class="line">    <span class="type">ParameterizedType</span> <span class="variable">type</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeLiteral</span>&lt;List&lt;Component&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line"></span><br><span class="line">    assertFalse(context.get(type).isPresent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Optional <span class="title function_">get</span><span class="params">(ParameterizedType type)</span> &#123;</span><br><span class="line">    <span class="comment">// 直接校验范型类型是否为 Provider</span></span><br><span class="line">    <span class="keyword">if</span> (type.getRawType() != Provider.class) <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    Class&lt;?&gt; componentType = (Class&lt;?&gt;)type.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(providers.get(componentType))</span><br><span class="line">            .map(provider -&gt; (Provider&lt;Object&gt;) () -&gt; provider.get(<span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="support-provider-inject-constructor"><a href="#support-provider-inject-constructor" class="headerlink" title="support provider inject constructor"></a>support provider inject constructor</h2><p>构造测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO：support inject constructor</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ProviderInjectConstructor</span> &#123;</span><br><span class="line">    Provider&lt;Dependency&gt; dependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProviderInjectConstructor</span><span class="params">(Provider&lt;Dependency&gt; dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_inject_provider_via_inject_constructor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProviderInjectConstructor</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(ProviderInjectConstructor.class).get(context);</span><br><span class="line"></span><br><span class="line">    assertNotNull(instance.dependency);</span><br><span class="line">    assertSame(dependencyProvider, instance.dependency);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 InjectionTest 是使用测试替身来进行测试的，所以这里同时还要设置测试替身和 setUp：</p>
<p><img src="/blogs/25729/image-20240815170531302.png" alt="image-20240815170531302"></p>
<p>运行测试会在 InjectionProvider 中报异常：</p>
<p><img src="/blogs/25729/image-20240815170616411.png" alt="image-20240815170616411"></p>
<blockquote>
<p>因为这里只能按 Class 的类型获取实例</p>
</blockquote>
<p>需要修改为：</p>
<blockquote>
<p>同时至此 Class 和 ParameterizedType 类型</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; Object[] toDependencies(Context context, Executable executable) &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(executable.getParameters()).map(</span><br><span class="line">            p -&gt; &#123;</span><br><span class="line">                <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> p.getParameterizedType();</span><br><span class="line">                <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) <span class="keyword">return</span> context.get((ParameterizedType) type).get();</span><br><span class="line">                <span class="keyword">return</span> context.get((Class&lt;?&gt;) type).get();</span><br><span class="line">            &#125;).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，通过。</p>
<h2 id="support-provider-inject-method"><a href="#support-provider-inject-method" class="headerlink" title="support provider inject method"></a>support provider inject method</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> support inject method</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ProviderInjectMethod</span> &#123;</span><br><span class="line">    Provider&lt;Dependency&gt; dependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(Provider&lt;Dependency&gt; dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_inject_provider_via_inject_method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProviderInjectMethod</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(ProviderInjectMethod.class).get(context);</span><br><span class="line"></span><br><span class="line">    assertNotNull(instance.dependency);</span><br><span class="line">    assertSame(dependencyProvider, instance.dependency);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，直接通过。</p>
<h2 id="support-provider-inject-field"><a href="#support-provider-inject-field" class="headerlink" title="support provider inject field"></a>support provider inject field</h2><p>构建测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// support provider inject field</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ProviderInjectField</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Provider&lt;Dependency&gt; dependency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_inject_provider_via_inject_field</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProviderInjectField</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(ProviderInjectField.class).get(context);</span><br><span class="line"></span><br><span class="line">    assertNotNull(instance.dependency);</span><br><span class="line">    assertSame(dependencyProvider, instance.dependency);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，以下代码会报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">toDependency</span><span class="params">(Context context, Field field)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> context.get(field.getType()).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样是查找依赖的代码异常，修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">toDependency</span><span class="params">(Context context, Field field)</span> &#123;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> field.getGenericType();</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) <span class="keyword">return</span> context.get((ParameterizedType) type).get();</span><br><span class="line">    <span class="keyword">return</span> context.get(field.getType()).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="遗漏的任务-Provider-依赖的检查"><a href="#遗漏的任务-Provider-依赖的检查" class="headerlink" title="遗漏的任务-Provider 依赖的检查"></a>遗漏的任务-Provider 依赖的检查</h1><p>同理，注入 Provider 时也需要检查依赖缺失、循环依赖的情况。</p>
<p>目前，对依赖的检查需要调用 getDependencies 接口，而这里的 getDependencies 接口依然返回的是 Class 类型。我们从容器中寻找依赖时，目前分为两种情况，分别是 Class 和 ，所以这里对依赖缺失或循环依赖的检查可能会出现问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ComponentProvider</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> List&lt;Class&lt;?&gt;&gt; getDependencies() &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以依赖缺失为例，在 ContextTest 中增加测试用例，增加一个参数值：</p>
<p><img src="/blogs/25729/image-20240816093648383.png" alt="image-20240816093648383"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MissingDependencyProviderConstructor</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MissingDependencyProviderConstructor</span><span class="params">(Provider&lt;Dependency&gt; dependency)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行，会有一个异常：</p>
<p><img src="/blogs/25729/image-20240816093851722.png" alt="image-20240816093851722"></p>
<p>我们期望提示是 Dependency 未找到，而不是 Provider 未找到，或者关于谁的 Provider 未找到，因为当我要求修正错误的时候，也不会去 bind 一个 Provider，而是 bind 一个 Dependency。</p>
<p>在回看 getDependencies 方法，我们期望这里能返回 Class 和 ParameterizedType 的公共接口，即 Type 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ComponentProvider</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> List&lt;Class&lt;?&gt;&gt; getDependencies() &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不能直接修改，需要使用先增加新功能再替换旧功能的方式重构，以下就是预取我们要实现的方式，使用 getDependencyTypes 替换掉 getDependencies：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ComponentProvider</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> List&lt;Class&lt;?&gt;&gt; getDependencies() &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> List&lt;Type&gt; <span class="title function_">getDependencyTypes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充两个测试用例：</p>
<p><img src="/blogs/25729/image-20240816101405554.png" alt="image-20240816101405554"></p>
<p>将这两个测试用例转换为实际的任务测试:</p>
<p>分别在 ConstructorInjection、FieldInjection、MethodInjection 中的 Injection 中增加以下测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO：should include dependency type from inject constructor</span></span><br><span class="line"><span class="comment">// TODO：should include dependency type from inject field</span></span><br><span class="line"><span class="comment">// TODO：should include dependency type from inject method</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为修改涉及的步骤比较长，先注释掉测试用例：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-16_10-26-52.png" alt="Snipaste_2024-08-16_10-26-52"></p>
</blockquote>
<p>获取构造器中的依赖的测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO：should include dependency type from inject constructor</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_include_dependency_type_from_inject_constructor</span><span class="params">()</span> &#123;</span><br><span class="line">    InjectionProvider&lt;ProviderInjectConstructor&gt; provider =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(ProviderInjectConstructor.class);</span><br><span class="line"></span><br><span class="line">    assertArrayEquals(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;dependencyProviderType&#125;, provider.getDependencyTypes().toArray(Type[]::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考前面的 getDependencies 方法，该方法并不检查依赖缺失和循环依赖，但是该方法保证了后续检查的正确性。</p>
<p>所以这里的 getDependencyTypes 也是同理。</p>
</blockquote>
<p>实现，在 InjectionProvider 中实现这个 getDependencyTypes 方法，与 getDependencies 类似：</p>
<p><img src="/blogs/25729/image-20240816110219942.png" alt="image-20240816110219942"></p>
<p>同理，构造字段注入时获取 Provider 依赖类型的测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO：should include dependency type from inject field</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_include_provider_dependency_type_from_inject_field</span><span class="params">()</span> &#123;</span><br><span class="line">    InjectionProvider&lt;ProviderInjectField&gt; provider =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(ProviderInjectField.class);</span><br><span class="line"></span><br><span class="line">    assertArrayEquals(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;dependencyProviderType&#125;, provider.getDependencyTypes().toArray(Type[]::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现：</p>
<p><img src="/blogs/25729/image-20240816111741157.png" alt="image-20240816111741157"></p>
<p>同理，构造方法注入时获取 Provider 依赖类型的测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO：should include dependency type from inject method</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_include_provider_dependency_type_from_inject_method</span><span class="params">()</span> &#123;</span><br><span class="line">    InjectionProvider&lt;ProviderInjectMethod&gt; provider = <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(ProviderInjectMethod.class);</span><br><span class="line"></span><br><span class="line">    assertArrayEquals(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;dependencyProviderType&#125;, provider.getDependencyTypes().toArray(Type[]::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现：</p>
<p><img src="/blogs/25729/image-20240816112722818.png" alt="image-20240816112722818"></p>
<p>完成 getDependencyTypes 后，就是要使用 getDependencyTypes 来完成依赖缺失的检查。</p>
<h2 id="Provider-检查依赖缺失"><a href="#Provider-检查依赖缺失" class="headerlink" title="Provider 检查依赖缺失"></a>Provider 检查依赖缺失</h2><p>恢复，ContextTest 依赖缺失中的测试用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MissingDependencyProviderConstructor</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MissingDependencyProviderConstructor</span><span class="params">(Provider&lt;Dependency&gt; dependency)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blogs/25729/Snipaste_2024-08-16_11-30-20.png" alt="Snipaste_2024-08-16_11-30-20"></p>
<p>我们知道，目前检查依赖，并且使用了 getDependencies 方法的地方是 ContextConfig 中的 checkDependencies 方法，这里我们希望将使用 getDependencies 改为使用 getDependencyTypes</p>
<p><img src="/blogs/25729/image-20240816113629005.png" alt="image-20240816113629005"></p>
<p>先提取方法：</p>
<p><img src="/blogs/25729/image-20240816113543754.png" alt="image-20240816113543754"></p>
<p>使用 Type 替换 Class&lt;?&gt; 并且属于 Class 类型的逻辑依然保持不变：</p>
<p><img src="/blogs/25729/image-20240816114253710.png" alt="image-20240816114253710"></p>
<p>被 Provider 包装的类型，需要获取到被包装的依赖的类型，并传递给 DependencyNotFoundException</p>
<p><img src="/blogs/25729/image-20240816114722694.png" alt="image-20240816114722694"></p>
<p>目前我们仅实现了对依赖缺失的检查，并没有实现循环依赖的检查（实际上引入 Provider 就解除了循环依赖）。</p>
<p>同理，在 ContextTest 中增加字段注入、方法注入时检查依赖缺失的测试用例。</p>
<blockquote>
<p>虽然我们已经知道这两个测试会通过，但是还是需要增加这两个测试用例，因为 ContextTest 测试的是比较对外的 API，需要完善测试文档化的诉求。</p>
</blockquote>
<p><img src="/blogs/25729/image-20240816115431932.png" alt="image-20240816115431932"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MissingDependencyProviderField</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Provider&lt;Dependency&gt; dependency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MissingDependencyProviderMethod</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(Provider&lt;Dependency&gt; dependency)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，直接通过，不用修改生产代码。</p>
<h2 id="Provider-检查循环依赖"><a href="#Provider-检查循环依赖" class="headerlink" title="Provider 检查循环依赖"></a>Provider 检查循环依赖</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicDependencyProviderInjectConstructor</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CyclicDependencyProviderInjectConstructor</span><span class="params">(Provider&lt;Component&gt; component)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_not_throw_exception_if_cyclic_dependencies_with_provider</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(Component.class, CyclicComponentInjectConstructor.class);</span><br><span class="line">    config.bind(Dependency.class, CyclicDependencyProviderInjectConstructor.class);</span><br><span class="line"></span><br><span class="line">    assertTrue(config.getContext().get(Component.class).isPresent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 CyclicComponentInjectConstructor 已经存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicComponentInjectConstructor</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CyclicComponentInjectConstructor</span><span class="params">(Dependency dependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的依赖关系是：<code>Compontent.class</code> -&gt; <code>Dependency.class</code> -&gt; <code>Provider&lt;Compontent&gt;</code></p>
<p>因为 <code>Provider&lt;Compontent&gt;</code> 在 <code>config.bind(Component.class, CyclicComponentInjectConstructor.class);</code> 时就已经创建，所以这里的依赖循环就解除了。</p>
<p>同理 <code>Provider&lt;Compontent&gt;</code> -&gt; <code>Provider&lt;Dependency&gt;</code> -&gt; <code>Provider&lt;Compontent&gt;</code> 也是如此，引入 Provider 后依赖的循环就解除了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicComponentProviderInjectConstructor</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CyclicComponentProviderInjectConstructor</span><span class="params">(Provider&lt;Dependency&gt; dependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_not_throw_exception_if_cyclic_dependencies_with_providers</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(Component.class, CyclicComponentProviderInjectConstructor.class);</span><br><span class="line">    config.bind(Dependency.class, CyclicDependencyProviderInjectConstructor.class);</span><br><span class="line"></span><br><span class="line">    assertTrue(config.getContext().get(Component.class).isPresent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="重构-5"><a href="#重构-5" class="headerlink" title="重构"></a>重构</h1><p>获取依赖时的重复代码：</p>
<p><img src="/blogs/25729/image-20240816142714821.png" alt="image-20240816142714821"></p>
<p>先修改一下，修改后就完全一样了，可以使用提取方法的重构。</p>
<p><img src="/blogs/25729/image-20240816142854828.png" alt="image-20240816142854828"></p>
<p>提取方法后：</p>
<p><img src="/blogs/25729/image-20240816143124700.png" alt="image-20240816143124700"></p>
<p>提取后，然后也可以有选择的 inline 掉部分代码，简化代码。</p>
<p>观察 ComponentProvider 中的 getDependencies 发现，这个方法只在测试中用到。</p>
<p><img src="/blogs/25729/image-20240816143615349.png" alt="image-20240816143615349"></p>
<p>我们将测试中的调用替换为 getDependencyTypes 发现也没有什么问题。因为 getDependencyTypes 返回的 Type 是 Class 的父接口。</p>
<p>所以可以把这所有 getDependencies 的调用修改为调用 getDependencyTypes，之后可以删除 getDependencies。</p>
<p>同时，将 Class 类型替换为 Type：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-16_14-44-20.png" alt="Snipaste_2024-08-16_14-44-20"></p>
<h2 id="重构对-Type-类型的判断"><a href="#重构对-Type-类型的判断" class="headerlink" title="重构对 Type 类型的判断"></a>重构对 Type 类型的判断</h2><p>目前 Context 中有两个接口，分别支持不同的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    &lt;Type&gt; Optional&lt;Type&gt; <span class="title function_">get</span><span class="params">(Class&lt;Type&gt; type)</span>;</span><br><span class="line"></span><br><span class="line">    Optional <span class="title function_">get</span><span class="params">(ParameterizedType type)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了支持这两种不同的类型，需要在两个类中的代码的各处做不同的判断，多个 if – else</p>
<p><img src="/blogs/25729/image-20240816145441076.png" alt="image-20240816145441076"></p>
<p><img src="/blogs/25729/image-20240816145519993.png" alt="image-20240816145519993"></p>
<p>那么当需要对这种结构的类型做修改的话，很可能就会发生<strong>散弹式修改</strong>。</p>
<blockquote>
<p>很多时候，我们对代码不是很满意，但是又不知道如何下手修改。</p>
<p>这个时候可以考虑将相关功能的散落在各处的坏味道的代码集中到同一个上下文中。</p>
</blockquote>
<p>比如说，InjectionProvider 中的 toDependency 方法是根据类型判断调用 Context 接口中的哪个方法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">toDependency</span><span class="params">(Context context, Type type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) <span class="keyword">return</span> context.get((ParameterizedType) type).get();</span><br><span class="line">    <span class="keyword">return</span> context.get((Class&lt;?&gt;) type).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么可以将这个实现移动到 Context 接口的默认方法中去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    &lt;Type&gt; Optional&lt;Type&gt; <span class="title function_">get</span><span class="params">(Class&lt;Type&gt; type)</span>;</span><br><span class="line"></span><br><span class="line">    Optional <span class="title function_">get</span><span class="params">(ParameterizedType type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Optional <span class="title function_">getType</span><span class="params">(Type type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) <span class="keyword">return</span> get((ParameterizedType) type);</span><br><span class="line">        <span class="keyword">return</span> get((Class&lt;?&gt;) type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那 toDependency 就可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">toDependency</span><span class="params">(Context context, Type type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> context.getType(type).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，会有异常，这是在 InjectionTest 使用测试替身引起的，我们之前的测试替身是调用的是 Context 的 get 方法，但是修改代码后调用的是 Context 的 getType 方法，所以需要同步修改测试替身，修改为调用 getType 方法。</p>
<p><img src="/blogs/25729/image-20240816151832369.png" alt="image-20240816151832369"></p>
<blockquote>
<p>用测试替身还是用真实的待测组件？</p>
<p>当你接口约定稳定的时候，那么用 stub 会更简单。所以测试替身需要知道待测组件内部的实现，当内部实现修改时，可能造成测试失败。所以这种使用测试替身的伦敦学派测试，对重构的影响比较大。</p>
</blockquote>
<p>之后在 ContextConfig 中实现这个方法，就可以将接口的默认方法恢复为未实现的普通方法：	</p>
<p><img src="/blogs/25729/image-20240816152614060.png" alt="image-20240816152614060"></p>
<p>至此，我们就将对这两类型的判断相关的代码，都移动到了 ContextConfig 这个上下文中。</p>
<p>再然后，查看一下还有哪里在使用 Context 的 get 接口，可以发现，除了 ContextConfig 中使用外，就是在测试方法中使用。</p>
<p>我们把这些测试中使用 get 的地方都改成 getType，也不会异常。</p>
<p>那么 get 方法就只在 ContextConfig 中被使用了，这样就可以把 Context 接口中的 get 方法移除掉，并移除到 ContextConfig 中的 Override 注解并且设置为 private，只保留一个 getType 方法作为对外的API：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-16_15-43-32.png" alt="Snipaste_2024-08-16_15-43-32"></p>
<p>再将 getType 重命名为 get。</p>
<p>至此，我们就实现了使用一个接口替换为原来的两个接口的效果。</p>
<p>继续重构，先使用函数来代替注释</p>
<p><img src="/blogs/25729/Snipaste_2024-08-16_15-53-25.png" alt="Snipaste_2024-08-16_15-53-25"></p>
<blockquote>
<p>这里的 ContainerType 的含义是比如：List&lt;&gt;、Provider&lt;&gt; 这些容器。</p>
</blockquote>
<p>重命名方法：</p>
<p><img src="/blogs/25729/image-20240816160853947.png" alt="image-20240816160853947"></p>
<p>提取方法</p>
<p><img src="/blogs/25729/Snipaste_2024-08-16_16-09-16.png" alt="Snipaste_2024-08-16_16-09-16"></p>
<p>在修改一下提取的方法的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getComponentType(Type type) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Class&lt;?&gt;) ((ParameterizedType)type).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再修改一下 checkDependencies 中的代码：</p>
<p><img src="/blogs/25729/image-20240816161944872.png" alt="image-20240816161944872"></p>
<p>至此我们会发现，整个 ContextConfig 就是围绕两个不同的 Type 来做判断，并实现功能的。</p>
<p>出现这种情况的话，通常都意味着封装失败。造成这种情况都是因为我们使用了一些我们无法修改，无法增加行为的类和接口（可能是由其他框架或库提供的，也可能是JDK中的）。</p>
<blockquote>
<p>在实践中，有些时候不要使用原始类型（Primitive Type），并不是指不使用 int 而是使用 Integer，而是说所有我们无法修改的类都是原始类型。</p>
</blockquote>
<h2 id="封装-Type-类型的判断逻辑"><a href="#封装-Type-类型的判断逻辑" class="headerlink" title="封装 Type 类型的判断逻辑"></a>封装 Type 类型的判断逻辑</h2><p>因为我们使用的是原始类型，在我们的上下文中代表某个概念。这种概念一般会有概念缺失（Concept Missing）。</p>
<p>不仅仅是在代码层面上重构，其实是要从模型的角度上重构。正是因为使用了这种内容缺失的概念，以至于每次使用到这种概念的时候，需要对它进行复杂的判断。</p>
<p>对于这种概念缺失的优化呢，就是使用封装，一般有两种封装方式，分别是：行为封装、数据封装。</p>
<p>？？？？</p>
<p>这里使用数据封装</p>
<p>对代码进行稍微的整理，会发现，这些对 Type 进行判断的代码中，都会包含 componentType 或 ContainerType 或两者同时包含。</p>
<p><img src="/blogs/25729/image-20240816172206505.png" alt="image-20240816172206505"></p>
<p>新建一个封装类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Ref</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Type container;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; component;</span><br><span class="line"></span><br><span class="line">    Ref(ParameterizedType type) &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = type.getRawType();</span><br><span class="line">        <span class="built_in">this</span>.component = (Class&lt;?&gt;) type.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Ref(Class&lt;?&gt; component) &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Ref <span class="title function_">of</span><span class="params">(Type type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ref</span>((ParameterizedType) type);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ref</span>((Class&lt;?&gt;) type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Type <span class="title function_">getContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getComponent() &#123;</span><br><span class="line">        <span class="keyword">return</span> component;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着就可以使用 Ref 来代替 type 的表示。</p>
<p><img src="/blogs/25729/image-20240816172730553.png" alt="image-20240816172730553"></p>
<p>这两个方法，只有在 Context 的 get 方法中被调用，因为使用了 Ref 代替了两种不同的类型，所以不需要分两个方法进行判断了，这里先 inline 这个两个方法。</p>
<p>inline 并整理一下代码后，得到下面的代码结构：</p>
<p><img src="/blogs/25729/image-20240816173312128.png" alt="image-20240816173312128"></p>
<p>其中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isContainerType(type)) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>的判断，我们应该把其作为 Ref 的知识，封装到 Ref 中，在 Ref 新增 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isContainer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> container != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个判断语句就可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ref.isContainer())</span><br></pre></td></tr></table></figure>



<p>同理，使用 Ref 代替 checkXXXDependencies 中的 type 引用：</p>
<p><img src="/blogs/25729/image-20240816174437894.png" alt="image-20240816174437894"></p>
<p>inline 这两个方法，inline 并调整简化代码后，变成如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkDependencies</span><span class="params">(Class&lt;?&gt; component, Stack&lt;Class&lt;?&gt;&gt; visiting)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Type dependency : providers.get(component).getDependencyTypes()) &#123;</span><br><span class="line">        <span class="type">Ref</span> <span class="variable">ref</span> <span class="operator">=</span> Ref.of(dependency);</span><br><span class="line">        <span class="comment">// 如果依赖的类型不存在，就提前停止递归</span></span><br><span class="line">        <span class="keyword">if</span> (!providers.containsKey(ref.getComponent())) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DependencyNotFoundException</span>(component, ref.getComponent());</span><br><span class="line">        <span class="keyword">if</span> (!ref.isContainer()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visiting.contains(ref.getComponent())) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CyclicDependenciesException</span>(visiting);</span><br><span class="line">            visiting.push(ref.getComponent());</span><br><span class="line">            checkDependencies(ref.getComponent(), visiting);</span><br><span class="line">            visiting.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除代码：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-16_17-56-56.png" alt="Snipaste_2024-08-16_17-56-56"></p>
<p>将 Ref 从内部类中移出。</p>
<h2 id="Context-使用-Ref-对外提供访问"><a href="#Context-使用-Ref-对外提供访问" class="headerlink" title="Context 使用 Ref 对外提供访问"></a>Context 使用 Ref 对外提供访问</h2><p>我们希望在 Context接口中，使用 Ref 代替 Type：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    Optional <span class="title function_">get</span><span class="params">(Type type)</span>;</span><br><span class="line"></span><br><span class="line">    Optional <span class="title function_">get</span><span class="params">(Ref ref)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽取 get 方法，并Override</p>
<p><img src="/blogs/25729/image-20240817094941953.png" alt="image-20240817094941953"></p>
<p>这里也可以将 get(Type type) 方法改为default</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> Optional <span class="title function_">get</span><span class="params">(Type type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(Ref.of(type));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional <span class="title function_">get</span><span class="params">(Ref ref)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 Ref 移入 Context 中。</p>
<p>尝试直接inline <code>Optional get(Type type)</code>方法。</p>
<p>inline 后，使用测试替身的地方又会报错，原因是：inline 后 eq 的位置是错误的，需要人工修改一下</p>
<p><img src="/blogs/25729/image-20240817100143695.png" alt="image-20240817100143695"></p>
<p>修改为：</p>
<p><img src="/blogs/25729/image-20240817100436322.png" alt="image-20240817100436322"></p>
<p>此外还需要在 Ref 中增加 equals 和 hashCode方法。</p>
<p>至此，对 Context 的访问都是通过 Ref 参数访问。</p>
<p>接着，需要将 ComponentProvider 中的 getDependencyTypes 方法修改为返回 List<Ref></Ref></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ComponentProvider</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> List&lt;Type&gt; <span class="title function_">getDependencyTypes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，也需要新增，再替换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ComponentProvider</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> List&lt;Type&gt; <span class="title function_">getDependencyTypes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> List&lt;Context.Ref&gt; getDependencies() &#123;</span><br><span class="line">        <span class="keyword">return</span> getDependencyTypes().stream().map(Context.Ref::of).toList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 getDependencyTypes 在哪里被使用，并尝试人工替换</p>
<p><img src="/blogs/25729/image-20240817101707744.png" alt="image-20240817101707744"></p>
<p>修改测试中的使用，把所有的使用修改为类似以下形式：</p>
<p><img src="/blogs/25729/image-20240817102416259.png" alt="image-20240817102416259"></p>
<p>接着就是要将旧的 <code>List&lt;Type&gt; getDependencyTypes()</code> 移出掉。</p>
<p>实现 getDependencies 方法</p>
<p><img src="/blogs/25729/image-20240817103155965.png" alt="image-20240817103155965"></p>
<p>inline 并删除 getDependencyTypes 实现</p>
<p><img src="/blogs/25729/image-20240817103405954.png" alt="image-20240817103405954"></p>
<p>getDependencies 还是要保留默认实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ComponentProvider</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> List&lt;Context.Ref&gt; getDependencies() &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何让接口-API-变得更友好"><a href="#如何让接口-API-变得更友好" class="headerlink" title="如何让接口 API 变得更友好"></a>如何让接口 API 变得更友好</h2><p>目前的 API 功能都是正确的，但是从使用者的角度看就并不友好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"></span><br><span class="line">    Optional <span class="title function_">get</span><span class="params">(Ref ref)</span>;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 Context 中 get 方法的入参和返回值都是不带范型的。</p>
<p>那么有些时候，就还需要使用者自己来做型转</p>
<p><img src="/blogs/25729/image-20240817110150540.png" alt="image-20240817110150540"></p>
<p>增加范型支持：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-17_11-10-00.png" alt="Snipaste_2024-08-17_11-10-00"></p>
<p>那么这个时候再 get 时，就能直接指示类型</p>
<p><img src="/blogs/25729/image-20240817111102232.png" alt="image-20240817111102232"></p>
<blockquote>
<p>因为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Component&gt; component1 = Component.class;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>现在就让 API 变得更容易，减少不必要的型转。</p>
<blockquote>
<p>在 get 方法中增加对范型的支持</p>
<p><img src="/blogs/25729/image-20240819105209273.png" alt="image-20240819105209273"></p>
</blockquote>
<p>上面的范型是对Class&lt;?&gt;的参数提供的支持，那么如何支持ContainerType的情况呢？</p>
<p>目前支持 ContainerType 的参数的方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Ref <span class="title function_">of</span><span class="params">(Type type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ref</span>((ParameterizedType) type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ref</span>((Class&lt;?&gt;) type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且在使用时，还需要用自定义的 <code>TypeLiteral</code> 包装一下：</p>
<p><img src="/blogs/25729/image-20240817112312997.png" alt="image-20240817112312997"></p>
<p>一个可能的方法是，将 Ref 和 TypeLiteral 做一个整合，以达到类似如下的使用效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.get(<span class="keyword">new</span> <span class="title class_">Context</span>.Ref&lt;Provider&lt;Component&gt;&gt;() &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>这里是创建一个匿名的 Ref 实例，如果我们获取去到这个实例的类型并为 Ref 中必要的字段赋值，可以避免用户在时使用自己构造TypeLiteral。</p>
<p>这里需要先创建一个无参构造函数，并在函数中获取到这个实例的范型类型，并根据范型类型赋值 Ref 的字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">Ref</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> ((ParameterizedType)(getClass().getGenericSuperclass())).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    init(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Type type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = ((ParameterizedType) type).getRawType();</span><br><span class="line">        <span class="built_in">this</span>.component = (Class&lt;?&gt;) ((ParameterizedType) type).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = (Class&lt;?&gt;) type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里提取了 init 方法，那么也可以将原来的有参构造函数的实现委托给 init 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Ref(ParameterizedType type) &#123;</span><br><span class="line">    init(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ref(Class&lt;ComponentType&gt; component) &#123;</span><br><span class="line">    init(component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">Ref</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> ((ParameterizedType)(getClass().getGenericSuperclass())).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    init(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Type type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = ((ParameterizedType) type).getRawType();</span><br><span class="line">        <span class="built_in">this</span>.component = (Class&lt;?&gt;) ((ParameterizedType) type).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = (Class&lt;?&gt;) type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么测试类中使用时，就修改为：</p>
<p><img src="/blogs/25729/image-20240817115223561.png" alt="image-20240817115223561"></p>
<p>随后就可以删除 TypeLiteral 了。</p>
<h1 id="Qualifier"><a href="#Qualifier" class="headerlink" title="Qualifier"></a>Qualifier</h1><p>自定义 Qualifier 的依赖</p>
<ul>
<li><p>注册组件时，可额外指定 Qualifier</p>
</li>
<li><p>注册组件时，可从类对象上提取 Qualifier</p>
</li>
<li><p>寻找依赖时，需同时满足类型与自定义 Qualifier 标注</p>
</li>
<li><p>支持默认 Qualifier——Named</p>
</li>
</ul>
<p>将上面的功能点，细分为多个测试任务</p>
<p>归属于 ContextTest 上下文中的任务，分别有关于 TypeBinding 和 DependencyCheck 的任务：</p>
<p>TypeBinding 的任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nested</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WithQualifier</span> &#123;</span><br><span class="line">    <span class="comment">// TODO binding component with qualifier</span></span><br><span class="line">    <span class="comment">// TODO binding component with qualifiers</span></span><br><span class="line">    <span class="comment">// TODO throw illegal component if illegal qualifier</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DependencyCheck 的任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nested</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WithQualifier</span> &#123;</span><br><span class="line">    <span class="comment">// TODO dependency missing if qualifier not match</span></span><br><span class="line">    <span class="comment">// TODO check cyclic dependencies with qualifier</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归属于 InjectionTest 上下文中的任务，分别有关于 ConstructorInjection、FieldInjection、MethodInjection 的任务：</p>
<p>分别都有如下的测试任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nested</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithQualifier</span> &#123;</span><br><span class="line">    <span class="comment">// TODO inject with qualifier</span></span><br><span class="line">    <span class="comment">// TODO throw illegal component if illegal qualifier given to injection point</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="binding-component-with-qualifier"><a href="#binding-component-with-qualifier" class="headerlink" title="binding component with qualifier"></a>binding component with qualifier</h2><p>component 分为两种情况，分别是：instance 和 component。</p>
<h3 id="绑定-instance"><a href="#绑定-instance" class="headerlink" title="绑定 instance"></a>绑定 instance</h3><p>先实现 instance 的情况，创建测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO binding component with qualifier</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_bind_instance_with_qualifier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Component</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    config.bind(Component.class, component, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> config.getContext();</span><br><span class="line"></span><br><span class="line">    <span class="type">Component</span> <span class="variable">chosenOne</span> <span class="operator">=</span></span><br><span class="line">            context.get(Context.Ref.of(Component.class, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>))).get();</span><br><span class="line">    assertSame(component, chosenOne);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要新建 NamedLiteral</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">NamedLiteral</span><span class="params">(String value)</span> <span class="keyword">implements</span> <span class="title class_">jakarta</span>.inject.Named &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType() &#123;</span><br><span class="line">        <span class="keyword">return</span> jakarta.inject.Named.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且需要在 ContextConfig 中增加包含三个参数的 bind 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Type instance, Annotation qualifier)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Ref 中增加两个参数的 of 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;ComponentType&gt; Ref&lt;ComponentType&gt; <span class="title function_">of</span><span class="params">(Class&lt;ComponentType&gt; component, Annotation qualifier)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使得编译通过。</p>
<p>实现</p>
<p>目前，保存 providers 的 map 中的 key 只有 class，我们现在需要的是 type 和 qualifier 两个参数共同组合成的 key</p>
<p><img src="/blogs/25729/image-20240819104016654.png" alt="image-20240819104016654"></p>
<p>自定义一个 record 来封装 type 和 qualifier 的组合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Component</span><span class="params">(Class&lt;?&gt; type, Annotation qualifier)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并新建一个 map 来保存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Component, ComponentProvider&lt;?&gt;&gt; components = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>实现 bind 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Type instance, Annotation qualifier)</span> &#123;</span><br><span class="line">    components.put(<span class="keyword">new</span> <span class="title class_">Component</span>(type, qualifier), context -&gt; instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>get 时需要判断 Ref 中是否是 Qualifier 的情况</p>
<p>可以在在 Ref 中增加一个字段 qualifier ，并相应的在构造方法中增加字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Annotation qualifier;</span><br><span class="line"></span><br><span class="line">Ref(Type type, Annotation qualifier) &#123;</span><br><span class="line">    init(type);</span><br><span class="line">    <span class="built_in">this</span>.qualifier = qualifier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Annotation <span class="title function_">getQualifier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> qualifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增分支，从 Context 中获取实例</p>
<p><img src="/blogs/25729/Snipaste_2024-08-19_11-18-32.png" alt="Snipaste_2024-08-19_11-18-32"></p>
<p>运行测试，通过。</p>
<h3 id="绑定组件"><a href="#绑定组件" class="headerlink" title="绑定组件"></a>绑定组件</h3><p>构造测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_bind_component_with_qualifier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Dependency</span> <span class="variable">dependency</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dependency</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    config.bind(Dependency.class, dependency);</span><br><span class="line">    config.bind(ConstructorInjection.class, ConstructorInjection.class, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> config.getContext();</span><br><span class="line"></span><br><span class="line">    <span class="type">ConstructorInjection</span> <span class="variable">chosenOne</span> <span class="operator">=</span></span><br><span class="line">            context.get(Context.Ref.of(ConstructorInjection.class, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>))).get();</span><br><span class="line">    assertSame(dependency, chosenOne.dependency());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConstructorInjection</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Dependency dependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstructorInjection</span><span class="params">(Dependency dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dependency <span class="title function_">dependency</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要增加一个对应的 bind 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type, Implementation <span class="keyword">extends</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation, Annotation qualifier)</span> &#123;</span><br><span class="line">    components.put(<span class="keyword">new</span> <span class="title class_">Component</span>(type, qualifier), <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>(implementation));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，通过。</p>
<h2 id="binding-component-with-qualifiers"><a href="#binding-component-with-qualifiers" class="headerlink" title="binding component with qualifiers"></a>binding component with qualifiers</h2><p>绑定、注册组件的时候，可以指定多个 qualifier，但是只能根据一个取，这是规范规定的。</p>
<h3 id="绑定实例"><a href="#绑定实例" class="headerlink" title="绑定实例"></a>绑定实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO binding component with qualifiers</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_bind_instance_with_multi_qualifiers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Component</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    config.bind(Component.class, component, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>), <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;AnotherOne&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> config.getContext();</span><br><span class="line"></span><br><span class="line">    <span class="type">Component</span> <span class="variable">chosenOne</span> <span class="operator">=</span> context.get(Context.Ref.of(Component.class, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>))).get();</span><br><span class="line">    <span class="type">Component</span> <span class="variable">anotherOne</span> <span class="operator">=</span> context.get(Context.Ref.of(Component.class, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;AnotherOne&quot;</span>))).get();</span><br><span class="line"></span><br><span class="line">    assertSame(component, anotherOne);</span><br><span class="line">    assertSame(chosenOne, anotherOne);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 bind 方法的 qualifier 参数修改为可变数组，使编译通过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Type instance, Annotation... qualifiers)</span> &#123;</span><br><span class="line">    components.put(<span class="keyword">new</span> <span class="title class_">Component</span>(type, qualifiers[<span class="number">0</span>]), context -&gt; instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现，bind 时分别注册每一 qualifier</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Type instance, Annotation... qualifiers)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Annotation qualifier : qualifiers)</span><br><span class="line">        components.put(<span class="keyword">new</span> <span class="title class_">Component</span>(type, qualifier), context -&gt; instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绑定组件-1"><a href="#绑定组件-1" class="headerlink" title="绑定组件"></a>绑定组件</h3><p>构造测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_bind_component_with_multi_qualifiers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Dependency</span> <span class="variable">dependency</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dependency</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    config.bind(Dependency.class, dependency);</span><br><span class="line">    config.bind(ConstructorInjection.class, ConstructorInjection.class, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;AnotherOne&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> config.getContext();</span><br><span class="line"></span><br><span class="line">    <span class="type">ConstructorInjection</span> <span class="variable">chosenOne</span> <span class="operator">=</span></span><br><span class="line">            context.get(Context.Ref.of(ConstructorInjection.class, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>))).get();</span><br><span class="line">     <span class="type">ConstructorInjection</span> <span class="variable">anotherOne</span> <span class="operator">=</span></span><br><span class="line">             context.get(Context.Ref.of(ConstructorInjection.class, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;AnotherOne&quot;</span>))).get();</span><br><span class="line"></span><br><span class="line">    assertSame(dependency, chosenOne.dependency());</span><br><span class="line">    assertSame(dependency, anotherOne.dependency());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现，对应的为 bind 方法的 qualifier 参数修改为可变数组，并分别注册每一个 qualifier ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type, Implementation <span class="keyword">extends</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation, Annotation... qualifiers)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Annotation qualifier : qualifiers)</span><br><span class="line">        components.put(<span class="keyword">new</span> <span class="title class_">Component</span>(type, qualifier), <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>(implementation));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重构-ContextConfig-的内部实现"><a href="#重构-ContextConfig-的内部实现" class="headerlink" title="重构 ContextConfig 的内部实现"></a>重构 ContextConfig 的内部实现</h2><p>位置支持 Qualifier 我们目前已经有很多方法存在平行实现（实现方法非常类似），如果继续完成其他测试，那么会产生更多的平行实现。这里我们选择先重构。</p>
<h3 id="components-替换掉-providers"><a href="#components-替换掉-providers" class="headerlink" title="components 替换掉 providers"></a>components 替换掉 providers</h3><p>接下来，就是要用 components 替换掉 providers</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;?&gt;, ComponentProvider&lt;?&gt;&gt; providers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;Component, ComponentProvider&lt;?&gt;&gt; components = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>重构之前先看一下有哪些地方使用了 providers </p>
<p><img src="/blogs/25729/Snipaste_2024-08-19_14-16-56.png" alt="Snipaste_2024-08-19_14-16-56"></p>
<p>这里使用的主要地方是 getContext 和 checkDependencies。</p>
<p>先看 getContext </p>
<p><img src="/blogs/25729/Snipaste_2024-08-19_14-20-19.png" alt="Snipaste_2024-08-19_14-20-19"></p>
<p>先将其中使用到 providers 的位置提取为方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;ComponentType&gt; ComponentProvider&lt;?&gt; getComponentProvider(Context.Ref&lt;ComponentType&gt; ref) &#123;</span><br><span class="line"><span class="comment">//        components.get(new Component(ref.getComponent(), ref.getQualifier()));</span></span><br><span class="line">    <span class="keyword">return</span> providers.get(ref.getComponent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面注释的代码，就是我们预期想要的实现。</p>
<p>逐步将使用到 providers 的地方用 components 替换掉。</p>
<p>bind 方法中替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Type instance)</span> &#123;</span><br><span class="line"><span class="comment">//        providers.put(type, (ComponentProvider&lt;Type&gt;) context -&gt; instance);</span></span><br><span class="line">    components.put(<span class="keyword">new</span> <span class="title class_">Component</span>(type, <span class="literal">null</span>), context -&gt; instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;Type, Implementation <span class="keyword">extends</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation)</span> &#123;</span><br><span class="line"><span class="comment">//        providers.put(type, new InjectionProvider(implementation));</span></span><br><span class="line">    components.put(<span class="keyword">new</span> <span class="title class_">Component</span>(type, <span class="literal">null</span>), <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>(implementation));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getContext 方法替换：</p>
<p><img src="/blogs/25729/image-20240819144934546.png" alt="image-20240819144934546"></p>
<p><img src="/blogs/25729/image-20240819145015046.png" alt="image-20240819145015046"></p>
<p>至此移除不在使用的 providers 即可。</p>
<blockquote>
<p>观察以下两个 bind 方法，可以合并成一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Type instance)</span> &#123;</span><br><span class="line">    components.put(<span class="keyword">new</span> <span class="title class_">Component</span>(type, <span class="literal">null</span>), context -&gt; instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;Type&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Type instance, Annotation... qualifiers)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Annotation qualifier : qualifiers)</span><br><span class="line">        components.put(<span class="keyword">new</span> <span class="title class_">Component</span>(type, qualifier), context -&gt; instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并后为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Type instance, Annotation... qualifiers)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (qualifiers.length == <span class="number">0</span>) components.put(<span class="keyword">new</span> <span class="title class_">Component</span>(type, <span class="literal">null</span>), context -&gt; instance);</span><br><span class="line">    <span class="keyword">for</span> (Annotation qualifier : qualifiers)</span><br><span class="line">        components.put(<span class="keyword">new</span> <span class="title class_">Component</span>(type, qualifier), context -&gt; instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>建议不合并</strong>，减少一个 if 也可以有一个更清晰的对外接口。</p>
</blockquote>
<h3 id="其他坏味道"><a href="#其他坏味道" class="headerlink" title="其他坏味道"></a>其他坏味道</h3><p>可以观察到，很多使用 Ref 的地方都需要转换为 Component</p>
<p><img src="/blogs/25729/image-20240819150104089.png" alt="image-20240819150104089"></p>
<p>好像 Ref 和 Component 之间存在某种关系。</p>
<p>其实，Ref 就应该将 Class 和 Qualifier 封装为一个整体，而不是再将这两个拆散。</p>
<p>一个更合理的实现是，使用一个 Component 来替换掉 <code>Class&lt;?&gt; component</code> 和 <code>Annotation qualifier</code> 字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ref</span>&lt;ComponentType&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Type container;</span><br><span class="line"><span class="comment">//        private ContextConfig.Component component;</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; component;</span><br><span class="line">    <span class="keyword">private</span> Annotation qualifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先将 Ref 重名为 ComponentRef，并从 Context 中移出，作为一个外部类。</p>
<p>也将 Component 从 ContextConfig 中移出，作为一个外部类。</p>
<blockquote>
<p>由于原来已经有一个 Component 用于作为测试用例的类，这里先将原来的 Component 修改为 TestComponent，以避免因重名造成的异常。</p>
</blockquote>
<p>在 ComponentRef 中增加 component 字段，并将原来的 component 字段重命名为 componentType：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentRef</span>&lt;ComponentType&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Type container;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; componentType;</span><br><span class="line">    <span class="keyword">private</span> Annotation qualifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加一个 component 字段，相应的给 init 中增加一个 qualifier 的参数，并在其中为 component 赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Type type, Annotation qualifier)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = ((ParameterizedType) type).getRawType();</span><br><span class="line">        <span class="built_in">this</span>.componentType = (Class&lt;?&gt;) ((ParameterizedType) type).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.component = <span class="keyword">new</span> <span class="title class_">Component</span>(componentType, qualifier);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.componentType = (Class&lt;?&gt;) type;</span><br><span class="line">        <span class="built_in">this</span>.component = <span class="keyword">new</span> <span class="title class_">Component</span>(componentType, qualifier);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么所有之前通过 ref 来 new Component 都可以替换为 ref.component().</p>
<p><img src="/blogs/25729/image-20240819155305967.png" alt="image-20240819155305967"></p>
<p>还可以发现，getQualifier 已无处使用，可以移除，qualifier 字段也无处使用，可以移除。</p>
<p>同时也可将 getComponentType 的实现替换为如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getComponentType() &#123;</span><br><span class="line">    <span class="keyword">return</span> component.type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，期望移除 component，先找到 component 在哪里被使用。</p>
<p>一个地方是在 equals 和 hashCode 方法中被使用，先重新生成这两个方法，新生成的方法不要使用 componentType 字段。</p>
<p>其他使用的地方就是在 init 方法中，修改 init 方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Type type, Annotation qualifier)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = ((ParameterizedType) type).getRawType();</span><br><span class="line">        Class&lt;?&gt; componentType = (Class&lt;?&gt;) ((ParameterizedType) type).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.component = <span class="keyword">new</span> <span class="title class_">Component</span>(componentType, qualifier);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = <span class="keyword">new</span> <span class="title class_">Component</span>((Class&lt;?&gt;) type, qualifier);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除 componentType 字段。</p>
<h2 id="重构测试"><a href="#重构测试" class="headerlink" title="重构测试"></a>重构测试</h2><h3 id="测试文档化-1"><a href="#测试文档化-1" class="headerlink" title="测试文档化"></a>测试文档化</h3><p>从测试文档化的角度来讲，下面的两个测试是不需要的。</p>
<p><img src="/blogs/25729/image-20240819161618368.png" alt="image-20240819161618368"></p>
<p>这两个测试，是驱动我们开发的记录，但是不应该作为最终的文档形式。</p>
<h3 id="自定义-Qualifier"><a href="#自定义-Qualifier" class="headerlink" title="自定义 Qualifier"></a>自定义 Qualifier</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@java</span>.lang.annotation.Documented</span><br><span class="line"><span class="meta">@java</span>.lang.annotation.Retention(RUNTIME)</span><br><span class="line"><span class="meta">@jakarta</span>.inject.Qualifier</span><br><span class="line"><span class="meta">@interface</span> AnotherOne &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">record</span> <span class="title class_">AnotherOneLiteral</span><span class="params">()</span> <span class="keyword">implements</span> <span class="title class_">AnotherOne</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType() &#123;</span><br><span class="line">        <span class="keyword">return</span> AnotherOne.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bind 时使用自定义注解：</p>
<p><img src="/blogs/25729/image-20240819162836708.png" alt="image-20240819162836708"></p>
<h2 id="非法的-Qualifier"><a href="#非法的-Qualifier" class="headerlink" title="非法的 Qualifier"></a>非法的 Qualifier</h2><p>验证的是非 Qualifier 注解标记的情况。</p>
<p>需要先创建一个非 Qualifier 的注解的包装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">TestLiteral</span><span class="params">()</span> <span class="keyword">implements</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Test.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造绑定实例的测试：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO throw illegal component if illegal qualifier</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_illegal_qualifier_given_to_instance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TestComponent</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestComponent</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    assertThrows(IllegalComponentException.class, () -&gt; config.bind(TestComponent.class, component, <span class="keyword">new</span> <span class="title class_">TestLiteral</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现，绑定时检查是否包含非Qualifier的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Type instance, Annotation... qualifiers)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Arrays.stream(qualifiers).anyMatch(q -&gt; !q.annotationType().isAnnotationPresent(Qualifier.class)))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br><span class="line">    <span class="keyword">for</span> (Annotation qualifier : qualifiers)</span><br><span class="line">        components.put(<span class="keyword">new</span> <span class="title class_">Component</span>(type, qualifier), context -&gt; instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造绑定组件的测试：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_illegal_qualifier_given_to_component</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalComponentException.class, </span><br><span class="line">            () -&gt; config.bind(ConstructorInjection.class, ConstructorInjection.class, <span class="keyword">new</span> <span class="title class_">TestLiteral</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现，同样的绑定时检查是否包含非Qualifier的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Type, Implementation <span class="keyword">extends</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation, Annotation... qualifiers)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Arrays.stream(qualifiers).anyMatch(q -&gt; !q.annotationType().isAnnotationPresent(Qualifier.class)))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br><span class="line">    <span class="keyword">for</span> (Annotation qualifier : qualifiers)</span><br><span class="line">        components.put(<span class="keyword">new</span> <span class="title class_">Component</span>(type, qualifier), <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>(implementation));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="依赖检查"><a href="#依赖检查" class="headerlink" title="依赖检查"></a>依赖检查</h2><h3 id="Qualifier-标记的依赖不存在"><a href="#Qualifier-标记的依赖不存在" class="headerlink" title="Qualifier 标记的依赖不存在"></a>Qualifier 标记的依赖不存在</h3><p>测试指定了 Qualifier 的依赖的情况：</p>
<blockquote>
<p>如果依赖的参数被 Qualifier 标记，那么从 容器中获取的依赖也必须被 Qualifier 标记，否则也要抛出 DependencyNotFoundException 异常。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO dependency missing if qualifier not match</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_dependency_not_found_with_qualifier</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    config.bind(Dependency.class, <span class="keyword">new</span> <span class="title class_">Dependency</span>() &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    config.bind(InjectConstructor.class, InjectConstructor.class);</span><br><span class="line"></span><br><span class="line">    assertThrows(DependencyNotFoundException.class, () -&gt; config.getContext());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InjectConstructor</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InjectConstructor</span><span class="params">(<span class="meta">@AnotherOne</span> Dependency dependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前的依赖检查的实现是基于 CompronentProvider 中的 getDependencies 方法。</p>
<p><img src="/blogs/25729/image-20240819171549770.png" alt="image-20240819171549770"></p>
<p>但是目前获取依赖时并没有区分被 Qualifier 标记的情况。所以想要实现依赖缺失的检查还需要修改 CompronentProvider 中的 getDependencies 方法。</p>
<p>这样就衍生出，<code>include qualifier with dependency</code> 的测试。这属于 InjectionTest 测试上下文的范畴。</p>
<p>分别在 InjectionTest 的 ConstructorInjection、FieldInjection、MethodInjection 中的 WithQualifier 测试分组中增加任务：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-19_17-25-58.png" alt="Snipaste_2024-08-19_17-25-58"></p>
<p>构造函数注入被 Qualifier 标注的测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO include qualifier with dependency</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InjectConstructor</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InjectConstructor</span><span class="params">(<span class="meta">@Named(&quot;ChosenOne&quot;)</span> Dependency dependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_include_qualifier_with_dependency</span><span class="params">()</span> &#123;</span><br><span class="line">    InjectionProvider&lt;InjectConstructor&gt; provider = <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(InjectConstructor.class);</span><br><span class="line"></span><br><span class="line">    assertArrayEquals(<span class="keyword">new</span> <span class="title class_">ComponentRef</span>[]&#123;ComponentRef.of(Dependency.class, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>))&#125;,</span><br><span class="line">            provider.getDependencies().toArray(ComponentRef[]::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现，需要修改以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;ComponentRef&gt; <span class="title function_">getDependencies</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.concat(</span><br><span class="line">                    Stream.concat(Arrays.stream(injectConstructor.getParameters()).map(Parameter::getParameterizedType),</span><br><span class="line">                            injectFields.stream().map(Field::getGenericType)),</span><br><span class="line">                    injectMethods.stream().flatMap(m -&gt; Arrays.stream(m.getGenericParameterTypes())))</span><br><span class="line">            .map(ComponentRef::of).toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前并没有考虑标注的情况。</p>
<p>修改 Provider 中的实现，获取依赖时在返回的 ComponentRef 应包含注解的信息。</p>
<p><img src="/blogs/25729/image-20240819180342402.png" alt="image-20240819180342402"></p>
<p>此外，判断 Named 于 NamedLiteral 是否相等，还需要修改 NamedLiteral 中的 equals 方法，因为是测试，所以只需要一个简单的实现。</p>
<blockquote>
<p>如果是生产代码中，应该根据 Annotation 中规范的方式编写。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> jakarta.inject.Named named) <span class="keyword">return</span> value.equals(named.value());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试通过。</p>
<p>同时，<code>should_throw_exception_if_dependency_not_found_with_qualifier</code> 测试也将通过。</p>
<h3 id="DependencyNotFoundException-信息优化"><a href="#DependencyNotFoundException-信息优化" class="headerlink" title="DependencyNotFoundException 信息优化"></a>DependencyNotFoundException 信息优化</h3><p>目前 DependencyNotFoundException 中并不包含 Qualifier 注解的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; dependency;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; component;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DependencyNotFoundException</span><span class="params">(Class&lt;?&gt; component, Class&lt;?&gt; dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getDependency() &#123;</span><br><span class="line">        <span class="keyword">return</span> dependency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getComponent() &#123;</span><br><span class="line">        <span class="keyword">return</span> component;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们还需要知道异常中注解的信息，可以修改测试，增加如下校验：</p>
<p><img src="/blogs/25729/image-20240819183725309.png" alt="image-20240819183725309"></p>
<p>在 DependencyNotFoundException 中新建两个方法，分别用于获取造成异常的 component 和 dependency 的信息。</p>
<p>DependencyNotFoundException 重构为：</p>
<blockquote>
<p>增加两个 Component 类型的字段和对应的 getter，以及构造函数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; dependency;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; component;</span><br><span class="line">    <span class="keyword">private</span> Component dependencyComponent;</span><br><span class="line">    <span class="keyword">private</span> Component componentComponent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DependencyNotFoundException</span><span class="params">(Class&lt;?&gt; component, Class&lt;?&gt; dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DependencyNotFoundException</span><span class="params">(Component componentComponent, Component dependencyComponent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependencyComponent = dependencyComponent;</span><br><span class="line">        <span class="built_in">this</span>.componentComponent = componentComponent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getDependency() &#123;</span><br><span class="line">        <span class="keyword">return</span> dependency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getComponent() &#123;</span><br><span class="line">        <span class="keyword">return</span> component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getDependencyComponent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.dependencyComponent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getComponentComponent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.componentComponent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的 AnotherOneLiteral 也需要实现 equals 方法，否则 AnotherOneLiteral 和 AnotherOne 的比较会异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">AnotherOneLiteral</span><span class="params">()</span> <span class="keyword">implements</span> <span class="title class_">AnotherOne</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType() &#123;</span><br><span class="line">        <span class="keyword">return</span> AnotherOne.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> AnotherOne;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现，找到唯一会创建 DependencyNotFoundException 的地方是 ContextConfig 中的 checkDependencies 方法，修改为：</p>
<p><img src="/blogs/25729/image-20240819190900039.png" alt="image-20240819190900039"></p>
<p>运行测试，should_throw_exception_if_dependency_not_found_with_qualifier 将通过。</p>
<p>但是，因为修改了返回的 DependencyNotFoundException 中的信息，所以之前创建的检查依赖缺失的测试将失败：</p>
<p><img src="/blogs/25729/image-20240819191232231.png" alt="image-20240819191232231"></p>
<p>因为当前异常中的 dependency 和 component 并没有被赋值：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-19_19-13-36.png" alt="Snipaste_2024-08-19_19-13-36"></p>
<p>修改 DependencyNotFoundException 方法返回的信息：</p>
<p><img src="/blogs/25729/image-20240819191622688.png" alt="image-20240819191622688"></p>
<p>删除未使用的字段的构造函数。</p>
<p>更进一步，将使用 getDependency 和 getComponent 方法的地方，替换为使用 getDependencyComponent 和 getComponentComponent：</p>
<p><img src="/blogs/25729/image-20240819191940010.png" alt="image-20240819191940010"></p>
<p>至此，就没有地方使用 getDependency 和 getComponent 方法。可移除，移除后可以对 DependencyNotFoundException 中的字段和方法进行重命名。</p>
<p>最终，DependencyNotFoundException 重构为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Component dependency;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DependencyNotFoundException</span><span class="params">(Component component, Component dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getDependency</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.dependency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getComponent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.component;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>构造测试：</p>
<p>我们期望： A -&gt; @AnotherOne A -&gt; @Named A 不构成循环依赖，因为 <code>Qualifier + 类型</code> 的组合构造类型的key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO check cyclic dependencies with qualifier</span></span><br><span class="line"><span class="comment">// A -&gt; @AnotherOne A -&gt; @Named A</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AnotherOneDependency</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnotherOneDependency</span><span class="params">(<span class="meta">@jakarta</span>.inject.Named(<span class="string">&quot;ChosenOne&quot;</span>)</span> Dependency dependency) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NotCyclicDependency</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotCyclicDependency</span><span class="params">(<span class="meta">@AnotherOne</span> Dependency dependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_not_throw_exception_if_component_with_same_type_tagged_with_different_qualifier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Dependency</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dependency</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    config.bind(Dependency.class, instance, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>));</span><br><span class="line">    config.bind(Dependency.class, AnotherOneDependency.class, <span class="keyword">new</span> <span class="title class_">AnotherOneLiteral</span>());</span><br><span class="line">    config.bind(Dependency.class, NotCyclicDependency.class);</span><br><span class="line"></span><br><span class="line">    assertDoesNotThrow(() -&gt; config.getContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还需要为 NamedLiteral 创建 hashCode 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">NamedLiteral</span><span class="params">(String value)</span> <span class="keyword">implements</span> <span class="title class_">jakarta</span>.inject.Named &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType() &#123;</span><br><span class="line">        <span class="keyword">return</span> jakarta.inject.Named.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> jakarta.inject.Named named) <span class="keyword">return</span> value.equals(named.value());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;value&quot;</span>.hashCode() * <span class="number">127</span> ^ value.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashCode 方法需要根据 Annotation 的规范创建：</p>
<blockquote>
<p><img src="/blogs/25729/image-20240819195133888.png" alt="image-20240819195133888"></p>
</blockquote>
<p>运行测试，将抛出 CyclicDependenciesException</p>
<p>找到抛出 CyclicDependenciesException 的代码，目前只有 ContextConfig 中的 checkDependencies 方法会抛出 CyclicDependenciesException</p>
<p><img src="/blogs/25729/image-20240819195927082.png" alt="image-20240819195927082"></p>
<p>原因是 visiting 栈中只包含 Class 的信息，没有 Qualifier 注解相关的信息。</p>
<p>那么需要把 Stack 中的类型由 Class&lt;?&gt; 改为 Component，并将使用 visiting 的地方都改为 Component：</p>
<p><img src="/blogs/25729/image-20240819200809441.png" alt="image-20240819200809441"></p>
<p><img src="/blogs/25729/image-20240819200844752.png" alt="image-20240819200844752"></p>
<p>运行测试，通过。</p>
<h2 id="ComponentProvider-检查-Qualifier-依赖"><a href="#ComponentProvider-检查-Qualifier-依赖" class="headerlink" title="ComponentProvider 检查 Qualifier 依赖"></a>ComponentProvider 检查 Qualifier 依赖</h2><p>检查 getDependencies 获取依赖时，返回正确的依赖，前面已经完成了构造器注入 Qualifier 依赖的检查。还需要检查字段注入和方法注入 Qualifier 依赖时的检查。</p>
<p>这里先检查方法注入时的情况。</p>
<p>构造测试，位于 InjectionTest.MethodInjection.WithQualifier中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO include qualifier with dependency</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InjectMethod</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(<span class="meta">@Named(&quot;ChosenOne&quot;)</span> Dependency dependency)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_include_dependency_with_qualifier</span><span class="params">()</span> &#123;</span><br><span class="line">    InjectionProvider&lt;InjectMethod&gt; provider = <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(InjectMethod.class);</span><br><span class="line"></span><br><span class="line">    assertArrayEquals(<span class="keyword">new</span> <span class="title class_">ComponentRef</span>[]&#123;ComponentRef.of(Dependency.class, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>))&#125;,</span><br><span class="line">            provider.getDependencies().toArray(ComponentRef[]::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现：</p>
<p><img src="/blogs/25729/image-20240819202905248.png" alt="image-20240819202905248"></p>
<p>构造字段注入 Qualifier 依赖的测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO include qualifier with dependency</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InjectField</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@Named(&quot;ChosenOne&quot;)</span> Dependency dependency;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_include_dependency_with_qualifier</span><span class="params">()</span> &#123;</span><br><span class="line">    InjectionProvider&lt;InjectField&gt; provider = <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(InjectField.class);</span><br><span class="line"></span><br><span class="line">    assertArrayEquals(<span class="keyword">new</span> <span class="title class_">ComponentRef</span>[]&#123;ComponentRef.of(Dependency.class, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>))&#125;,</span><br><span class="line">            provider.getDependencies().toArray(ComponentRef[]::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现：</p>
<p><img src="/blogs/25729/image-20240819204156897.png" alt="image-20240819204156897"></p>
<h2 id="inject-with-qualifier"><a href="#inject-with-qualifier" class="headerlink" title="inject with qualifier"></a>inject with qualifier</h2><p>实现注入被 Qualifier 标记的依赖的功能。</p>
<h3 id="构造器注入被-Qualifier-标记的依赖"><a href="#构造器注入被-Qualifier-标记的依赖" class="headerlink" title="构造器注入被 Qualifier 标记的依赖"></a>构造器注入被 Qualifier 标记的依赖</h3><p>通过构造函数注入的方式，注入被 Qualifier 标记的组件，构造以下测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO inject with qualifier</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_inject_dependency_with_qualifier_via_constructor</span><span class="params">()</span> &#123;</span><br><span class="line">    InjectionProvider&lt;InjectConstructor&gt; provider = <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(InjectConstructor.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">InjectConstructor</span> <span class="variable">instance</span> <span class="operator">=</span> provider.get(context);</span><br><span class="line">    assertSame(dependency, instance.dependency);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InjectConstructor</span> &#123;</span><br><span class="line">    Dependency dependency;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InjectConstructor</span><span class="params">(<span class="meta">@Named(&quot;ChosenOne&quot;)</span> Dependency dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，测试会通过。</p>
<blockquote>
<p>这是假阴性。</p>
</blockquote>
<p>因为使用了测试替身，在测试替身构造的结果和生产代码都没发生改变的情况下，就不会出现错误。就会导致假阴性。</p>
<p><img src="/blogs/25729/image-20240820092043644.png" alt="image-20240820092043644"></p>
<p>无法直接修改 setUp 中的行为，因为现在直接修改的话，会产生大量的错误。</p>
<p>需要在当前测试中，重置 sutUp 中的行为（预期），也就是重新设置测试夹具：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nested</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithQualifier</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        Mockito.reset(context);</span><br><span class="line">        Mockito.when(context.get(eq(ComponentRef.of(Dependency.class, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>))))).thenReturn(Optional.of(dependency));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO inject with qualifier</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_inject_dependency_with_qualifier_via_constructor</span><span class="params">()</span> &#123;</span><br><span class="line">        InjectionProvider&lt;InjectConstructor&gt; provider = <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(InjectConstructor.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">InjectConstructor</span> <span class="variable">instance</span> <span class="operator">=</span> provider.get(context);</span><br><span class="line">        assertSame(dependency, instance.dependency);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时运行测试，将不通过。</p>
<p>原因是，使用 get 方法获取组件时，会去容器中查找组件的依赖，并赋值到组件中。但是目前去容器中查找的方法，并没有携带 Qualifier 标记的信息，只包含了类型的信息。</p>
<p><img src="/blogs/25729/image-20240820093625332.png" alt="image-20240820093625332"></p>
<p><img src="/blogs/25729/image-20240820093829851.png" alt="image-20240820093829851"></p>
<p>实现，即查找依赖时需要从容器中获取带有 qualifier</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.get(ComponentRef.of(type, qualifier))</span><br></pre></td></tr></table></figure>

<p>提取一个新方法，在其中获取参数的注解，并传递给 toDependency 方法。</p>
<p><img src="/blogs/25729/image-20240820100400074.png" alt="image-20240820100400074"></p>
<p>因为前面实现了一个获取方法参数的注解的功能，这里提取一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Annotation <span class="title function_">getQualifier</span><span class="params">(Parameter parameter)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(parameter.getAnnotations()).filter(a -&gt; a.annotationType().isAnnotationPresent(Qualifier.class))</span><br><span class="line">                .findFirst().orElse(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，通过。</p>
<h3 id="方法注入被-Qualifier-标记的依赖"><a href="#方法注入被-Qualifier-标记的依赖" class="headerlink" title="方法注入被 Qualifier 标记的依赖"></a>方法注入被 Qualifier 标记的依赖</h3><p>通过构造函数注入的方式，注入被 Qualifier 标记的组件，构造以下测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    Mockito.reset(context);</span><br><span class="line">    Mockito.when(context.get(eq(ComponentRef.of(Dependency.class, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>))))).thenReturn(Optional.of(dependency));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inject with qualifier</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_inject_dependency_with_qualifier_via_method</span><span class="params">()</span> &#123;</span><br><span class="line">    InjectionProvider&lt;InjectMethod&gt; provider = <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(InjectMethod.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">InjectMethod</span> <span class="variable">instance</span> <span class="operator">=</span> provider.get(context);</span><br><span class="line">    assertSame(dependency, instance.dependency);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InjectMethod</span> &#123;</span><br><span class="line">    Dependency dependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(<span class="meta">@Named(&quot;ChosenOne&quot;)</span> Dependency dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，通过。因为方法注入和构造函数注入的内部实现是一样的，所以不需要修改生产代码。</p>
<h3 id="字段注入被-Qualifier-标记的依赖"><a href="#字段注入被-Qualifier-标记的依赖" class="headerlink" title="字段注入被 Qualifier 标记的依赖"></a>字段注入被 Qualifier 标记的依赖</h3><p>构造测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    Mockito.reset(context);</span><br><span class="line">    Mockito.when(context.get(eq(ComponentRef.of(Dependency.class, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>))))).thenReturn(Optional.of(dependency));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_inject_dependency_with_qualifier_via_field</span><span class="params">()</span> &#123;</span><br><span class="line">    InjectionProvider&lt;InjectField&gt; provider = <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(InjectField.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">InjectField</span> <span class="variable">instance</span> <span class="operator">=</span> provider.get(context);</span><br><span class="line">    assertSame(dependency, instance.dependency);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理需要修改 toDependency 的参数：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-20_10-39-36.png" alt="Snipaste_2024-08-20_10-39-36"></p>
<p>因为前面实现过获取 Field 中的注解的功能，这里提取一个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Annotation <span class="title function_">getQualifier</span><span class="params">(Field field)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(field.getAnnotations()).filter(a -&gt; a.annotationType().isAnnotationPresent(Qualifier.class))</span><br><span class="line">                .findFirst().orElse(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="非法的-Qualifier-注入"><a href="#非法的-Qualifier-注入" class="headerlink" title="非法的 Qualifier 注入"></a>非法的 Qualifier 注入</h3><p>非法注入的情况是指，同时使用两个 Qualifier 注解标注同一个依赖时的情况。</p>
<p>根据  JSR330 规范，同一个组件可以被多个 Qualifier 标记注册多个，但是依赖只能指定一个 Qualifier 注解。</p>
<h4 id="构造器非法注入"><a href="#构造器非法注入" class="headerlink" title="构造器非法注入"></a>构造器非法注入</h4><p>构造测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO throw illegal component if illegal qualifier given to injection point</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MultiQualifierInjectConstructor</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MultiQualifierInjectConstructor</span><span class="params">(<span class="meta">@Named(&quot;ChosenOne&quot;)</span> <span class="meta">@AnotherOne</span> Dependency dependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_multi_qualifier_given_to_inject_constructor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 需要在创建时检查依赖是否合法</span></span><br><span class="line">    assertThrows(IllegalComponentException.class,</span><br><span class="line">            () -&gt; <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(MultiQualifierInjectConstructor.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，不通过，即不会抛出异常，我们需要的是抛出异常。</p>
<p>因为当前并没有在创建 InjectionProvider 时检查依赖是否合法，也没有去校验依赖被多个  Qualifier 标注的情况，目前只取其中一个 Qualifier 注解注册。</p>
<p>所以需要修改检查依赖的代码，并将检查依赖的代码加入到构造 Provider 时。</p>
<p>修改获取依赖参数上的 Qualifier 注解，判断注解的数量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Annotation <span class="title function_">getQualifier</span><span class="params">(Parameter parameter)</span> &#123;</span><br><span class="line">    List&lt;Annotation&gt; qualifiers = Arrays.stream(parameter.getAnnotations())</span><br><span class="line">            .filter(a -&gt; a.annotationType().isAnnotationPresent(Qualifier.class)).toList();</span><br><span class="line">    <span class="keyword">if</span> (qualifiers.size() &gt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br><span class="line">    <span class="keyword">return</span> qualifiers.stream().findFirst().orElse(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在构造函数中获取依赖（获取依赖时，会调用 getQualifier 方法，即会检查依赖上的 Qualifier 是否不合法）</p>
<p><img src="/blogs/25729/image-20240820111434672.png" alt="image-20240820111434672"></p>
<p>运行测试，通过。</p>
<h4 id="方法非法注入"><a href="#方法非法注入" class="headerlink" title="方法非法注入"></a>方法非法注入</h4><p>构造测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MultiQualifierInjectMethod</span> &#123;</span><br><span class="line">    Dependency dependency;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(<span class="meta">@Named(&quot;ChosenOne&quot;)</span> <span class="meta">@AnotherOne</span> Dependency dependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_multi_qualifier_given_to_inject_method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 需要在创建时检查依赖是否合法</span></span><br><span class="line">    assertThrows(IllegalComponentException.class,</span><br><span class="line">            () -&gt; <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(MultiQualifierInjectMethod.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，直接通过。因为方法注入的内部实现和构造器注入的内部实现一致，不需要修改生产代码。</p>
<h4 id="字段非法注入"><a href="#字段非法注入" class="headerlink" title="字段非法注入"></a>字段非法注入</h4><p>构造测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MultiQualifierInjectField</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@Named(&quot;ChosenOne&quot;)</span> <span class="meta">@AnotherOne</span> Dependency dependency;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_multi_qualifier_given_to_inject_field</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 需要在创建时检查依赖是否合法</span></span><br><span class="line">    assertThrows(IllegalComponentException.class,</span><br><span class="line">            () -&gt; <span class="keyword">new</span> <span class="title class_">InjectionProvider</span>&lt;&gt;(MultiQualifierInjectField.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，也需要修改 getQualifier 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Annotation <span class="title function_">getQualifier</span><span class="params">(Field field)</span> &#123;</span><br><span class="line">    List&lt;Annotation&gt; qualifiers = Arrays.stream(field.getAnnotations())</span><br><span class="line">            .filter(a -&gt; a.annotationType().isAnnotationPresent(Qualifier.class)).toList();</span><br><span class="line">    <span class="keyword">if</span> (qualifiers.size() &gt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br><span class="line">    <span class="keyword">return</span> qualifiers.stream().findFirst().orElse(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，通过。</p>
<h1 id="重构-6"><a href="#重构-6" class="headerlink" title="重构"></a>重构</h1><h2 id="合并两个-getQualifier"><a href="#合并两个-getQualifier" class="headerlink" title="合并两个 getQualifier"></a>合并两个 getQualifier</h2><p>我们这里目前有两个内部实现完全一样的方法，分别是：getQualifier(Field field) 、getQualifier(Parameter parameter)</p>
<p>因为 Field 和 Parameter 实现了共同的 AnnotatedElement 接口，可以将这两个方法合并为一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Annotation <span class="title function_">getQualifier</span><span class="params">(AnnotatedElement parameter)</span> &#123;</span><br><span class="line">    List&lt;Annotation&gt; qualifiers = Arrays.stream(parameter.getAnnotations())</span><br><span class="line">            .filter(a -&gt; a.annotationType().isAnnotationPresent(Qualifier.class)).toList();</span><br><span class="line">    <span class="keyword">if</span> (qualifiers.size() &gt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br><span class="line">    <span class="keyword">return</span> qualifiers.stream().findFirst().orElse(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简化 toDependency 代码，减少调用层级</p>
<p><img src="/blogs/25729/image-20240820141337390.png" alt="image-20240820141337390"></p>
<p><img src="/blogs/25729/image-20240820141638666.png" alt="image-20240820141638666"></p>
<p>dependency 被获取了两次，属于重复</p>
<p><img src="/blogs/25729/image-20240820142512043.png" alt="image-20240820142512043"></p>
<p>这是最难发现和消除的坏味道。这可能意味着我们对模型概念的封装不足。</p>
<h2 id="模型封装"><a href="#模型封装" class="headerlink" title="模型封装"></a>模型封装</h2><p>先创建一个封装类，将注入器和依赖组合在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">record</span> <span class="title class_">Injectable</span>&lt;Element <span class="keyword">extends</span> <span class="title class_">AccessibleObject</span>&gt;(Element element, ComponentRef&lt;?&gt;[] required)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>范型继承自 AccessibleObject，因为其子类正好包含当前需要的 Constructor、Field、Method，并使用 ComponentRef 数组表示依赖。</p>
<p><img src="/blogs/25729/image-20240820143332218.png" alt="image-20240820143332218"></p>
<h3 id="封装构造器和依赖"><a href="#封装构造器和依赖" class="headerlink" title="封装构造器和依赖"></a>封装构造器和依赖</h3><p>使用 injectableConstructor 来代替原有的 injectConstructor，同样是先新增功能再替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Constructor&lt;T&gt; injectConstructor;</span><br><span class="line"><span class="keyword">private</span> Injectable&lt;Constructor&lt;T&gt;&gt; injectableConstructor;</span><br></pre></td></tr></table></figure>

<p>new InjectionProvider 时，同时为 injectableConstructor 赋值，需要先获取 constructor 和 构造器依赖的 dependency，获取这两数据的代码，在现有的代码里面已经存在了，直接复用就可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;T&gt; constructor = getInjectConstructor(component);</span><br><span class="line">ComponentRef&lt;?&gt;[] constructorDependencies = Arrays.stream(constructor.getParameters()).map(InjectionProvider::toComponentRef)</span><br><span class="line">        .toArray(ComponentRef&lt;?&gt;[]::<span class="keyword">new</span>);</span><br><span class="line"><span class="built_in">this</span>.injectableConstructor = <span class="keyword">new</span> <span class="title class_">Injectable</span>&lt;&gt;(constructor, constructorDependencies);</span><br></pre></td></tr></table></figure>

<p>接着，需要找到 injectConstructor 在哪里使用，并使用 injectableConstructor 替换掉 injectConstructor。</p>
<p><img src="/blogs/25729/image-20240820145941249.png" alt="image-20240820145941249"></p>
<p>并且以上 getDependencies 方法中的部分还需要替换为如下，避免重复获取依赖，可以直接从 injectableConstructor 获取：</p>
<p><img src="/blogs/25729/image-20240820150159534.png" alt="image-20240820150159534"></p>
<p>同样的，newInstance 也不需要重新获取依赖，可以直接从 injectable 中获取。</p>
<p>在 Injectable 中增加一个方法，直接从 context 容器中查找依赖，并返回为 newInstance 所需的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">record</span> <span class="title class_">Injectable</span>&lt;Element <span class="keyword">extends</span> <span class="title class_">AccessibleObject</span>&gt;(Element element, ComponentRef&lt;?&gt;[] required)&#123;</span><br><span class="line">    Object[] toDependencies(Context context) &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(required).map(context::get).map(Optional::get).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blogs/25729/image-20240820151251760.png" alt="image-20240820151251760"></p>
<p>修改后，可以移除 injectConstructor。</p>
<p>再将 injectableConstructor 重名回 injectConstructor。</p>
<h3 id="封装方法注入器和依赖"><a href="#封装方法注入器和依赖" class="headerlink" title="封装方法注入器和依赖"></a>封装方法注入器和依赖</h3><p>同样的，使用 injectableMethods 替换掉 injectMethods：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Injectable&lt;Method&gt;&gt; injectableMethods;</span><br><span class="line"><span class="keyword">private</span> List&lt;Method&gt; injectMethods;</span><br></pre></td></tr></table></figure>

<p>因为构造器和普通方法都是属于方法，并且因为 Constructor 和 Method 都有一个名为 Executable 的父类，所以将构造每一个 Executable 的 Injectable 的代码提取为一个方法，用于同时创建 Constructor 和 Method 的 Injectable 封装类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;Element <span class="keyword">extends</span> <span class="title class_">Executable</span>&gt; Injectable&lt;Element&gt; <span class="title function_">getInjectable</span><span class="params">(Element method)</span> &#123;</span><br><span class="line">    ComponentRef&lt;?&gt;[] dependencies = Arrays.stream(method.getParameters()).map(InjectionProvider::toComponentRef)</span><br><span class="line">            .toArray(ComponentRef&lt;?&gt;[]::<span class="keyword">new</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Injectable</span>&lt;&gt;(method, dependencies);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blogs/25729/image-20240820153558513.png" alt="image-20240820153558513"></p>
<p>那么 injectableMethods 的赋值语句就如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.injectableMethods = getInjectMethods(component).stream().map(InjectionProvider::getInjectable).toList();</span><br></pre></td></tr></table></figure>

<p>接着找到，injectMethods 在哪里被使用</p>
<blockquote>
<p>之前的代码有一处有问题的地方，这里应该先使用 injectMethods 替换掉，不然就在 new InjectionProvider 时，重复调用了两次 getInjectMethods 方法</p>
<p><img src="/blogs/25729/image-20240820154445155.png" alt="image-20240820154445155"></p>
</blockquote>
<p>修为为：</p>
<p><img src="/blogs/25729/image-20240820154815243.png" alt="image-20240820154815243"></p>
<p><img src="/blogs/25729/image-20240820154941586.png" alt="image-20240820154941586"></p>
<p>修改为：</p>
<p><img src="/blogs/25729/image-20240820155126273.png" alt="image-20240820155126273"></p>
<p><img src="/blogs/25729/image-20240820160107174.png" alt="image-20240820160107174"></p>
<p>修改为：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-20_16-01-58.png" alt="Snipaste_2024-08-20_16-01-58"></p>
<p> 移除掉 injectMethods 字段</p>
<p>再将 injectableMethods 重命名回 injectMethods</p>
<h3 id="简单重构-2"><a href="#简单重构-2" class="headerlink" title="简单重构"></a>简单重构</h3><p>先将当前的 getInjectable 方法移动到 Injectable 中，并重命名为 of，这就是一个工厂方法：</p>
<p><img src="/blogs/25729/image-20240820161115163.png" alt="image-20240820161115163"></p>
<h3 id="封装字段注入器和依赖"><a href="#封装字段注入器和依赖" class="headerlink" title="封装字段注入器和依赖"></a>封装字段注入器和依赖</h3><p>使用 injectableFields 替换掉 injectFields</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Injectable&lt;Field&gt;&gt; injectableFields;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Field&gt; injectFields;</span><br></pre></td></tr></table></figure>

<p>在 Injectable 中新建一个工厂方法：</p>
<p><img src="/blogs/25729/image-20240820161528106.png" alt="image-20240820161528106"></p>
<p>那么 injectableFields 的赋值语句为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.injectableFields = getInjectFields(component).stream().map(Injectable::of).toList();</span><br></pre></td></tr></table></figure>

<p>接着查找 injectFields 在哪里被使用，并修改为 injectableFields</p>
<p><img src="/blogs/25729/image-20240820161933112.png" alt="image-20240820161933112"></p>
<p><img src="/blogs/25729/image-20240820162458834.png" alt="image-20240820162458834"></p>
<p><img src="/blogs/25729/image-20240820162837117.png" alt="image-20240820162837117"></p>
<p>更好的实现是直接从 Injectable 中获取依赖，避免计算：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-20_16-32-49.png" alt="Snipaste_2024-08-20_16-32-49"></p>
<p>移除 injectFields 字段，</p>
<p>再将 injectableFields 重命名为 injectFields</p>
<p>至此，dependencies 字段已无用，也可以删除，并移除掉一些不再使用的方法。</p>
<p>那么，InjectionProvider 的字段和构造函数就变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Injectable&lt;Constructor&lt;T&gt;&gt; injectConstructor;</span><br><span class="line"><span class="keyword">private</span> List&lt;Injectable&lt;Method&gt;&gt; injectMethods;</span><br><span class="line"><span class="keyword">private</span> List&lt;Injectable&lt;Field&gt;&gt; injectFields;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InjectionProvider</span><span class="params">(Class&lt;T&gt; component)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Modifier.isAbstract(component.getModifiers())) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br><span class="line"></span><br><span class="line">    Constructor&lt;T&gt; constructor = getInjectConstructor(component);</span><br><span class="line">    <span class="built_in">this</span>.injectConstructor = Injectable.of(constructor);</span><br><span class="line">    <span class="built_in">this</span>.injectMethods = getInjectMethods(component).stream().map(Injectable::of).toList();</span><br><span class="line">    <span class="built_in">this</span>.injectFields = getInjectFields(component).stream().map(Injectable::of).toList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (injectFields.stream().map(Injectable::element).anyMatch(f -&gt; Modifier.isFinal(f.getModifiers())))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (injectMethods.stream().map(Injectable::element).anyMatch(m -&gt; m.getTypeParameters().length != <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="整理代码"><a href="#整理代码" class="headerlink" title="整理代码"></a>整理代码</h2><p>观察发现，这几个方法只会在 Injectable 中被调用，可以将这几个方法移动到 Injectable 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ComponentRef&lt;?&gt; toComponentRef(Field field) &#123;</span><br><span class="line">    <span class="type">Annotation</span> <span class="variable">qualifier</span> <span class="operator">=</span> getQualifier(field);</span><br><span class="line">    <span class="keyword">return</span> ComponentRef.of(field.getGenericType(), qualifier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ComponentRef&lt;?&gt; toComponentRef(Parameter parameter) &#123;</span><br><span class="line">    <span class="type">Annotation</span> <span class="variable">qualifier</span> <span class="operator">=</span> getQualifier(parameter);</span><br><span class="line">    <span class="keyword">return</span> ComponentRef.of(parameter.getParameterizedType(), qualifier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Annotation <span class="title function_">getQualifier</span><span class="params">(AnnotatedElement parameter)</span> &#123;</span><br><span class="line">    List&lt;Annotation&gt; qualifiers = Arrays.stream(parameter.getAnnotations())</span><br><span class="line">            .filter(a -&gt; a.annotationType().isAnnotationPresent(Qualifier.class)).toList();</span><br><span class="line">    <span class="keyword">if</span> (qualifiers.size() &gt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br><span class="line">    <span class="keyword">return</span> qualifiers.stream().findFirst().orElse(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 Move Member 的重构方式移动：</p>
<p><img src="/blogs/25729/image-20240820171152367.png" alt="image-20240820171152367"></p>
<p><img src="/blogs/25729/image-20240820171834398.png" alt="image-20240820171834398"></p>
<p>将这些表达式都提取为方法：</p>
<p><img src="/blogs/25729/image-20240820172735344.png" alt="image-20240820172735344"></p>
<p>将getDependencies 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;ComponentRef&lt;?&gt;&gt; getDependencies() &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.concat(</span><br><span class="line">                    Stream.concat(Arrays.stream(injectConstructor.required()),</span><br><span class="line">                            injectFields.stream().map(Injectable::required).flatMap(Arrays::stream)),</span><br><span class="line">                    injectMethods.stream().map(Injectable::required).flatMap(Arrays::stream))</span><br><span class="line">            .toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化为，先拼接为 Injectable 的 Stream，再 Map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;ComponentRef&lt;?&gt;&gt; getDependencies() &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.concat(Stream.concat(Stream.of(injectConstructor), injectFields.stream()), injectMethods.stream())</span><br><span class="line">            .flatMap(i -&gt; Arrays.stream(i.required)).toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="测试文档化重组"><a href="#测试文档化重组" class="headerlink" title="测试文档化重组"></a>测试文档化重组</h1><h2 id="Provider-和-Qualifier-的测试"><a href="#Provider-和-Qualifier-的测试" class="headerlink" title="Provider 和 Qualifier 的测试"></a>Provider 和 Qualifier 的测试</h2><p>在 ContextText.TypeBinding.WithQualifier 中增加 Provider 和 Qualifier 相关联的两个测试，用于检查</p>
<ul>
<li>获取被 Qualifier 的组件的 Provider</li>
<li>获取无对应 Qualifier 标记的组件的Provider是，Provider 应为空</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_retrieve_bind_type_as_provider</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TestComponent</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestComponent</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    config.bind(TestComponent.class, component, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>), <span class="keyword">new</span> <span class="title class_">AnotherOneLiteral</span>());</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> config.getContext();</span><br><span class="line">    Optional&lt;Provider&lt;TestComponent&gt;&gt; provider =</span><br><span class="line">            context.get(<span class="keyword">new</span> <span class="title class_">ComponentRef</span>&lt;Provider&lt;TestComponent&gt;&gt;(<span class="keyword">new</span> <span class="title class_">AnotherOneLiteral</span>()) &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    assertTrue(provider.isPresent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_retrieve_empty_if_no_matched_qualifier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TestComponent</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestComponent</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    config.bind(TestComponent.class, component);</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> config.getContext();</span><br><span class="line">    Optional&lt;Provider&lt;TestComponent&gt;&gt; provider =</span><br><span class="line">            context.get(<span class="keyword">new</span> <span class="title class_">ComponentRef</span>&lt;Provider&lt;TestComponent&gt;&gt;(<span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>)) &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    assertTrue(provider.isEmpty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在 ComponentRef 中增加构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ComponentRef</span><span class="params">(Annotation qualifier)</span> &#123;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> ((ParameterizedType) (getClass().getGenericSuperclass())).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    init(type, qualifier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Qualifier-依赖检查参数化"><a href="#Qualifier-依赖检查参数化" class="headerlink" title="Qualifier 依赖检查参数化"></a>Qualifier 依赖检查参数化</h2><p>将当前 ContextText.DependencyCheck.WithQualifier 中两个测试修改为参数化的测试：</p>
<p>未找到被 Qualifier 标记的依赖时，抛出依赖不存在的异常的的参数化测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dependency missing if qualifier not match</span></span><br><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_dependency_with_qualifier_not_found</span><span class="params">(Class&lt;? extends TestComponent&gt; componentType)</span> &#123;</span><br><span class="line"></span><br><span class="line">    config.bind(Dependency.class, <span class="keyword">new</span> <span class="title class_">Dependency</span>() &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    config.bind(TestComponent.class, componentType, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyNotFoundException</span> <span class="variable">exception</span> <span class="operator">=</span></span><br><span class="line">            assertThrows(DependencyNotFoundException.class, () -&gt; config.getContext());</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="keyword">new</span> <span class="title class_">Component</span>(TestComponent.class, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>)), exception.getComponent());</span><br><span class="line">    assertEquals(<span class="keyword">new</span> <span class="title class_">Component</span>(Dependency.class, <span class="keyword">new</span> <span class="title class_">AnotherOneLiteral</span>()), exception.getDependency());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Arguments&gt; <span class="title function_">should_throw_exception_if_dependency_with_qualifier_not_found</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(</span><br><span class="line">            Arguments.of(Named.of(<span class="string">&quot;Constructor Injection with Qualifier&quot;</span>, DependencyCheck.WithQualifier.InjectConstructor.class)),</span><br><span class="line">            Arguments.of(Named.of(<span class="string">&quot;Field Injection with Qualifier&quot;</span>, DependencyCheck.WithQualifier.InjectField.class)),</span><br><span class="line">            Arguments.of(Named.of(<span class="string">&quot;Method Injection with Qualifier&quot;</span>, DependencyCheck.WithQualifier.InjectMethod.class)),</span><br><span class="line">            Arguments.of(Named.of(<span class="string">&quot;Provider Constructor Injection with Qualifier&quot;</span>, DependencyCheck.WithQualifier.InjectConstructorProvider.class)),</span><br><span class="line">            Arguments.of(Named.of(<span class="string">&quot;Provider Field Injection with Qualifier&quot;</span>, DependencyCheck.WithQualifier.InjectFieldProvider.class)),</span><br><span class="line">            Arguments.of(Named.of(<span class="string">&quot;Provider Method Injection with Qualifier&quot;</span>, DependencyCheck.WithQualifier.InjectMethodProvider.class))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InjectConstructor</span> <span class="keyword">implements</span> <span class="title class_">TestComponent</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InjectConstructor</span><span class="params">(<span class="meta">@AnotherOne</span> Dependency dependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InjectField</span> <span class="keyword">implements</span> <span class="title class_">TestComponent</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@AnotherOne</span> Dependency dependency;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InjectMethod</span> <span class="keyword">implements</span> <span class="title class_">TestComponent</span> &#123;</span><br><span class="line">    Dependency dependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(<span class="meta">@AnotherOne</span> Dependency dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InjectConstructorProvider</span> <span class="keyword">implements</span> <span class="title class_">TestComponent</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InjectConstructorProvider</span><span class="params">(<span class="meta">@AnotherOne</span> Provider&lt;Dependency&gt; dependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InjectFieldProvider</span> <span class="keyword">implements</span> <span class="title class_">TestComponent</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@AnotherOne</span></span><br><span class="line">    Provider&lt;Dependency&gt; dependency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InjectMethodProvider</span> <span class="keyword">implements</span> <span class="title class_">TestComponent</span> &#123;</span><br><span class="line">    Dependency dependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(<span class="meta">@AnotherOne</span> Provider&lt;Dependency&gt; dependency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dependency = dependency.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包含 Qualifier 标注的依赖的循环依赖检查的参数化测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check cyclic dependencies with qualifier</span></span><br><span class="line"><span class="comment">// A -&gt; @AnotherOne A -&gt; @Named A</span></span><br><span class="line"><span class="meta">@ParameterizedTest(name = &quot;&#123;1&#125; -&gt; @AnotherOne(&#123;0&#125;) -&gt; @Named(\&quot;ChosenOne\&quot;) not cyclic dependencies&quot;)</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_not_throw_exception_if_component_with_same_type_tagged_with_different_qualifier</span><span class="params">(Class&lt;? extends Dependency&gt; anotherDependencyType,</span></span><br><span class="line"><span class="params">                                                                                               Class&lt;? extends Dependency&gt; notCyclicDependencyType)</span> &#123;</span><br><span class="line">    <span class="type">Dependency</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dependency</span>() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    config.bind(Dependency.class, instance, <span class="keyword">new</span> <span class="title class_">NamedLiteral</span>(<span class="string">&quot;ChosenOne&quot;</span>));</span><br><span class="line">    config.bind(Dependency.class, anotherDependencyType, <span class="keyword">new</span> <span class="title class_">AnotherOneLiteral</span>());</span><br><span class="line">    config.bind(Dependency.class, notCyclicDependencyType);</span><br><span class="line"></span><br><span class="line">    assertDoesNotThrow(() -&gt; config.getContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Arguments&gt; <span class="title function_">should_not_throw_exception_if_component_with_same_type_tagged_with_different_qualifier</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Arguments&gt; arguments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Named anotherDependency : List.of(Named.of(<span class="string">&quot;Constructor Injection&quot;</span>, AnotherOneDependencyConstructor.class),</span><br><span class="line">            Named.of(<span class="string">&quot;Field Injection&quot;</span>, DependencyCheck.WithQualifier.AnotherOneDependencyField.class),</span><br><span class="line">            Named.of(<span class="string">&quot;Method Injection&quot;</span>, DependencyCheck.WithQualifier.AnotherOneDependencyMethod.class))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Named notCyclicDependency : List.of(Named.of(<span class="string">&quot;Constructor Injection&quot;</span>, NotCyclicDependencyConstructor.class),</span><br><span class="line">                Named.of(<span class="string">&quot;Field Injection&quot;</span>, DependencyCheck.WithQualifier.NotCyclicDependencyField.class),</span><br><span class="line">                Named.of(<span class="string">&quot;Method Injection&quot;</span>, DependencyCheck.WithQualifier.NotCyclicDependencyMethod.class))) &#123;</span><br><span class="line">            arguments.add(Arguments.of(anotherDependency, notCyclicDependency));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arguments.stream();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AnotherOneDependencyConstructor</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnotherOneDependencyConstructor</span><span class="params">(<span class="meta">@jakarta</span>.inject.Named(<span class="string">&quot;ChosenOne&quot;</span>)</span> Dependency dependency) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AnotherOneDependencyField</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@jakarta</span>.inject.Named(<span class="string">&quot;ChosenOne&quot;</span>) Dependency dependency;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AnotherOneDependencyMethod</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(<span class="meta">@jakarta</span>.inject.Named(<span class="string">&quot;ChosenOne&quot;</span>)</span> Dependency dependency) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NotCyclicDependencyConstructor</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotCyclicDependencyConstructor</span><span class="params">(<span class="meta">@AnotherOne</span> Dependency dependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NotCyclicDependencyField</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@AnotherOne</span> Dependency dependency;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NotCyclicDependencyMethod</span> <span class="keyword">implements</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">(<span class="meta">@AnotherOne</span> Dependency dependency)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Singleton-生命周期管理"><a href="#Singleton-生命周期管理" class="headerlink" title="Singleton-生命周期管理"></a>Singleton-生命周期管理</h1><p>Singleton 生命周期</p>
<ul>
<li>注册组件时，可额外指定是否为 Singleton</li>
<li>注册组件时，可从类对象上提取 Singleton 标注</li>
<li>对于包含 Singleton 标注的组件，在容器范围内提供唯一实例</li>
<li>容器组件默认不是 Single 生命周期</li>
</ul>
<p>基于当前的架构现状，可以将任务转换为如下 todo list</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO default scope should not be singleton</span></span><br><span class="line"><span class="comment">// TODO bind component as singleton scoped</span></span><br><span class="line"><span class="comment">// TODO bind component with qualifiers as singleton scoped</span></span><br><span class="line"><span class="comment">// TODO get scope from component class</span></span><br><span class="line"><span class="comment">// TODO get scope from component with qualifiers</span></span><br><span class="line"><span class="comment">// TODO bind component with customize scope annotation</span></span><br></pre></td></tr></table></figure>

<p>将任务放置在 ContextText.TypeBinding.WithScope 中：</p>
<p><img src="/blogs/25729/image-20240820192553665.png" alt="image-20240820192553665"></p>
<h2 id="默认非单例"><a href="#默认非单例" class="headerlink" title="默认非单例"></a>默认非单例</h2><p>默认非单例模式，目前默认就是非单例模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NotSingletonComponent</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_not_be_singleton_scope_by_default</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(NotSingletonComponent.class, NotSingletonComponent.class);</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> config.getContext();</span><br><span class="line"></span><br><span class="line">    <span class="type">NotSingletonComponent</span> <span class="variable">component1</span> <span class="operator">=</span> context.get(ComponentRef.of(NotSingletonComponent.class)).get();</span><br><span class="line">    <span class="type">NotSingletonComponent</span> <span class="variable">component2</span> <span class="operator">=</span> context.get(ComponentRef.of(NotSingletonComponent.class)).get();</span><br><span class="line"></span><br><span class="line">    assertNotSame(component1, component2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被 Qualifier 标注的依赖，默认也是非单例的，在 WithScope 中再创建一个 WithQualifier 分组，测试带有 Qualifier 标注的依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nested</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WithQualifier</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_not_be_singleton_scope_by_default</span><span class="params">()</span> &#123;</span><br><span class="line">        config.bind(NotSingletonComponent.class, NotSingletonComponent.class, <span class="keyword">new</span> <span class="title class_">AnotherOneLiteral</span>());</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> config.getContext();</span><br><span class="line"></span><br><span class="line">        <span class="type">NotSingletonComponent</span> <span class="variable">component1</span> <span class="operator">=</span> context.get(ComponentRef.of(NotSingletonComponent.class, <span class="keyword">new</span> <span class="title class_">AnotherOneLiteral</span>())).get();</span><br><span class="line">        <span class="type">NotSingletonComponent</span> <span class="variable">component2</span> <span class="operator">=</span> context.get(ComponentRef.of(NotSingletonComponent.class, <span class="keyword">new</span> <span class="title class_">AnotherOneLiteral</span>())).get();</span><br><span class="line"></span><br><span class="line">        assertNotSame(component1, component2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="绑定组件为单例模式"><a href="#绑定组件为单例模式" class="headerlink" title="绑定组件为单例模式"></a>绑定组件为单例模式</h2><h3 id="构建测试"><a href="#构建测试" class="headerlink" title="构建测试"></a>构建测试</h3><p>新建一个 SingletonLiteral，用于作为 bind 的参数，来指定将当前组件注册为单例模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">SingletonLiteral</span><span class="params">()</span> <span class="keyword">implements</span> <span class="title class_">jakarta</span>.inject.Singleton &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType() &#123;</span><br><span class="line">        <span class="keyword">return</span> jakarta.inject.Singleton.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO bind component as singleton scoped</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonComponent</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_bind_component_as_singleton_scope</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(SingletonComponent.class, SingletonComponent.class, <span class="keyword">new</span> <span class="title class_">SingletonLiteral</span>());</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> config.getContext();</span><br><span class="line"></span><br><span class="line">    <span class="type">SingletonComponent</span> <span class="variable">component1</span> <span class="operator">=</span> context.get(ComponentRef.of(SingletonComponent.class)).get();</span><br><span class="line">    <span class="type">SingletonComponent</span> <span class="variable">component2</span> <span class="operator">=</span> context.get(ComponentRef.of(SingletonComponent.class)).get();</span><br><span class="line"></span><br><span class="line">    assertSame(component1, component2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，会抛出一个 IllegalComponentException，抛出的位置是：</p>
<p><img src="/blogs/25729/image-20240820194638100.png" alt="image-20240820194638100"></p>
<p>异常的原因是目前只支持 Qualifier 注解。</p>
<p>修改，让其同时支持 Qualifier 和 Scope 两种注解：</p>
<p><img src="/blogs/25729/image-20240820195127187.png" alt="image-20240820195127187"></p>
<p>运行测试，现在还是异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.NoSuchElementException: No value present</span><br></pre></td></tr></table></figure>

<p>不符合我们预期的 assertSame 的情况。我们预期要么相等要么不相等，不应该是不存在的情况。</p>
<p>原因依然在 bind 方法处，这里将 Scope 注解也当成了 Qualifier ：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-20_19-55-36.png" alt="Snipaste_2024-08-20_19-55-36"></p>
<p>修改，过滤掉非 Qualifier 的注解，并注意当 qualifiers 为空时也需要注册：</p>
<p><img src="/blogs/25729/image-20240820200136437.png" alt="image-20240820200136437"></p>
<p>运行测试，异常，现在是我们期望的 Same 或 NotSame 异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected :world.nobug.tdd.di.ContextTest$TypeBinding$WithScope$SingletonComponent@10b892d5</span><br><span class="line">Actual   :world.nobug.tdd.di.ContextTest$TypeBinding$WithScope$SingletonComponent@3d3f761a</span><br></pre></td></tr></table></figure>

<p>说明目前还是非单例的。</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>使用一个 Proxy 或者 Decorator Pattern，包装 InjectionProvider 修改其创建行为，根据条件创建。</p>
<p>新建一个 ComponentProvider 的子类，其中缓存一个实例，每次 get 实例时先从缓存中取，缓存缺失时才新建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonProvider</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">ComponentProvider</span>&lt;T&gt; &#123;</span><br><span class="line">    T instance;</span><br><span class="line">    ComponentProvider&lt;T&gt; provider;</span><br><span class="line"></span><br><span class="line">    SingletonProvider(ComponentProvider&lt;T&gt; provider) &#123;</span><br><span class="line">        <span class="built_in">this</span>.provider = provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) instance = provider.get(context);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blogs/25729/image-20240820201833198-1724156314344-16.png" alt="image-20240820201833198"></p>
<p>判断，当 Scope 存在时，使用 SingletonProvider 代替 InjectionProvider。</p>
<p>运行测试，通过。</p>
<p>同样的，构造测试，检查被 Scope 和 Qualifier 注解同时标记的依赖是否支持单例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind component with qualifiers as singleton scoped</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_bind_component_as_singleton_scope</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(SingletonComponent.class, SingletonComponent.class, <span class="keyword">new</span> <span class="title class_">SingletonLiteral</span>(), <span class="keyword">new</span> <span class="title class_">AnotherOneLiteral</span>());</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> config.getContext();</span><br><span class="line"></span><br><span class="line">    <span class="type">SingletonComponent</span> <span class="variable">component1</span> <span class="operator">=</span> context.get(ComponentRef.of(SingletonComponent.class, <span class="keyword">new</span> <span class="title class_">AnotherOneLiteral</span>())).get();</span><br><span class="line">    <span class="type">SingletonComponent</span> <span class="variable">component2</span> <span class="operator">=</span> context.get(ComponentRef.of(SingletonComponent.class, <span class="keyword">new</span> <span class="title class_">AnotherOneLiteral</span>())).get();</span><br><span class="line"></span><br><span class="line">    assertSame(component1, component2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，通过。</p>
<h2 id="支持-Singleton"><a href="#支持-Singleton" class="headerlink" title="支持 @Singleton"></a>支持 @Singleton</h2><p>如果一个类被 <code>@Singleton</code> 标记，那么在绑定时可以不指定 Scope，对于这样的类默认为单例模式。</p>
<blockquote>
<p>这个是 JSR330 规范中的一个用例，查看 Scope 注解的注释：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-20_20-37-35.png" alt="Snipaste_2024-08-20_20-37-35"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonComponentAnnotated</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造测试-12"><a href="#构造测试-12" class="headerlink" title="构造测试"></a>构造测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO get scope from component class</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_retrieve_scope_annotation_from_component</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 未指定 scope 时，默认将标记了 Singleton 的类作为单例</span></span><br><span class="line">    config.bind(SingletonComponentAnnotated.class, SingletonComponentAnnotated.class);</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> config.getContext();</span><br><span class="line"></span><br><span class="line">    <span class="type">SingletonComponentAnnotated</span> <span class="variable">component1</span> <span class="operator">=</span> context.get(ComponentRef.of(SingletonComponentAnnotated.class)).get();</span><br><span class="line">    <span class="type">SingletonComponentAnnotated</span> <span class="variable">component2</span> <span class="operator">=</span> context.get(ComponentRef.of(SingletonComponentAnnotated.class)).get();</span><br><span class="line"></span><br><span class="line">    assertSame(component1, component2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected :world.nobug.tdd.di.ContextTest$TypeBinding$WithScope$SingletonComponentAnnotated@3a4b0e5d</span><br><span class="line">Actual   :world.nobug.tdd.di.ContextTest$TypeBinding$WithScope$SingletonComponentAnnotated@10b892d5</span><br></pre></td></tr></table></figure>

<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p>目前使用的 bind 方法是：</p>
<p><img src="/blogs/25729/image-20240820204448777.png" alt="image-20240820204448777"></p>
<p>修改为：</p>
<p><img src="/blogs/25729/image-20240820204544810.png" alt="image-20240820204544810"></p>
<p>因为，重载的 bind 方法中现在已经支持 <code>Annotation... annotations</code> 参数为空的情况了。</p>
<p>同样的，构造组件同时被 Qualifier 标注时的测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO get scope from component with qualifiers</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_retrieve_scope_annotation_from_component</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 未指定 scope 时，默认将标记了 Singleton 的类作为单例</span></span><br><span class="line">    config.bind(SingletonComponentAnnotated.class, SingletonComponentAnnotated.class, <span class="keyword">new</span> <span class="title class_">AnotherOneLiteral</span>());</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> config.getContext();</span><br><span class="line"></span><br><span class="line">    <span class="type">SingletonComponentAnnotated</span> <span class="variable">component1</span> <span class="operator">=</span> context.get(ComponentRef.of(SingletonComponentAnnotated.class, <span class="keyword">new</span> <span class="title class_">AnotherOneLiteral</span>())).get();</span><br><span class="line">    <span class="type">SingletonComponentAnnotated</span> <span class="variable">component2</span> <span class="operator">=</span> context.get(ComponentRef.of(SingletonComponentAnnotated.class, <span class="keyword">new</span> <span class="title class_">AnotherOneLiteral</span>())).get();</span><br><span class="line"></span><br><span class="line">    assertSame(component1, component2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected :world.nobug.tdd.di.ContextTest$TypeBinding$WithScope$SingletonComponentAnnotated@2ddc8ecb</span><br><span class="line">Actual   :world.nobug.tdd.di.ContextTest$TypeBinding$WithScope$SingletonComponentAnnotated@229d10bd</span><br></pre></td></tr></table></figure>

<p>原因是目前并没有取组件上标记的 <code>@Singleton</code> , 只取了 bind 方法参数中的 Scope 注解：</p>
<p><img src="/blogs/25729/image-20240820205249652.png" alt="image-20240820205249652"></p>
<p>增加从组件上获取 Scope 注解的实现，当无法从参数中获取到 Scope 时，尝试将 scope 赋值为从组件上获取到的 Scope 注解：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-20_20-59-15.png" alt="Snipaste_2024-08-20_20-59-15"></p>
<p>运行测试，通过。</p>
<h2 id="小-bug"><a href="#小-bug" class="headerlink" title="小 bug"></a>小 bug</h2><p><img src="/blogs/25729/image-20240820210355336.png" alt="image-20240820210355336"></p>
<p>这里不应该从 type 取注解，而是应该从 implementation 上取。</p>
<h2 id="依赖检查-1"><a href="#依赖检查-1" class="headerlink" title="依赖检查"></a>依赖检查</h2><h3 id="依赖不存在"><a href="#依赖不存在" class="headerlink" title="依赖不存在"></a>依赖不存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dependencies not exist</span></span><br><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_dependency_not_found</span><span class="params">(Class&lt;? extends TestComponent&gt; componentType)</span> &#123;</span><br><span class="line">    config.bind(TestComponent.class, componentType);</span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyNotFoundException</span> <span class="variable">exception</span> <span class="operator">=</span> assertThrows(DependencyNotFoundException.class, () -&gt; &#123;</span><br><span class="line">        config.getContext();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    assertEquals(Dependency.class, exception.getDependency().type());</span><br><span class="line">    assertEquals(TestComponent.class, exception.getComponent().type());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加一个被 @Singleton 标记的测试用例：</p>
<p><img src="/blogs/25729/image-20240821093308594.png" alt="image-20240821093308594"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MissingDependencyScope</span> <span class="keyword">implements</span> <span class="title class_">TestComponent</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Dependency dependency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.opentest4j.AssertionFailedError: Expected world.nobug.tdd.di.DependencyNotFoundException to be thrown, but nothing was thrown.</span><br></pre></td></tr></table></figure>

<p>我们预期应该抛出依赖不存在的异常，但是这里并没有抛出。说明在 config.getContext() 中 checkDependencies 时并没有获取到该组件的正确依赖。因为当前组件被构建成  SingletonProvider 并且当前并没有实现 getDependencies 方法，实现该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonProvider</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">ComponentProvider</span>&lt;T&gt; &#123;</span><br><span class="line">    T instance;</span><br><span class="line">    ComponentProvider&lt;T&gt; provider;</span><br><span class="line"></span><br><span class="line">    SingletonProvider(ComponentProvider&lt;T&gt; provider) &#123;</span><br><span class="line">        <span class="built_in">this</span>.provider = provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = provider.get(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ComponentRef&lt;?&gt;&gt; getDependencies() &#123;</span><br><span class="line">        <span class="keyword">return</span> provider.getDependencies();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，通过。</p>
<p>再增加一个 Provider包装的依赖的测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arguments.of(Named.of(<span class="string">&quot;Provider Scope&quot;</span>, DependencyCheck.MissingDependencyProviderScope.class))</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MissingDependencyProviderScope</span> <span class="keyword">implements</span> <span class="title class_">TestComponent</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Provider&lt;Dependency&gt; dependency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，通过。</p>
<h3 id="循环依赖-1"><a href="#循环依赖-1" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>对于 Scope 的循环依赖是一个可选项。</p>
<p>这种情况有一个很典型的优化：当两个组件都是构造函数相互依赖时，并且其中有一个是 Singleton 的，那么这个循环依赖是不成立的，因为并不是每次都需要构造新对象。</p>
<h2 id="自定义-Scope-注解"><a href="#自定义-Scope-注解" class="headerlink" title="自定义 Scope 注解"></a>自定义 Scope 注解</h2><p>自定义一个 Scope 注解 Pooled，来表示指定数量的多例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Pooled &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">record</span> <span class="title class_">PooledLiteral</span><span class="params">()</span> <span class="keyword">implements</span> <span class="title class_">Pooled</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Pooled.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，需要定义一个 Provider：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PooledProvider</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">ContextConfig</span>.ComponentProvider&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> current;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; instancePool = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ContextConfig.ComponentProvider&lt;T&gt; provider;</span><br><span class="line"></span><br><span class="line">    PooledProvider(ContextConfig.ComponentProvider&lt;T&gt; provider) &#123;</span><br><span class="line">        <span class="built_in">this</span>.provider = provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instancePool.size() &lt; MAX) instancePool.add(provider.get(context));</span><br><span class="line">        <span class="keyword">return</span> instancePool.get(current++ % MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ComponentRef&lt;?&gt;&gt; getDependencies() &#123;</span><br><span class="line">        <span class="keyword">return</span> provider.getDependencies();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造测试-13"><a href="#构造测试-13" class="headerlink" title="构造测试"></a>构造测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO bind component with customize scope annotation</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PooledComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_bind_component_with_customize_scope_annotation</span><span class="params">()</span> &#123;</span><br><span class="line">    config.bind(PooledComponent.class, PooledComponent.class, <span class="keyword">new</span> <span class="title class_">PooledLiteral</span>());</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> config.getContext();</span><br><span class="line"></span><br><span class="line">    List&lt;PooledComponent&gt; instances = IntStream.range(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">            .mapToObj(i -&gt; context.get(ComponentRef.of(PooledComponent.class)).get()).toList();</span><br><span class="line">    assertEquals(PooledProvider.MAX, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(instances).size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，将失败：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected :2</span><br><span class="line">Actual   :1</span><br></pre></td></tr></table></figure>

<p>因为我们当前将所有 Scope 的注解都设置为单例。</p>
<h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><p>我们预期的方式是，为 config 配置指定的 Scope 应该如何创建对应的 Provider：</p>
<p><img src="/blogs/25729/image-20240821103932822.png" alt="image-20240821103932822"></p>
<p>创建该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;ScopeType <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; <span class="keyword">void</span> <span class="title function_">scope</span><span class="params">(Class&lt;ScopeType&gt; scopeType, Function&lt;ComponentProvider&lt;?&gt;, ComponentProvider&lt;?&gt;&gt; provider)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建一个字段来保存 scope 信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Function&lt;ComponentProvider&lt;?&gt;, ComponentProvider&lt;?&gt;&gt;&gt; scopes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>那么 scope 方法的实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;ScopeType <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; <span class="keyword">void</span> <span class="title function_">scope</span><span class="params">(Class&lt;ScopeType&gt; scopeType, Function&lt;ComponentProvider&lt;?&gt;, ComponentProvider&lt;?&gt;&gt; provider)</span> &#123;</span><br><span class="line">    scopes.put(scopeType, provider);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后还需要新建一个默认构造函数，并在其中初始化默认的 Scope 的 Provider 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ContextConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    scopes.put(Singleton.class, SingletonProvider::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 bind 方法中获取 scope 的 provider 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (scope.isPresent()) provider = scopes.get(scope.get().annotationType()).apply(provider);</span><br></pre></td></tr></table></figure>

<p>运行测试，通过。</p>
<h2 id="重构-7"><a href="#重构-7" class="headerlink" title="重构"></a>重构</h2><p>重构之前，先将 ComponentProvider 和 SingletonProvider 移动到最外层。</p>
<p>为下面的参数定义一个函数式接口，简化代码：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-21_11-10-20.png" alt="Snipaste_2024-08-21_11-10-20"></p>
<p><img src="/blogs/25729/Snipaste_2024-08-21_11-13-29.png" alt="Snipaste_2024-08-21_11-13-29"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ScopeProvider</span> &#123;</span><br><span class="line">    ComponentProvider&lt;?&gt; create(ComponentProvider&lt;?&gt; provider);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的修改后：</p>
<p><img src="/blogs/25729/image-20240821111855275.png" alt="image-20240821111855275"></p>
<p><img src="/blogs/25729/image-20240821111943949.png" alt="image-20240821111943949"></p>
<h3 id="重构简化-bind-方法"><a href="#重构简化-bind-方法" class="headerlink" title="重构简化 bind 方法"></a>重构简化 bind 方法</h3><p>目前，这个 bind 方法中的实现比较复杂：</p>
<p><img src="/blogs/25729/image-20240821114336444.png" alt="image-20240821114336444"></p>
<p>分析，这个代码中主要是对不同类型的 annotations 参数进行处理，目前这个参数中包含的的类型有：</p>
<ul>
<li>Scope</li>
<li>Qualifier</li>
<li>其他</li>
</ul>
<p>我们要做的就是将 annotations 根据 Scope、Qualifier 和 其他来进行分类。</p>
<p>这里我们可以将 “其他” 这个类别用一个自定义的注解表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="meta">@interface</span> Illegal &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并定义一个分类函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; typeOf(Annotation annotation) &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type = annotation.annotationType();</span><br><span class="line">    <span class="keyword">return</span> Stream.of(Qualifier.class, Scope.class)</span><br><span class="line">            .filter(type::isAnnotationPresent)</span><br><span class="line">            .findFirst()</span><br><span class="line">            .orElse(Illegal.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么分组函数就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Class&lt;?&gt;, List&lt;Annotation&gt;&gt; annotationGroups =</span><br><span class="line">        Arrays.stream(annotations).collect(Collectors.groupingBy(<span class="built_in">this</span>::typeOf, Collectors.toList()));</span><br></pre></td></tr></table></figure>

<p>然后通过使用分组的数据来简化后面的代码逻辑。</p>
<p>首先，是对 Illegal 情况的判断：</p>
<p><img src="/blogs/25729/image-20240821134009469.png" alt="image-20240821134009469"></p>
<p>简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (annotationGroups.containsKey(Illegal.class)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalComponentException</span>();</span><br></pre></td></tr></table></figure>

<h2 id="Scope-Sad-Path"><a href="#Scope-Sad-Path" class="headerlink" title="Scope Sad Path"></a>Scope Sad Path</h2><p>增加几个关于 Scope 的 sad path</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO multi scope provided</span></span><br><span class="line"><span class="comment">// TODO multi scope annotated</span></span><br><span class="line"><span class="comment">// TODO undefined scope</span></span><br></pre></td></tr></table></figure>

<p>注册时为组件设置多个 scope，构造测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO multi scope provided</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_multi_scope_provided</span><span class="params">()</span> &#123;</span><br><span class="line">    config.scope(Pooled.class, PooledProvider::<span class="keyword">new</span>);</span><br><span class="line">    config.scope(Singleton.class, SingletonProvider::<span class="keyword">new</span>);</span><br><span class="line">    assertThrows(IllegalComponentException.class,</span><br><span class="line">            () -&gt; config.bind(PooledComponent.class, PooledComponent.class, <span class="keyword">new</span> <span class="title class_">PooledLiteral</span>(), <span class="keyword">new</span> <span class="title class_">SingletonLiteral</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，不通过。说明并没有判断设置多个 Scope 的情况。</p>
<p>增加判断：</p>
<p><img src="/blogs/25729/Snipaste_2024-08-21_14-20-48.png" alt="Snipaste_2024-08-21_14-20-48"></p>
<p>多个 Scope 注解标注同一个组件时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multi scope annotated</span></span><br><span class="line"><span class="meta">@Singleton</span> <span class="meta">@Pooled</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MultiScopeAnnotatedComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_multi_scope_annotated</span><span class="params">()</span> &#123;</span><br><span class="line">    config.scope(Pooled.class, PooledProvider::<span class="keyword">new</span>);</span><br><span class="line">    assertThrows(IllegalComponentException.class,</span><br><span class="line">            () -&gt; config.bind(MultiScopeAnnotatedComponent.class, MultiScopeAnnotatedComponent.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，通过。</p>
<p>注册时，设置未定义的 Scope：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO undefined scope</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">should_throw_exception_if_undefined_scope</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalComponentException.class,</span><br><span class="line">            () -&gt; config.bind(PooledComponent.class, PooledComponent.class, <span class="keyword">new</span> <span class="title class_">PooledLiteral</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个测试中并没有指定在容器中配置 Pooled 注解如何定义 Provider，也就是没有执行 <code>config.scope(Pooled.class, PooledProvider::new);</code></p>
<p>运行测试，异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.opentest4j.AssertionFailedError: Unexpected exception type thrown ==&gt; expected: &lt;world.nobug.tdd.di.IllegalComponentException&gt; but was: &lt;java.lang.NullPointerException&gt;</span><br></pre></td></tr></table></figure>

<p>有一个空指针异常，是因为无法获取 Pooled 注解对应的 Provider，获取到的为 null。</p>
<p>修改实现：</p>
<p><img src="/blogs/25729/image-20240821144348995.png" alt="image-20240821144348995"></p>
<p>运行测试，通过。</p>
<h1 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h1><p>Run …. with Coverage 检查代码的测试覆盖率：</p>
<p><img src="/blogs/25729/image-20240821145440311.png" alt="image-20240821145440311"></p>
<p><img src="/blogs/25729/image-20240821150535770.png" alt="image-20240821150535770"></p>
<p>虽然我们没有做到 100% 的代码覆盖了，但是我们做到了 100% 的功能覆盖，对于有些行因为语言特性的需求或者其他原因的代码，也没有必要写测试覆盖。</p>
<h1 id="走的更远"><a href="#走的更远" class="headerlink" title="走的更远"></a>走的更远</h1><p>可以引入 Jakarta 的 tck 包，来测试当前容器对 JSR330 规范的兼容度，并完善对 JSR330 规范的兼容。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="彭嘉俊 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>彭嘉俊
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://nobug.world/blogs/25729/" title="TDD实现Spring（DI容器）">https://nobug.world/blogs/25729/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <span class="social-link">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </span>

          <img class="social-item-img" src="/images/wechat_channel.png">
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/TDD/" rel="tag"># TDD</a>
          </div>

        
  <div class="social-like a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a>
      <a class="a2a_button_wechat"></a>
  </div>

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blogs/59413/" rel="prev" title="Kubernetes网络和Cilium网络工程师指南">
                  <i class="fa fa-angle-left"></i> Kubernetes网络和Cilium网络工程师指南
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blogs/21720/" rel="next" title="记一次为NexT主题提交PR的经过">
                  记一次为NexT主题提交PR的经过 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">彭嘉俊</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">159k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">9:40</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        站点访客数<span id="busuanzi_value_site_uv"></span>人次
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        站点总访问量<span id="busuanzi_value_site_pv"></span>次
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  





  <script src="/js/third-party/addtoany.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blogs-waline.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"请文明评论呀","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":false,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/blogs/25729/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
